{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"learn2learn is a software library for meta-learning research. learn2learn builds on top of PyTorch to accelerate two aspects of the meta-learning research cycle: fast prototyping , essential in letting researchers quickly try new ideas, and correct reproducibility , ensuring that these ideas are evaluated fairly. learn2learn provides low-level utilities and unified interface to create new algorithms and domains, together with high-quality implementations of existing algorithms and standardized benchmarks. It retains compatibility with torchvision , torchaudio , torchtext , cherry , and any other PyTorch-based library you might be using. To learn more, see our whitepaper: arXiv:2008.12284 Overview learn2learn.data : TaskDataset and transforms to create few-shot tasks from any PyTorch dataset. learn2learn.vision : Models, datasets, and benchmarks for computer vision and few-shot learning. learn2learn.gym : Environment and utilities for meta-reinforcement learning. learn2learn.algorithms : High-level wrappers for existing meta-learning algorithms. learn2learn.optim : Utilities and algorithms for differentiable optimization and meta-descent. Resources Website: http://learn2learn.net/ Documentation: http://learn2learn.net/docs/learn2learn Tutorials: http://learn2learn.net/tutorials/getting_started/ Examples: https://github.com/learnables/learn2learn/tree/master/examples GitHub: https://github.com/learnables/learn2learn/ Slack: http://slack.learn2learn.net/ Installation \u00b6 1 pip install learn2learn Snippets & Examples \u00b6 The following snippets provide a sneak peek at the functionalities of learn2learn. High-level Wrappers \u00b6 Few-Shot Learning with MAML For more algorithms (ProtoNets, ANIL, Meta-SGD, Reptile, Meta-Curvature, KFO) refer to the examples folder. Most of them can be implemented with with the `GBML` wrapper. ( documentation ). 1 2 3 4 5 6 7 8 9 10 maml = l2l . algorithms . MAML ( model , lr = 0.1 ) opt = torch . optim . SGD ( maml . parameters (), lr = 0.001 ) for iteration in range ( 10 ): opt . zero_grad () task_model = maml . clone () # torch.clone() for nn.Modules adaptation_loss = compute_loss ( task_model ) task_model . adapt ( adaptation_loss ) # computes gradient, update task_model in-place evaluation_loss = compute_loss ( task_model ) evaluation_loss . backward () # gradients w.r.t. maml.parameters() opt . step () Meta-Descent with Hypergradient Learn any kind of optimization algorithm with the `LearnableOptimizer`. ( example and documentation ) 1 2 3 4 5 6 7 8 9 10 11 linear = nn . Linear ( 784 , 10 ) transform = l2l . optim . ModuleTransform ( l2l . nn . Scale ) metaopt = l2l . optim . LearnableOptimizer ( linear , transform , lr = 0.01 ) # metaopt has .step() opt = torch . optim . SGD ( metaopt . parameters (), lr = 0.001 ) # metaopt also has .parameters() metaopt . zero_grad () opt . zero_grad () error = loss ( linear ( X ), y ) error . backward () opt . step () # update metaopt metaopt . step () # update linear Learning Domains \u00b6 Custom Few-Shot Dataset Many standardized datasets (Omniglot, mini-/tiered-ImageNet, FC100, CIFAR-FS) are readily available in `learn2learn.vision.datasets`. ( documentation ) 1 2 3 4 5 6 7 8 9 10 dataset = l2l . data . MetaDataset ( MyDataset ()) # any PyTorch dataset transforms = [ # Easy to define your own transform l2l . data . transforms . NWays ( dataset , n = 5 ), l2l . data . transforms . KShots ( dataset , k = 1 ), l2l . data . transforms . LoadData ( dataset ), ] taskset = TaskDataset ( dataset , transforms , num_tasks = 20000 ) for task in taskset : X , y = task # Meta-train on the task Environments and Utilities for Meta-RL Parallelize your own meta-environments with `AsyncVectorEnv`, or use the standardized ones. ( documentation ) 1 2 3 4 5 6 7 8 9 10 11 def make_env (): env = l2l . gym . HalfCheetahForwardBackwardEnv () env = cherry . envs . ActionSpaceScaler ( env ) return env env = l2l . gym . AsyncVectorEnv ([ make_env for _ in range ( 16 )]) # uses 16 threads for task_config in env . sample_tasks ( 20 ): env . set_task ( task ) # all threads receive the same task state = env . reset () # use standard Gym API action = my_policy ( env ) env . step ( action ) Low-Level Utilities \u00b6 Differentiable Optimization Learn and differentiate through updates of PyTorch Modules. ( documentation ) 1 2 3 4 5 6 7 8 9 10 11 12 13 model = MyModel () transform = l2l . optim . KroneckerTransform ( l2l . nn . KroneckerLinear ) learned_update = l2l . optim . ParameterUpdate ( # learnable update function model . parameters (), transform ) clone = l2l . clone_module ( model ) # torch.clone() for nn.Modules error = loss ( clone ( X ), y ) updates = learned_update ( # similar API as torch.autograd.grad error , clone . parameters (), create_graph = True , ) l2l . update_module ( clone , updates = updates ) loss ( clone ( X ), y ) . backward () # Gradients w.r.t model.parameters() and learned_update.parameters() Changelog \u00b6 A human-readable changelog is available in the CHANGELOG.md file. Citation \u00b6 To cite the learn2learn repository in your academic publications, please use the following reference. Arnold, Sebastien M. R., Praateek Mahajan, Debajyoti Datta, Ian Bunner, and Konstantinos Saitas Zarkias. 2020. \u201clearn2learn: A Library for Meta-Learning Research.\u201d arXiv [cs.LG]. http://arxiv.org/abs/2008.12284. You can also use the following Bibtex entry. 1 2 3 4 5 6 7 8 9 10 11 @article { Arnold2020-ss , title = \"learn2learn: A Library for {Meta-Learning} Research\" , author = \"Arnold, S{\\'e}bastien M R and Mahajan, Praateek and Datta, Debajyoti and Bunner, Ian and Zarkias, Konstantinos Saitas\" , month = aug , year = 2020 , url = \"http://arxiv.org/abs/2008.12284\" , archivePrefix = \"arXiv\" , primaryClass = \"cs.LG\" , eprint = \"2008.12284\" } Acknowledgements & Friends \u00b6 TorchMeta is similar library, with a focus on datasets for supervised meta-learning. higher is a PyTorch library that enables differentiating through optimization inner-loops. While they monkey-patch nn.Module to be stateless, learn2learn retains the stateful PyTorch look-and-feel. For more information, refer to their ArXiv paper . We are thankful to the following open-source implementations which helped guide the design of learn2learn: Tristan Deleu's pytorch-maml-rl Jonas Rothfuss' ProMP Kwonjoon Lee's MetaOptNet Han-Jia Ye's and Hexiang Hu's FEAT","title":"Home"},{"location":"#installation","text":"1 pip install learn2learn","title":"Installation"},{"location":"#snippets-examples","text":"The following snippets provide a sneak peek at the functionalities of learn2learn.","title":"Snippets &amp; Examples"},{"location":"#high-level-wrappers","text":"Few-Shot Learning with MAML For more algorithms (ProtoNets, ANIL, Meta-SGD, Reptile, Meta-Curvature, KFO) refer to the examples folder. Most of them can be implemented with with the `GBML` wrapper. ( documentation ). 1 2 3 4 5 6 7 8 9 10 maml = l2l . algorithms . MAML ( model , lr = 0.1 ) opt = torch . optim . SGD ( maml . parameters (), lr = 0.001 ) for iteration in range ( 10 ): opt . zero_grad () task_model = maml . clone () # torch.clone() for nn.Modules adaptation_loss = compute_loss ( task_model ) task_model . adapt ( adaptation_loss ) # computes gradient, update task_model in-place evaluation_loss = compute_loss ( task_model ) evaluation_loss . backward () # gradients w.r.t. maml.parameters() opt . step () Meta-Descent with Hypergradient Learn any kind of optimization algorithm with the `LearnableOptimizer`. ( example and documentation ) 1 2 3 4 5 6 7 8 9 10 11 linear = nn . Linear ( 784 , 10 ) transform = l2l . optim . ModuleTransform ( l2l . nn . Scale ) metaopt = l2l . optim . LearnableOptimizer ( linear , transform , lr = 0.01 ) # metaopt has .step() opt = torch . optim . SGD ( metaopt . parameters (), lr = 0.001 ) # metaopt also has .parameters() metaopt . zero_grad () opt . zero_grad () error = loss ( linear ( X ), y ) error . backward () opt . step () # update metaopt metaopt . step () # update linear","title":"High-level Wrappers"},{"location":"#learning-domains","text":"Custom Few-Shot Dataset Many standardized datasets (Omniglot, mini-/tiered-ImageNet, FC100, CIFAR-FS) are readily available in `learn2learn.vision.datasets`. ( documentation ) 1 2 3 4 5 6 7 8 9 10 dataset = l2l . data . MetaDataset ( MyDataset ()) # any PyTorch dataset transforms = [ # Easy to define your own transform l2l . data . transforms . NWays ( dataset , n = 5 ), l2l . data . transforms . KShots ( dataset , k = 1 ), l2l . data . transforms . LoadData ( dataset ), ] taskset = TaskDataset ( dataset , transforms , num_tasks = 20000 ) for task in taskset : X , y = task # Meta-train on the task Environments and Utilities for Meta-RL Parallelize your own meta-environments with `AsyncVectorEnv`, or use the standardized ones. ( documentation ) 1 2 3 4 5 6 7 8 9 10 11 def make_env (): env = l2l . gym . HalfCheetahForwardBackwardEnv () env = cherry . envs . ActionSpaceScaler ( env ) return env env = l2l . gym . AsyncVectorEnv ([ make_env for _ in range ( 16 )]) # uses 16 threads for task_config in env . sample_tasks ( 20 ): env . set_task ( task ) # all threads receive the same task state = env . reset () # use standard Gym API action = my_policy ( env ) env . step ( action )","title":"Learning Domains"},{"location":"#low-level-utilities","text":"Differentiable Optimization Learn and differentiate through updates of PyTorch Modules. ( documentation ) 1 2 3 4 5 6 7 8 9 10 11 12 13 model = MyModel () transform = l2l . optim . KroneckerTransform ( l2l . nn . KroneckerLinear ) learned_update = l2l . optim . ParameterUpdate ( # learnable update function model . parameters (), transform ) clone = l2l . clone_module ( model ) # torch.clone() for nn.Modules error = loss ( clone ( X ), y ) updates = learned_update ( # similar API as torch.autograd.grad error , clone . parameters (), create_graph = True , ) l2l . update_module ( clone , updates = updates ) loss ( clone ( X ), y ) . backward () # Gradients w.r.t model.parameters() and learned_update.parameters()","title":"Low-Level Utilities"},{"location":"#changelog","text":"A human-readable changelog is available in the CHANGELOG.md file.","title":"Changelog"},{"location":"#citation","text":"To cite the learn2learn repository in your academic publications, please use the following reference. Arnold, Sebastien M. R., Praateek Mahajan, Debajyoti Datta, Ian Bunner, and Konstantinos Saitas Zarkias. 2020. \u201clearn2learn: A Library for Meta-Learning Research.\u201d arXiv [cs.LG]. http://arxiv.org/abs/2008.12284. You can also use the following Bibtex entry. 1 2 3 4 5 6 7 8 9 10 11 @article { Arnold2020-ss , title = \"learn2learn: A Library for {Meta-Learning} Research\" , author = \"Arnold, S{\\'e}bastien M R and Mahajan, Praateek and Datta, Debajyoti and Bunner, Ian and Zarkias, Konstantinos Saitas\" , month = aug , year = 2020 , url = \"http://arxiv.org/abs/2008.12284\" , archivePrefix = \"arXiv\" , primaryClass = \"cs.LG\" , eprint = \"2008.12284\" }","title":"Citation"},{"location":"#acknowledgements-friends","text":"TorchMeta is similar library, with a focus on datasets for supervised meta-learning. higher is a PyTorch library that enables differentiating through optimization inner-loops. While they monkey-patch nn.Module to be stateless, learn2learn retains the stateful PyTorch look-and-feel. For more information, refer to their ArXiv paper . We are thankful to the following open-source implementations which helped guide the design of learn2learn: Tristan Deleu's pytorch-maml-rl Jonas Rothfuss' ProMP Kwonjoon Lee's MetaOptNet Han-Jia Ye's and Hexiang Hu's FEAT","title":"Acknowledgements &amp; Friends"},{"location":"changelog/","text":"Changelog \u00b6 All notable changes to this project will be documented in this file. The format is based on Keep a Changelog , and this project adheres to Semantic Versioning . [Unreleased] \u00b6 Added \u00b6 New vision example: MAML++. (@ DubiousCactus ) Add tutorial: \"Demystifying Task Transforms\", ( Varad Pimpalkhute ) Add l2l.nn.MetaModule and l2l.nn.ParameterTransform for parameter-efficient finetuning. Add l2l.nn.freeze and l2l.nn.unfreeze . Add Adapters and LoRA examples. Changed \u00b6 Documentation: uses mkdocstrings instead of pydoc-markdown . Fixed \u00b6 Example for detach_module . ( Nimish Sanghi ) Loading duplicate FGVC Aircraft images. v0.1.7 \u00b6 Added \u00b6 Bounding box cropping for Aircraft and CUB200. Pretrained weights for vision models with: l2l.vision.models.get_pretrained_backbone() . Add keep_requires_grad flag to detach_module . ( Zhaofeng Wu ) Changed \u00b6 Fixed \u00b6 Fix arguments when instantiating l2l.nn.Scale . Fix train_loss logging in LightningModule implementations with PyTorch-Lightning 1.5. Fix RandomClassRotation ( #283 ) to incorporate multi-channelled inputs. ( Varad Pimpalkhute ) Fix memory leak in maml.py and meta-sgd.py and add tests to maml_test.py and metasgd_test.py to check for possible future memory leaks. ( #284 ) ( Kevin Zhang ) v0.1.6 \u00b6 Added \u00b6 PyTorch Lightning interface to MAML, ANIL, ProtoNet, MetaOptNet. Automatic batcher for Lightning: l2l.data.EpisodicBatcher . l2l.nn.PrototypicalClassifier and l2l.nn.SVMClassifier . Add l2l.vision.models.WRN28 . Separate modules for CNN4Backbone , ResNet12Backbone , WRN28Backbones w/ pretrained weights. Add l2l.data.OnDeviceDataset and implement device parameter for benchmarks. (Beta) Add l2l.data.partition_task and l2l.data.InfiniteIterator . Changed \u00b6 Renamed and clarify dropout parameters for ResNet12 . Fixed \u00b6 Improved support for 1D inputs in l2l.nn.KroneckerLinear . (@timweiland) v0.1.5 \u00b6 Fixed \u00b6 Fix setup.py for windows installs. v0.1.4 \u00b6 Added \u00b6 FilteredMetaDatasest filter the classes used to sample tasks. UnionMetaDatasest to get the union of multiple MetaDatasets. Alias MiniImageNetCNN to CNN4 and add embedding_size argument. Optional data augmentation schemes for vision benchmarks. l2l.vision.models.ResNet12 l2l.vision.datasets.DescribableTextures l2l.vision.datasets.Quickdraw l2l.vision.datasets.FGVCFungi Add labels_to_indices and indices_to_labels as optional arguments to l2l.data.MetaDataset . Changed \u00b6 Updated reference for citations. v0.1.3 \u00b6 Added \u00b6 l2l.vision.datasets.CUBirds200 . Changed \u00b6 Optimization transforms can be accessed directly through l2l.optim , e.g. l2l.optim.KroneckerTransform . All vision models adhere to the .features and .classifier interface. Fixed \u00b6 Fix clone_module for Modules whose submodules share parameters. v0.1.2 \u00b6 Added \u00b6 New example: Meta-World example with MAML-TRPO with it's own env wrapper. (@ Kostis-S-Z ) l2l.vision.benchmarks interface. Differentiable optimization utilities in l2l.optim . (including l2l.optim.LearnableOptimizer for meta-descent) General gradient-based meta-learning wrapper in l2l.algorithms.GBML . Various nn.Modules in l2l.nn . l2l.update_module as a more general alternative to l2l.algorithms.maml_update . Changed \u00b6 Fixed \u00b6 clone_module supports non-Module objects. VGG flowers now relies on tarfile.open() instead of tarfile.TarFile(). v0.1.1 \u00b6 Added \u00b6 New tutorial: 'Feature Reuse with ANIL'. (@ewinapun) Changed \u00b6 Mujoco imports optional for docs: the import error is postponed to first method call. Fixed \u00b6 MAML() and clone_module support for RNN modules. v0.1.0.1 \u00b6 Fixed \u00b6 Remove Cython dependency when installing from PyPI and clean up package distribution. v0.1.0 \u00b6 Added \u00b6 A CHANGELOG.md file. New vision datasets: FC100, tiered-Imagenet, FGVCAircraft, VGGFlowers102. New vision examples: Reptile & ANIL. Extensive benchmarks of all vision examples. Changed \u00b6 Re-wrote TaskDataset and task transforms in Cython, for a 20x speed-up. Travis testing with different versions of Python (3.6, 3.7), torch (1.1, 1.2, 1.3, 1.4), and torchvision (0.3, 0.4, 0.5). New Material doc theme with links to changelog and examples. Fixed \u00b6 Support for RandomClassRotation with newer versions of torchvision. Various minor fixes in the examples. Add Dropbox download if GDrive fails for FC100.","title":"Changelog"},{"location":"changelog/#changelog","text":"All notable changes to this project will be documented in this file. The format is based on Keep a Changelog , and this project adheres to Semantic Versioning .","title":"Changelog"},{"location":"changelog/#unreleased","text":"","title":"[Unreleased]"},{"location":"changelog/#added","text":"New vision example: MAML++. (@ DubiousCactus ) Add tutorial: \"Demystifying Task Transforms\", ( Varad Pimpalkhute ) Add l2l.nn.MetaModule and l2l.nn.ParameterTransform for parameter-efficient finetuning. Add l2l.nn.freeze and l2l.nn.unfreeze . Add Adapters and LoRA examples.","title":"Added"},{"location":"changelog/#changed","text":"Documentation: uses mkdocstrings instead of pydoc-markdown .","title":"Changed"},{"location":"changelog/#fixed","text":"Example for detach_module . ( Nimish Sanghi ) Loading duplicate FGVC Aircraft images.","title":"Fixed"},{"location":"changelog/#v017","text":"","title":"v0.1.7"},{"location":"changelog/#added_1","text":"Bounding box cropping for Aircraft and CUB200. Pretrained weights for vision models with: l2l.vision.models.get_pretrained_backbone() . Add keep_requires_grad flag to detach_module . ( Zhaofeng Wu )","title":"Added"},{"location":"changelog/#changed_1","text":"","title":"Changed"},{"location":"changelog/#fixed_1","text":"Fix arguments when instantiating l2l.nn.Scale . Fix train_loss logging in LightningModule implementations with PyTorch-Lightning 1.5. Fix RandomClassRotation ( #283 ) to incorporate multi-channelled inputs. ( Varad Pimpalkhute ) Fix memory leak in maml.py and meta-sgd.py and add tests to maml_test.py and metasgd_test.py to check for possible future memory leaks. ( #284 ) ( Kevin Zhang )","title":"Fixed"},{"location":"changelog/#v016","text":"","title":"v0.1.6"},{"location":"changelog/#added_2","text":"PyTorch Lightning interface to MAML, ANIL, ProtoNet, MetaOptNet. Automatic batcher for Lightning: l2l.data.EpisodicBatcher . l2l.nn.PrototypicalClassifier and l2l.nn.SVMClassifier . Add l2l.vision.models.WRN28 . Separate modules for CNN4Backbone , ResNet12Backbone , WRN28Backbones w/ pretrained weights. Add l2l.data.OnDeviceDataset and implement device parameter for benchmarks. (Beta) Add l2l.data.partition_task and l2l.data.InfiniteIterator .","title":"Added"},{"location":"changelog/#changed_2","text":"Renamed and clarify dropout parameters for ResNet12 .","title":"Changed"},{"location":"changelog/#fixed_2","text":"Improved support for 1D inputs in l2l.nn.KroneckerLinear . (@timweiland)","title":"Fixed"},{"location":"changelog/#v015","text":"","title":"v0.1.5"},{"location":"changelog/#fixed_3","text":"Fix setup.py for windows installs.","title":"Fixed"},{"location":"changelog/#v014","text":"","title":"v0.1.4"},{"location":"changelog/#added_3","text":"FilteredMetaDatasest filter the classes used to sample tasks. UnionMetaDatasest to get the union of multiple MetaDatasets. Alias MiniImageNetCNN to CNN4 and add embedding_size argument. Optional data augmentation schemes for vision benchmarks. l2l.vision.models.ResNet12 l2l.vision.datasets.DescribableTextures l2l.vision.datasets.Quickdraw l2l.vision.datasets.FGVCFungi Add labels_to_indices and indices_to_labels as optional arguments to l2l.data.MetaDataset .","title":"Added"},{"location":"changelog/#changed_3","text":"Updated reference for citations.","title":"Changed"},{"location":"changelog/#v013","text":"","title":"v0.1.3"},{"location":"changelog/#added_4","text":"l2l.vision.datasets.CUBirds200 .","title":"Added"},{"location":"changelog/#changed_4","text":"Optimization transforms can be accessed directly through l2l.optim , e.g. l2l.optim.KroneckerTransform . All vision models adhere to the .features and .classifier interface.","title":"Changed"},{"location":"changelog/#fixed_4","text":"Fix clone_module for Modules whose submodules share parameters.","title":"Fixed"},{"location":"changelog/#v012","text":"","title":"v0.1.2"},{"location":"changelog/#added_5","text":"New example: Meta-World example with MAML-TRPO with it's own env wrapper. (@ Kostis-S-Z ) l2l.vision.benchmarks interface. Differentiable optimization utilities in l2l.optim . (including l2l.optim.LearnableOptimizer for meta-descent) General gradient-based meta-learning wrapper in l2l.algorithms.GBML . Various nn.Modules in l2l.nn . l2l.update_module as a more general alternative to l2l.algorithms.maml_update .","title":"Added"},{"location":"changelog/#changed_5","text":"","title":"Changed"},{"location":"changelog/#fixed_5","text":"clone_module supports non-Module objects. VGG flowers now relies on tarfile.open() instead of tarfile.TarFile().","title":"Fixed"},{"location":"changelog/#v011","text":"","title":"v0.1.1"},{"location":"changelog/#added_6","text":"New tutorial: 'Feature Reuse with ANIL'. (@ewinapun)","title":"Added"},{"location":"changelog/#changed_6","text":"Mujoco imports optional for docs: the import error is postponed to first method call.","title":"Changed"},{"location":"changelog/#fixed_6","text":"MAML() and clone_module support for RNN modules.","title":"Fixed"},{"location":"changelog/#v0101","text":"","title":"v0.1.0.1"},{"location":"changelog/#fixed_7","text":"Remove Cython dependency when installing from PyPI and clean up package distribution.","title":"Fixed"},{"location":"changelog/#v010","text":"","title":"v0.1.0"},{"location":"changelog/#added_7","text":"A CHANGELOG.md file. New vision datasets: FC100, tiered-Imagenet, FGVCAircraft, VGGFlowers102. New vision examples: Reptile & ANIL. Extensive benchmarks of all vision examples.","title":"Added"},{"location":"changelog/#changed_7","text":"Re-wrote TaskDataset and task transforms in Cython, for a 20x speed-up. Travis testing with different versions of Python (3.6, 3.7), torch (1.1, 1.2, 1.3, 1.4), and torchvision (0.3, 0.4, 0.5). New Material doc theme with links to changelog and examples.","title":"Changed"},{"location":"changelog/#fixed_8","text":"Support for RandomClassRotation with newer versions of torchvision. Various minor fixes in the examples. Add Dropbox download if GDrive fails for FC100.","title":"Fixed"},{"location":"community/","text":"Community \u00b6 learn2learn is built by a small but active community \u2014 this page acknowledges the institutions enabling those contributors and their work. For individual contributions, please refer to our Changelog . Universities \u00b6 Companies \u00b6 Publications \u00b6 A non-exhaustive list of papers built on top of learn2learn. Ping S\u00e9b to get yours listed, or open an issue . Uniform Sampling over Episode Difficulty [ ArXiv , code ] S.M.R. Arnold*, G. S. Dhillon*, A. Ravichandran, S. Soatto , NeurIPS 2021 Bridging Multi-Task Learning and Meta-Learning: Towards Efficient Training and Effective Adaptation [ ArXiv , code ] H. Wang, H. Zhao, B. Li , ICML 2021 Embedding Adaptation is Still Needed for Few-Shot Learning [ ArXiv ] S.M.R. Arnold, F. Sha , ArXiv 2021 When MAML Can Adapt Fast and How to Assist When It Cannot [ ArXiv , code ] S.M.R. Arnold, S. Iqbal, F. Sha , AISTATS 2021 learn2learn: A Library for Meta-Learning Research [ ArXiv , code ] S.M.R. Arnold, P. Mahajan, D. Datta, I. Bunner, K.S. Zarkias , ArXiv 2020","title":"Community"},{"location":"community/#community","text":"learn2learn is built by a small but active community \u2014 this page acknowledges the institutions enabling those contributors and their work. For individual contributions, please refer to our Changelog .","title":"Community"},{"location":"community/#universities","text":"","title":"Universities"},{"location":"community/#companies","text":"","title":"Companies"},{"location":"community/#publications","text":"A non-exhaustive list of papers built on top of learn2learn. Ping S\u00e9b to get yours listed, or open an issue . Uniform Sampling over Episode Difficulty [ ArXiv , code ] S.M.R. Arnold*, G. S. Dhillon*, A. Ravichandran, S. Soatto , NeurIPS 2021 Bridging Multi-Task Learning and Meta-Learning: Towards Efficient Training and Effective Adaptation [ ArXiv , code ] H. Wang, H. Zhao, B. Li , ICML 2021 Embedding Adaptation is Still Needed for Few-Shot Learning [ ArXiv ] S.M.R. Arnold, F. Sha , ArXiv 2021 When MAML Can Adapt Fast and How to Assist When It Cannot [ ArXiv , code ] S.M.R. Arnold, S. Iqbal, F. Sha , AISTATS 2021 learn2learn: A Library for Meta-Learning Research [ ArXiv , code ] S.M.R. Arnold, P. Mahajan, D. Datta, I. Bunner, K.S. Zarkias , ArXiv 2020","title":"Publications"},{"location":"paper_list/","text":"Paper List \u00b6 The following papers were announced on the learn2learn Twitter account . You can submit unannounced and meta-learning related papers through the following Google Form. (It does not matter if they are old or new, but they shouldn't be already announced.) Info Announce any paper via the Google Form to announce papers , also available below. Submitted Papers \u00b6 Grounded Language Learning Fast and Slow by Hill, Felix and Tieleman, Olivier and von Glehn, Tamara and Wong, Nathaniel and Merzic, Hamza and Clark, Stephen http://arxiv.org/abs/2009.01719 Sparse Meta Networks for Sequential Adaptation and its Application to Adaptive Language Modelling by Munkhdalai, Tsendsuren http://arxiv.org/abs/2009.01803 Learning with Differentiable Perturbed Optimizers by Berthet, Quentin and Blondel, Mathieu and Teboul, Olivier and Cuturi, Marco and Vert, Jean-Philippe and Bach, Francis http://arxiv.org/abs/2002.08676 What is being transferred in transfer learning? by Neyshabur, Behnam and Sedghi, Hanie and Zhang, Chiyuan http://arxiv.org/abs/2008.11687 On modulating the gradient for meta-learning by Simon, Christian and Koniusz, Piotr and Nock, Richard and Harandi, Mehrtash https://www.ecva.net/papers/eccv_2020/papers_ECCV/papers/123530545.pdf Meta-Learning with Shared Amortized Variational Inference by Iakovleva, Ekaterina and Verbeek, Jakob and Alahari, Karteek http://arxiv.org/abs/2008.12037 learn2learn: A Library for Meta-Learning Research by Arnold, S\u00e9bastien M R and Mahajan, Praateek and Datta, Debajyoti and Bunner, Ian and Zarkias, Konstantinos Saitas http://arxiv.org/abs/2008.12284 A Universal Representation Transformer Layer for Few-Shot Image Classification by Liu, Lu and Hamilton, William and Long, Guodong and Jiang, Jing and Larochelle, Hugo http://arxiv.org/abs/2006.11702 Safe Model-Based Meta-Reinforcement Learning: A Sequential Exploration-Exploitation Framework by Lew, Thomas and Sharma, Apoorva and Harrison, James and Pavone, Marco http://arxiv.org/abs/2008.11700 Learning to Learn in a Semi-Supervised Fashion by Chen, Yun-Chun and Chou, Chao-Te and Wang, Yu-Chiang Frank http://arxiv.org/abs/2008.11203 The Advantage of Conditional Meta-Learning for Biased Regularization and Fine-Tuning by Denevi, Giulia and Pontil, Massimiliano and Ciliberto, Carlo http://arxiv.org/abs/2008.10857 Adaptive Multi-level Hyper-gradient Descent by Jie, Renlong and Gao, Junbin and Vasnev, Andrey and Tran, Minh-Ngoc http://arxiv.org/abs/2008.07277 Few-Shot Image Classification via Contrastive Self-Supervised Learning by Li, Jianyi and Liu, Guizhong http://arxiv.org/abs/2008.09942 Does MAML really want feature reuse only? by Oh, Jaehoon and Yoo, Hyungjun and Kim, Changhwan and Yun, Se-Young http://arxiv.org/abs/2008.08882 Meta Learning MPC using Finite-Dimensional Gaussian Process Approximations by Arcari, Elena and Carron, Andrea and Zeilinger, Melanie N http://arxiv.org/abs/2008.05984 Offline Meta-Reinforcement Learning with Advantage Weighting by Mitchell, Eric and Rafailov, Rafael and Peng, Xue Bin and Levine, Sergey and Finn, Chelsea http://arxiv.org/abs/2008.06043 Explore then Execute: Adapting without Rewards via Factorized Meta-Reinforcement Learning by Liu, Evan Zheran and Raghunathan, Aditi and Liang, Percy and Finn, Chelsea http://arxiv.org/abs/2008.02790 Offline Meta Reinforcement Learning by Dorfman, Ron and Tamar, Aviv http://arxiv.org/abs/2008.02598 Few-Shot Learning via Learning the Representation, Provably by Du, Simon S and Hu, Wei and Kakade, Sham M and Lee, Jason D and Lei, Qi http://arxiv.org/abs/2002.09434 Multi-Task Reinforcement Learning as a Hidden-Parameter Block MDP by Zhang, Amy and Sodhani, Shagun and Khetarpal, Khimya and Pineau, Joelle http://arxiv.org/abs/2007.07206 CAMPs: Learning Context-Specific Abstractions for Efficient Planning in Factored MDPs by Chitnis, Rohan and Silver, Tom and Kim, Beomjoon and Kaelbling, Leslie Pack and Lozano-Perez, Tomas http://arxiv.org/abs/2007.13202 Unsupervised Learning of Visual Features by Contrasting Cluster Assignments by Caron, Mathilde and Misra, Ishan and Mairal, Julien and Goyal, Priya and Bojanowski, Piotr and Joulin, Armand http://arxiv.org/abs/2006.09882 MiCo: Mixup Co-Training for Semi-Supervised Domain Adaptation by Yang, Luyu and Wang, Yan and Gao, Mingfei and Shrivastava, Abhinav and Weinberger, Kilian Q and Chao, Wei-Lun and Lim, Ser-Nam http://arxiv.org/abs/2007.12684 Adaptive Task Sampling for Meta-Learning by Liu, Chenghao and Wang, Zhihao and Sahoo, Doyen and Fang, Yuan and Zhang, Kun and Hoi, Steven C H http://arxiv.org/abs/2007.08735 Discovering Reinforcement Learning Algorithms by Oh, Junhyuk and Hessel, Matteo and Czarnecki, Wojciech M and Xu, Zhongwen and van Hasselt, Hado and Singh, Satinder and Silver, David http://arxiv.org/abs/2007.08794 On the Outsized Importance of Learning Rates in Local Update Methods by Charles, Zachary and Kone{\\v c}n{\\'y}, Jakub http://arxiv.org/abs/2007.00878 Global Convergence and Induced Kernels of Gradient-Based Meta-Learning with Neural Nets by Wang, Haoxiang and Sun, Ruoyu and Li, Bo http://arxiv.org/abs/2006.14606 On the Iteration Complexity of Hypergradient Computation by Grazzi, Riccardo and Franceschi, Luca and Pontil, Massimiliano and Salzo, Saverio http://arxiv.org/abs/2006.16218 On the Outsized Importance of Learning Rates in Local Update Methods by Charles, Zachary and Kone{\\v c}n{\\'y}, Jakub http://arxiv.org/abs/2007.00878 Meta-SAC: Auto-tune the Entropy Temperature of Soft Actor-Critic via Metagradient by Wang, Yufei and Ni, Tianwei http://arxiv.org/abs/2007.01932 Meta Learning in the Continuous Time Limit by Xu, Ruitu and Chen, Lin and Karbasi, Amin http://arxiv.org/abs/2006.10921 Expert Training: Task Hardness Aware Meta-Learning for Few-Shot Classification by Zhou, Yucan and Wang, Yu and Cai, Jianfei and Zhou, Yu and Hu, Qinghua and Wang, Weiping http://arxiv.org/abs/2007.06240 MTL2L: A Context Aware Neural Optimiser by Kuo, Nicholas I-Hsien and Harandi, Mehrtash and Fourrier, Nicolas and Walder, Christian and Ferraro, Gabriela and Suominen, Hanna http://arxiv.org/abs/2007.09343 Navigating the Trade-Off between Multi-Task Learning and Learning to Multitask in Deep Neural Networks by Ravi, Sachin and Musslick, Sebastian and Hamin, Maia and Willke, Theodore L and Cohen, Jonathan D http://arxiv.org/abs/2007.10527 Balanced Meta-Softmax for Long-Tailed Visual Recognition by Ren, Jiawei and Yu, Cunjun and Sheng, Shunan and Ma, Xiao and Zhao, Haiyu and Yi, Shuai and Li, Hongsheng http://arxiv.org/abs/2007.10740 CrossTransformers: spatially-aware few-shot transfer by Doersch, Carl and Gupta, Ankush and Zisserman, Andrew http://arxiv.org/abs/2007.11498 Meta-Learning a Dynamical Language Model by Wolf, Thomas and Chaumond, Julien and Delangue, Clement http://arxiv.org/abs/1803.10631 Meta-Learning Requires Meta-Augmentation by Rajendran, Janarthanan and Irpan, Alex and Jang, Eric http://arxiv.org/abs/2007.05549 Adaptive Risk Minimization: A Meta-Learning Approach for Tackling Group Shift by Zhang, Marvin and Marklund, Henrik and Gupta, Abhishek and Levine, Sergey and Finn, Chelsea http://arxiv.org/abs/2007.02931 Meta-Learning Symmetries by Reparameterization by Zhou, Allan and Knowles, Tom and Finn, Chelsea http://arxiv.org/abs/2007.02933 Adaptive Risk Minimization: A Meta-Learning Approach for Tackling Group Shift by Zhang, Marvin and Marklund, Henrik and Gupta, Abhishek and Levine, Sergey and Finn, Chelsea http://arxiv.org/abs/2007.02931 A Brief Look at Generalization in Visual Meta-Reinforcement Learning by Alver, Safa and Precup, Doina http://arxiv.org/abs/2006.07262 Learning Representations by Stochastic Meta-Gradient Descent in Neural Networks by Veeriah, Vivek and Zhang, Shangtong and Sutton, Richard S http://arxiv.org/abs/1612.02879 PACOH: Bayes-Optimal Meta-Learning with PAC-Guarantees by Rothfuss, Jonas and Fortuin, Vincent and Krause, Andreas http://arxiv.org/abs/2002.05551 Meta-Meta-Classification for One-Shot Learning by Chowdhury, Arkabandhu and Chaudhari, Dipak and Chaudhuri, Swarat and Jermaine, Chris http://arxiv.org/abs/2004.08083 Relatedness Measures to Aid the Transfer of Building Blocks among Multiple Tasks by Nguyen, Trung B and Browne, Will N and Zhang, Mengjie http://arxiv.org/abs/2005.03947 Information-Theoretic Generalization Bounds for Meta-Learning and Applications by Jose, Sharu Theresa and Simeone, Osvaldo http://arxiv.org/abs/2005.04372 On Learning Intrinsic Rewards for Policy Gradient Methods by Zheng, Zeyu and Oh, Junhyuk and Singh, Satinder http://arxiv.org/abs/1804.06459 A Sample Complexity Separation between Non-Convex and Convex Meta-Learning by Saunshi, Nikunj and Zhang, Yi and Khodak, Mikhail and Arora, Sanjeev http://arxiv.org/abs/2002.11172 Bayesian Online Meta-Learning with Laplace Approximation by Yap, Pau Ching and Ritter, Hippolyt and Barber, David http://arxiv.org/abs/2005.00146 Meta-Reinforcement Learning for Robotic Industrial Insertion Tasks by Schoettler, Gerrit and Nair, Ashvin and Ojea, Juan Aparicio and Levine, Sergey and Solowjow, Eugen http://arxiv.org/abs/2004.14404 Continual Deep Learning by Functional Regularisation of Memorable Past by Pan, Pingbo and Swaroop, Siddharth and Immer, Alexander and Eschenhagen, Runa and Turner, Richard E and Khan, Mohammad Emtiyaz http://arxiv.org/abs/2004.14070 Jelly Bean World: A Testbed for Never-Ending Learning by Platanios, Emmanouil Antonios and Saparov, Abulhair and Mitchell, Tom https://openreview.net/pdf?id=Byx_YAVYPH Encouraging behavioral diversity in evolutionary robotics: an empirical study by Mouret, J-B and Doncieux, S http://dx.doi.org/10.1162/EVCO_a_00048 Defining Benchmarks for Continual Few-Shot Learning by Antoniou, Antreas and Patacchiola, Massimiliano and Ochal, Mateusz and Storkey, Amos http://arxiv.org/abs/2004.11967 Emergent Real-World Robotic Skills via Unsupervised Off-Policy Reinforcement Learning by Sharma, Archit and Ahn, Michael and Levine, Sergey and Kumar, Vikash and Hausman, Karol and Gu, Shixiang http://arxiv.org/abs/2004.12974 Empirical Bayes Transductive Meta-Learning with Synthetic Gradients by Hu, Shell Xu and Moreno, Pablo G and Xiao, Yang and Shen, Xi and Obozinski, Guillaume and Lawrence, Neil D and Damianou, Andreas http://arxiv.org/abs/2004.12696 Evolving Inborn Knowledge For Fast Adaptation in Dynamic POMDP Problems by Ben-Iwhiwhu, Eseoghene and Ladosz, Pawel and Dick, Jeffery and Chen, Wen-Hua and Pilly, Praveen and Soltoggio, Andrea http://arxiv.org/abs/2004.12846 Meta-World: A Benchmark and Evaluation for Multi-Task and Meta Reinforcement Learning by Yu, Tianhe and Quillen, Deirdre and He, Zhanpeng and Julian, Ryan and Hausman, Karol and Finn, Chelsea and Levine, Sergey http://arxiv.org/abs/1910.10897 Meta reinforcement learning as task inference by Humplik, Jan and Galashov, Alexandre and Hasenclever, Leonard and Ortega, Pedro A and Teh, Yee Whye and Heess, Nicolas http://arxiv.org/abs/1905.06424 Meta-Gradient Reinforcement Learning by Xu, Zhongwen and van Hasselt, Hado and Silver, David http://arxiv.org/abs/1805.09801 Self-Paced Deep Reinforcement Learning by Klink, Pascal and D'Eramo, Carlo and Peters, Jan and Pajarinen, Joni http://arxiv.org/abs/2004.11812 Scheduling the Learning Rate Via Hypergradients: New Insights and a New Algorithm by Donini, Michele and Franceschi, Luca and Majumder, Orchid and Pontil, Massimiliano and Frasconi, Paolo https://openreview.net/pdf?id=Ske6qJSKPH Learning Stabilizable Nonlinear Dynamics with Contraction-Based Regularization by Singh, Sumeet and Richards, Spencer M and Sindhwani, Vikas and Slotine, Jean-Jacques E and Pavone, Marco http://arxiv.org/abs/1907.13122 A Comprehensive Overview and Survey of Recent Advances in Meta-Learning by Peng, Huimin http://arxiv.org/abs/2004.11149 Learning a Formula of Interpretability to Learn Interpretable Formulas by Virgolin, Marco and De Lorenzo, Andrea and Medvet, Eric and Randone, Francesca http://arxiv.org/abs/2004.11170 Model-Based Meta-Reinforcement Learning for Flight with Suspended Payloads by Belkhale, Suneel and Li, Rachel and Kahn, Gregory and McAllister, Rowan and Calandra, Roberto and Levine, Sergey http://arxiv.org/abs/2004.11345 Frustratingly Simple Few-Shot Object Detection by Wang, Xin and Huang, Thomas E and Darrell, Trevor and Gonzalez, Joseph E and Yu, Fisher http://arxiv.org/abs/2003.06957 Meta Pseudo Labels by Pham, Hieu and Xie, Qizhe and Dai, Zihang and Le, Quoc V http://arxiv.org/abs/2003.10580 0e56da12-a2f0-4288-b745-c15deec9183a by Unknown http://learn2learn.net Finding online neural update rules by learning to remember by Gregor, Karol http://arxiv.org/abs/2003.03124 A New Meta-Baseline for Few-Shot Learning by Chen, Yinbo and Wang, Xiaolong and Liu, Zhuang and Xu, Huijuan and Darrell, Trevor http://arxiv.org/abs/2003.04390 Learning to be Global Optimizer by Zhang, Haotian and Sun, Jianyong and Xu, Zongben http://arxiv.org/abs/2003.04521 Scalable Multi-Task Imitation Learning with Autonomous Improvement by Singh, Avi and Jang, Eric and Irpan, Alexander and Kappler, Daniel and Dalal, Murtaza and Levine, Sergey and Khansari, Mohi and Finn, Chelsea http://arxiv.org/abs/2003.02636 Meta-learning for mixed linear regression by Kong, Weihao and Somani, Raghav and Song, Zhao and Kakade, Sham and Oh, Sewoong http://arxiv.org/abs/2002.08936 Provable Meta-Learning of Linear Representations by Tripuraneni, Nilesh and Jin, Chi and Jordan, Michael I http://arxiv.org/abs/2002.11684 Learning to Continually Learn by Beaulieu, Shawn and Frati, Lapo and Miconi, Thomas and Lehman, Joel and Stanley, Kenneth O and Clune, Jeff and Cheney, Nick http://arxiv.org/abs/2002.09571 PACOH: Bayes-Optimal Meta-Learning with PAC-Guarantees by Rothfuss, Jonas and Fortuin, Vincent and Krause, Andreas http://arxiv.org/abs/2002.05551 Incremental Learning for Metric-Based Meta-Learners by Liu, Qing and Majumder, Orchid and Ravichandran, Avinash and Bhotika, Rahul and Soatto, Stefano http://arxiv.org/abs/2002.04162 Hyper-Meta Reinforcement Learning with Sparse Reward by Hua, Yun and Wang, Xiangfeng and Jin, Bo and Li, Wenhao and Yan, Junchi and He, Xiaofeng and Zha, Hongyuan http://arxiv.org/abs/2002.04238 Meta-Learning across Meta-Tasks for Few-Shot Learning by Fei, Nanyi and Lu, Zhiwu and Gao, Yizhao and Tian, Jia and Xiang, Tao and Wen, Ji-Rong http://arxiv.org/abs/2002.04274 Distribution-Agnostic Model-Agnostic Meta-Learning by Collins, Liam and Mokhtari, Aryan and Shakkottai, Sanjay http://arxiv.org/abs/2002.04766 Provably Convergent Policy Gradient Methods for Model-Agnostic Meta-Reinforcement Learning by Fallah, Alireza and Mokhtari, Aryan and Ozdaglar, Asuman http://arxiv.org/abs/2002.05135 Meta-learning framework with applications to zero-shot time-series forecasting by Oreshkin, Boris N and Carpov, Dmitri and Chapados, Nicolas and Bengio, Yoshua http://arxiv.org/abs/2002.02887 A Loss-Function for Causal Machine-Learning by Yang, I-Sheng http://arxiv.org/abs/2001.00629 Self-Tuning Deep Reinforcement Learning by Zahavy, Tom and Xu, Zhongwen and Veeriah, Vivek and Hessel, Matteo and Van Hasslet, Hado and Silver, David and Singh, Satinder http://arxiv.org/abs/2002.12928 Learning Adaptive Loss for Robust Learning with Noisy Labels by Shu, Jun and Zhao, Qian and Chen, Keyu and Xu, Zongben and Meng, Deyu http://arxiv.org/abs/2002.06482 A Structured Prediction Approach for Conditional Meta-Learning by Wang, Ruohan and Demiris, Yiannis and Ciliberto, Carlo http://arxiv.org/abs/2002.08799 Curriculum in Gradient-Based Meta-Reinforcement Learning by Mehta, Bhairav and Deleu, Tristan and Raparthy, Sharath Chandra and Pal, Chris J and Paull, Liam http://arxiv.org/abs/2002.07956 Multi-Step Model-Agnostic Meta-Learning: Convergence and Improved Algorithms by Ji, Kaiyi and Yang, Junjie and Liang, Yingbin http://arxiv.org/abs/2002.07836 Local Nonparametric Meta-Learning by Goo, Wonjoon and Niekum, Scott http://arxiv.org/abs/2002.03272 Revisiting Meta-Learning as Supervised Learning by Chao, Wei-Lun and Ye, Han-Jia and Zhan, De-Chuan and Campbell, Mark and Weinberger, Kilian Q http://arxiv.org/abs/2002.00573 SimpleShot: Revisiting Nearest-Neighbor Classification for Few-Shot Learning by Wang, Yan and Chao, Wei-Lun and Weinberger, Kilian Q and van der Maaten, Laurens http://arxiv.org/abs/1911.04623 Fast and Generalized Adaptation for Few-Shot Learning by Song, Liang and Liu, Jinlu and Qin, Yongqiang http://arxiv.org/abs/1911.10807 Meta-Learning without Memorization by Yin, Mingzhang and Tucker, George and Zhou, Mingyuan and Levine, Sergey and Finn, Chelsea http://arxiv.org/abs/1912.03820 Your Classifier is Secretly an Energy Based Model and You Should Treat it Like One by Grathwohl, Will and Wang, Kuan-Chieh and Jacobsen, J{\\\"o}rn-Henrik and Duvenaud, David and Norouzi, Mohammad and Swersky, Kevin http://arxiv.org/abs/1912.03263 MAME : Model-Agnostic Meta-Exploration by Gurumurthy, Swaminathan and Kumar, Sumit and Sycara, Katia http://arxiv.org/abs/1911.04024 Constructing Multiple Tasks for Augmentation: Improving Neural Image Classification With K-means Features by Gui, Tao and Qing, Lizhi and Zhang, Qi and Ye, Jiacheng and Yan, Hang and Fei, Zichu and Huang, Xuanjing http://arxiv.org/abs/1911.07518 Meta Adaptation using Importance Weighted Demonstrations by Lekkala, Kiran and Abu-El-Haija, Sami and Itti, Laurent http://arxiv.org/abs/1911.10322 VIABLE: Fast Adaptation via Backpropagating Learned Loss by Feng, Leo and Zintgraf, Luisa and Peng, Bei and Whiteson, Shimon http://arxiv.org/abs/1911.13159 Decoupling Adaptation from Modeling with Meta-Optimizers for Meta Learning by Arnold, S{\\'e}bastien M R and Iqbal, Shariq and Sha, Fei http://arxiv.org/abs/1910.13603 TADAM: Task dependent adaptive metric for improved few-shot learning by Oreshkin, Boris and Rodr{\\'\\i}guez L{\\'o}pez, Pau and Lacoste, Alexandre http://papers.nips.cc/paper/7352-tadam-task-dependent-adaptive-metric-for-improved-few-shot-learning.pdf Learning to Few-Shot Learn Across Diverse Natural Language Classification Tasks by Bansal, Trapit and Jha, Rishikesh and McCallum, Andrew http://arxiv.org/abs/1911.03863 Optimizing Millions of Hyperparameters by Implicit Differentiation by Lorraine, Jonathan and Vicol, Paul and Duvenaud, David http://arxiv.org/abs/1911.02590 Meta-data: Characterization of Input Features for Meta-learning by Castiello, Ciro and Castellano, Giovanna and Fanelli, Anna Maria http://dx.doi.org/10.1007/11526018_45 Meta-Learning for Low-resource Natural Language Generation in Task-oriented Dialogue Systems by Mi, Fei and Huang, Minlie and Zhang, Jiyong and Faltings, Boi http://arxiv.org/abs/1905.05644 Domain Generalization via Model-Agnostic Learning of Semantic Features by Dou, Qi and Castro, Daniel C and Kamnitsas, Konstantinos and Glocker, Ben http://arxiv.org/abs/1910.13580 Hierarchical Expert Networks for Meta-Learning by Hihn, Heinke and Braun, Daniel A http://arxiv.org/abs/1911.00348 Online Meta-Learning on Non-convex Setting by Zhuang, Zhenxun and Wang, Yunlong and Yu, Kezi and Lu, Songtao http://arxiv.org/abs/1910.10196 Learning-to-Learn Stochastic Gradient Descent with Biased Regularization by Denevi, Giulia and Ciliberto, Carlo and Grazzi, Riccardo and Pontil, Massimiliano http://arxiv.org/abs/1903.10399 Provable Guarantees for Gradient-Based Meta-Learning by Khodak, Mikhail and Balcan, Maria-Florina and Talwalkar, Ameet http://arxiv.org/abs/1902.10644 The TCGA Meta-Dataset Clinical Benchmark by Samiei, Mandana and W{\\\"u}rfl, Tobias and Deleu, Tristan and Weiss, Martin and Dutil, Francis and Fevens, Thomas and Boucher, Genevi{`e}ve and Lemieux, Sebastien and Cohen, Joseph Paul http://arxiv.org/abs/1910.08636 VariBAD: A Very Good Method for Bayes-Adaptive Deep RL via Meta-Learning by Zintgraf, Luisa and Shiarlis, Kyriacos and Igl, Maximilian and Schulze, Sebastian and Gal, Yarin and Hofmann, Katja and Whiteson, Shimon http://arxiv.org/abs/1910.08348 Meta-Transfer Learning through Hard Tasks by Sun, Qianru and Liu, Yaoyao and Chen, Zhaozheng and Chua, Tat-Seng and Schiele, Bernt http://arxiv.org/abs/1910.03648 Model-Agnostic Meta-Learning using Runge-Kutta Methods by Im, Daniel Jiwoong and Jiang, Yibo and Verma, Nakul http://arxiv.org/abs/1910.07368 Improving Generalization in Meta Reinforcement Learning using Learned Objectives by Kirsch, Louis and van Steenkiste, Sjoerd and Schmidhuber, J{\\\"u}rgen http://arxiv.org/abs/1910.04098 Generalized Inner Loop Meta-Learning by Grefenstette, Edward and Amos, Brandon and Yarats, Denis and Htut, Phu Mon and Molchanov, Artem and Meier, Franziska and Kiela, Douwe and Cho, Kyunghyun and Chintala, Soumith http://arxiv.org/abs/1910.01727 Is Fast Adaptation All You Need? by Javed, Khurram and Yao, Hengshuai and White, Martha http://arxiv.org/abs/1910.01705 Deep Reinforcement Learning for Single-Shot Diagnosis and Adaptation in Damaged Robots by Verma, Shresth and Nair, Haritha S and Agarwal, Gaurav and Dhar, Joydip and Shukla, Anupam http://arxiv.org/abs/1910.01240 ES-MAML: Simple Hessian-Free Meta Learning by Song, Xingyou and Gao, Wenbo and Yang, Yuxiang and Choromanski, Krzysztof and Pacchiano, Aldo and Tang, Yunhao http://arxiv.org/abs/1910.01215 Meta-Q-Learning by Fakoor, Rasool and Chaudhari, Pratik and Soatto, Stefano and Smola, Alexander J http://arxiv.org/abs/1910.00125 Efficient meta reinforcement learning via meta goal generation by Fu, Haotian and Tang, Hongyao and Hao, Jianye http://arxiv.org/abs/1909.13607 Chameleon: Learning Model Initializations Across Tasks With Different Schemas by Brinkmeyer, Lukas and Drumond, Rafael Rego and Scholz, Randolf and Grabocka, Josif and Schmidt-Thieme, Lars http://arxiv.org/abs/1909.13576 Learning Fast Adaptation with Meta Strategy Optimization by Yu, Wenhao and Tan, Jie and Bai, Yunfei and Coumans, Erwin and Ha, Sehoon http://arxiv.org/abs/1909.12995 Meta-Inverse Reinforcement Learning with Probabilistic Context Variables by Yu, Lantao and Yu, Tianhe and Finn, Chelsea and Ermon, Stefano http://arxiv.org/abs/1909.09314 Modular Meta-Learning with Shrinkage by Chen, Yutian and Friesen, Abram L and Behbahani, Feryal and Budden, David and Hoffman, Matthew W and Doucet, Arnaud and de Freitas, Nando http://arxiv.org/abs/1909.05557 Loaded DiCE: Trading off Bias and Variance in Any-Order Score Function Estimators for Reinforcement Learning by Farquhar, Gregory and Whiteson, Shimon and Foerster, Jakob http://arxiv.org/abs/1909.10549 Rapid Learning or Feature Reuse? Towards Understanding the Effectiveness of MAML by Raghu, Aniruddh and Raghu, Maithra and Bengio, Samy and Vinyals, Oriol http://arxiv.org/abs/1909.09157 Meta-Learning by Vanschoren, Joaquin https://doi.org/10.1007/978-3-030-05318-5_2 Understanding Short-Horizon Bias in Stochastic Meta-Optimization by Wu, Yuhuai and Ren, Mengye and Liao, Renjie and Grosse, Roger http://arxiv.org/abs/1803.02021 On First-Order Meta-Learning Algorithms by Nichol, Alex and Achiam, Joshua and Schulman, John http://arxiv.org/abs/1803.02999 Towards Understanding Generalization in Gradient-Based Meta-Learning by Guiroy, Simon and Verma, Vikas and Pal, Christopher http://arxiv.org/abs/1907.07287 They empirically study the landscape of fast-adaptation in MAML. The most interesting claim is that when meta-overfitting, the loss landscape becomes flatter on test tasks. On the Convergence Theory of Gradient-Based Model-Agnostic Meta-Learning Algorithms by Fallah, Alireza and Mokhtari, Aryan and Ozdaglar, Asuman http://arxiv.org/abs/1908.10400 Learning to Learn with Gradients by Finn, Chelsea http://learn2learn.net Acetylcholine and memory by Hasselmo, M E and Bower, J M https://www.ncbi.nlm.nih.gov/pubmed/7688162 A THEORY OF META-LEARNING AND PRINCIPLES OF FACILITATION: AN ORGANISMIC PERSPECTIVE by Maudsley, Donald B https://uosc.primo.exlibrisgroup.com/discovery/fulldisplay?docid=proquest302999651&context=PC&vid=01USC_INST:01USC&lang=en&search_scope=MyInst_and_CI&adaptor=Primo%20Central&tab=Everything&mode=Basic THE ROLE OF METALEARNING IN STUDY PROCESSES by Biggs, J B http://doi.wiley.com/10.1111/j.2044-8279.1985.tb02625.x Understanding and correcting pathologies in the training of learned optimizers by Metz, Luke and Maheswaranathan, Niru and Nixon, Jeremy and Daniel Freeman, C and Sohl-Dickstein, Jascha http://arxiv.org/abs/1810.10180 Provides many tricks (e.g. split train batch for model \\& opt, average gradient estimators) for training differentiable optimizers online. They also have a couple of interesting observations specific to recurrent optimizers. Learned Optimizers that Scale and Generalize by Wichrowska, Olga and Maheswaranathan, Niru and Hoffman, Matthew W and Colmenarejo, Sergio Gomez and Denil, Misha and de Freitas, Nando and Sohl-Dickstein, Jascha http://arxiv.org/abs/1703.04813 Using learned optimizers to make models robust to input noise by Metz, Luke and Maheswaranathan, Niru and Shlens, Jonathon and Sohl-Dickstein, Jascha and Cubuk, Ekin D http://arxiv.org/abs/1906.03367 Learning to Optimize Neural Nets by Li, Ke and Malik, Jitendra http://arxiv.org/abs/1703.00441 Meta-Learning Update Rules for Unsupervised Representation Learning by Metz, Luke and Maheswaranathan, Niru and Cheung, Brian and Sohl-Dickstein, Jascha http://arxiv.org/abs/1804.00222 Learning to Optimize by Li, Ke and Malik, Jitendra http://arxiv.org/abs/1606.01885 Learning to learn by gradient descent by gradient descent by Andrychowicz, M and Denil, M and Gomez, S http://learn2learn.net Online Learning Rate Adaptation with Hypergradient Descent by Baydin, Atilim Gunes and Cornish, Robert and Rubio, David Martinez and Schmidt, Mark and Wood, Frank http://arxiv.org/abs/1703.04782 They adapt the learning rate of SGD by differentiating the loss of the next parameters w.r.t. the learning rate. They observe that the gradient of the learning rate is simply the inner product of the last two gradients. Adapting Bias by Gradient Descent: An Incremental Version of Delta-Bar-Delta by Sutton, Richard S http://dx.doi.org/ What's mostly interesting in this paper is the adaptation of delta-bar-delta to the online scenario. The idea of representing the learning rate as an exponential is nice. Also nice to see that the derivation suggests a full-matrix adaptive case. Gain adaptation beats least squares by Sutton, Richard S https://pdfs.semanticscholar.org/7ec8/876f219b3b3d5c894a3f395c89c382029cc5.pdf This paper extends IDBD as algorithms K1 and K2, but from my quick read, it isn't clear what's the motivation for those modifications. (Seems to work in a `normalized space'', {\\ a} la natural gradient ?)They do work better. Local Gain Adaptation in Stochastic Gradient Descent by Schraudolph, Nicol N https://pdfs.semanticscholar.org/31a0/b86c3cd04e6539626f34b80db7ff79d23f40.pdf This algorithm extends IDBD (Sutton) to the non-linear setting. Interestingly, they have a few brief discussionson the difficulties to optimize at the meta-level. (c.f. Meta-level conditioning section.) Overall, it shines light on the ground idea behind IDBD. TIDBD: Adapting Temporal-difference Step-sizes Through Stochastic Meta-descent by Kearney, Alex and Veeriah, Vivek and Travnik, Jaden B and Sutton, Richard S and Pilarski, Patrick M http://arxiv.org/abs/1804.03334 Increased rates of convergence through learning rate adaptation by Jacobs, Robert A http://www.sciencedirect.com/science/article/pii/0893608088900032 This paper argues that we need (at least) four ingredients to improve optimization of connectionist networks: 1. each parameter has its own stepsize, 2. stepsizes vary over time, 3. if consecutive gradients of a stepsize have the same sign, the stepsize should be increased, 4. conversely, if the stepsize should be decreased if its gradients have opposite signs. It also proposes to use two improvements: 1. Momentum (i.e. Polyak's heavyball), 2. delta-bar-delta (i.e. learning the stepsize). It has an interesting comment on the difficulty of learning the stepsize, and therefore comes up with a ``hack'' that outperforms momentum. Meta-descent for Online, Continual Prediction by Jacobsen, Andrew and Schlegel, Matthew and Linke, Cameron and Degris, Thomas and White, Adam and White, Martha http://arxiv.org/abs/1907.07751 The idea is to learn the learning rate so as to minimize the norm of the gradient. They argue that for the continual learning setting, this forces the algorithm to stay ``as stable as possible''. No theorems, small-scale (but interesting) experiments. Adaptation of learning rate parameters by Sutton, Rich http://learn2learn.net Gradient-Based Meta-Learning with Learned Layerwise Metric and Subspace by Lee, Yoonho and Choi, Seungjin http://arxiv.org/abs/1801.05558 Meta-Learning with Warped Gradient Descent by Flennerhag, Sebastian and Rusu, Andrei A and Pascanu, Razvan and Yin, Hujun and Hadsell, Raia http://arxiv.org/abs/1909.00025 Meta-Learning via Learned Loss by Chebotar, Yevgen and Molchanov, Artem and Bechtle, Sarah and Righetti, Ludovic and Meier, Franziska and Sukhatme, Gaurav http://arxiv.org/abs/1906.05374 They learn the loss as a NN, and that loss's objective is to maximize the sum of rewards. It is provided a bunch of things, including inputs, outputs, goals. Meta-Curvature by Park, Eunbyung and Oliva, Junier B http://arxiv.org/abs/1902.03356 Alpha MAML: Adaptive Model-Agnostic Meta-Learning by Behl, Harkirat Singh and Baydin, At{\\i}l{\\i}m G{\\\"u}ne{\\c s} and Torr, Philip H S http://arxiv.org/abs/1905.07435 They combine hypergradient and MAML: adapt all learning rates at all times. Meta-SGD: Learning to Learn Quickly for Few-Shot Learning by Li, Zhenguo and Zhou, Fengwei and Chen, Fei and Li, Hang http://arxiv.org/abs/1707.09835 ProMP: Proximal Meta-Policy Search by Rothfuss, Jonas and Lee, Dennis and Clavera, Ignasi and Asfour, Tamim and Abbeel, Pieter http://arxiv.org/abs/1810.06784 Model-Agnostic Meta-Learning for Fast Adaptation of Deep Networks by Finn, Chelsea and Abbeel, Pieter and Levine, Sergey http://learn2learn.net Optimization as a model for few-shot learning by Ravi, Sachin and Larochelle, Hugo https://openreview.net/pdf?id=rJY0-Kcll Fast Context Adaptation via Meta-Learning by Zintgraf, Luisa M and Shiarlis, Kyriacos and Kurin, Vitaly and Hofmann, Katja and Whiteson, Shimon http://arxiv.org/abs/1810.03642 Meta-Learning with Implicit Gradients by Rajeswaran, Aravind and Finn, Chelsea and Kakade, Sham and Levine, Sergey http://arxiv.org/abs/1909.04630 Natural Neural Networks by Desjardins, Guillaume and Simonyan, Karen and Pascanu, Razvan and Kavukcuoglu, Koray http://dl.acm.org/citation.cfm?id=2969442.2969471 A Baseline for Few-Shot Image Classification by Dhillon, Guneet S and Chaudhari, Pratik and Ravichandran, Avinash and Soatto, Stefano http://arxiv.org/abs/1909.02729 A CLOSER LOOK AT FEW-SHOT CLASSIFICATION by Chen, Wei-Yu and Liu, Yen-Cheng and Kira, Zsolt https://openreview.net/pdf?id=HkxLXnAcFQ Suggests that meta-learning papers haven't been tested against classical baselines. When considering those baselines, they perform better than many of the recent meta-learning techniques. Meta-learning with differentiable closed-form solvers by Bertinetto, Luca and Henriques, Joao F and Torr, Philip and Vedaldi, Andrea https://openreview.net/forum?id=HyxnZh0ct7 Uncertainty in Model-Agnostic Meta-Learning using Variational Inference by Nguyen, Cuong and Do, Thanh-Toan and Carneiro, Gustavo http://arxiv.org/abs/1907.11864 Meta-Reinforcement Learning of Structured Exploration Strategies by Gupta, Abhishek and Mendonca, Russell and Liu, Yuxuan and Abbeel, Pieter and Levine, Sergey http://arxiv.org/abs/1802.07245 Metalearned Neural Memory by Munkhdalai, Tsendsuren and Sordoni, Alessandro and Wang, Tong and Trischler, Adam http://arxiv.org/abs/1907.09720 Accelerated Stochastic Approximation by Kesten, Harry https://projecteuclid.org/euclid.aoms/1177706705 Meta-Learning for Black-box Optimization by Vishnu, T V and Malhotra, Pankaj and Narwariya, Jyoti and Vig, Lovekesh and Shroff, Gautam http://arxiv.org/abs/1907.06901 They essentially extend the recurrent meta-learning framework in a few ways: 1. Use regret instead of objective improvement as meta-learning objective. 2. Normalize the objective so as to make it play nice with LSTMs. 3. Incorporate domain-constraints, so that the LSTM always outputs feasible solutions. All are described in page 3. Task Agnostic Continual Learning via Meta Learning by He, Xu and Sygnowski, Jakub and Galashov, Alexandre and Rusu, Andrei A and Teh, Yee Whye and Pascanu, Razvan http://arxiv.org/abs/1906.05201 Watch, Try, Learn: Meta-Learning from Demonstrations and Reward by Zhou, Allan and Jang, Eric and Kappler, Daniel and Herzog, Alex and Khansari, Mohi and Wohlhart, Paul and Bai, Yunfei and Kalakrishnan, Mrinal and Levine, Sergey and Finn, Chelsea http://arxiv.org/abs/1906.03352 Meta-Learning Representations for Continual Learning by Javed, Khurram and White, Martha http://arxiv.org/abs/1905.12588 TapNet: Neural Network Augmented with Task-Adaptive Projection for Few-Shot Learning by Yoon, Sung Whan and Seo, Jun and Moon, Jaekyun http://arxiv.org/abs/1905.06549 Meta Reinforcement Learning with Task Embedding and Shared Policy by Lan, Lin and Li, Zhenguo and Guan, Xiaohong and Wang, Pinghui http://arxiv.org/abs/1905.06527 Hierarchically Structured Meta-learning by Yao, Huaxiu and Wei, Ying and Huang, Junzhou and Li, Zhenhui http://arxiv.org/abs/1905.05301 Curious Meta-Controller: Adaptive Alternation between Model-Based and Model-Free Control in Deep Reinforcement Learning by Hafez, Muhammad Burhan and Weber, Cornelius and Kerzel, Matthias and Wermter, Stefan http://arxiv.org/abs/1905.01718 Learning to Learn in Simulation by Teng, Ervin and Iannucci, Bob http://arxiv.org/abs/1902.01569 Meta-Learning with Differentiable Convex Optimization by Lee, Kwonjoon and Maji, Subhransu and Ravichandran, Avinash and Soatto, Stefano http://arxiv.org/abs/1904.03758 Functional Regularisation for Continual Learning by Titsias, Michalis K and Schwarz, Jonathan and de G. Matthews, Alexander G and Pascanu, Razvan and Teh, Yee Whye http://arxiv.org/abs/1901.11356 Learning to Forget for Meta-Learning by Baik, Sungyong and Hong, Seokil and Lee, Kyoung Mu http://arxiv.org/abs/1906.05895 Meta-learning of Sequential Strategies by Ortega, Pedro A and Wang, Jane X and Rowland, Mark and Genewein, Tim and Kurth-Nelson, Zeb and Pascanu, Razvan and Heess, Nicolas and Veness, Joel and Pritzel, Alex and Sprechmann, Pablo and Jayakumar, Siddhant M and McGrath, Tom and Miller, Kevin and Azar, Mohammad and Osband, Ian and Rabinowitz, Neil and Gy{\\\"o}rgy, Andr{\\'a}s and Chiappa, Silvia and Osindero, Simon and Teh, Yee Whye and van Hasselt, Hado and de Freitas, Nando and Botvinick, Matthew and Legg, Shane http://arxiv.org/abs/1905.03030 This paper essentially provides a theoretical framework to ground the fact that recurrent meta-learning (RL^2, LLGD^2) performs Bayesian inference during adaptation. Auto-Meta: Automated Gradient Based Meta Learner Search by Kim, Jaehong and Lee, Sangyeul and Kim, Sungwan and Cha, Moonsu and Lee, Jung Kwon and Choi, Youngduck and Choi, Yongseok and Cho, Dong-Yeon and Kim, Jiwon http://arxiv.org/abs/1806.06927 Adaptive Gradient-Based Meta-Learning Methods by Khodak, Mikhail and Florina-Balcan, Maria and Talwalkar, Ameet http://arxiv.org/abs/1906.02717 Embedded Meta-Learning: Toward more flexible deep-learning models by Lampinen, Andrew K and McClelland, James L http://arxiv.org/abs/1905.09950 Modular meta-learning by Alet, Ferran and Lozano-P{\\'e}rez, Tom{\\'a}s and Kaelbling, Leslie P http://arxiv.org/abs/1806.10166 MetaPred: Meta-Learning for Clinical Risk Prediction with Limited Patient Electronic Health Records by Zhang, Xi Sheryl and Tang, Fengyi and Dodge, Hiroko and Zhou, Jiayu and Wang, Fei http://arxiv.org/abs/1905.03218 Prototypical Networks for Few-shot Learning by Snell, Jake and Swersky, Kevin and Zemel, Richard S http://arxiv.org/abs/1703.05175 Meta-learners' learning dynamics are unlike learners' by Rabinowitz, Neil C http://arxiv.org/abs/1905.01320 Backpropamine: training self-modifying neural networks with differentiable neuromodulated plasticity by Miconi, Thomas and Rawal, Aditya and Clune, Jeff and Stanley, Kenneth O https://openreview.net/forum?id=r1lrAiA5Ym Reinforcement Learning, Fast and Slow by Botvinick, Matthew and Ritter, Sam and Wang, Jane X and Kurth-Nelson, Zeb and Blundell, Charles and Hassabis, Demis http://dx.doi.org/10.1016/j.tics.2019.02.006 Been There, Done That: Meta-Learning with Episodic Recall by Ritter, Samuel and Wang, Jane X and Kurth-Nelson, Zeb and Jayakumar, Siddhant M and Blundell, Charles and Pascanu, Razvan and Botvinick, Matthew http://arxiv.org/abs/1805.09692 Guided Meta-Policy Search by Mendonca, Russell and Gupta, Abhishek and Kralev, Rosen and Abbeel, Pieter and Levine, Sergey and Finn, Chelsea http://arxiv.org/abs/1904.00956 Hierarchical Meta Learning by Zou, Yingtian and Feng, Jiashi http://arxiv.org/abs/1904.09081 A Meta-Transfer Objective for Learning to Disentangle Causal Mechanisms by Bengio, Yoshua and Deleu, Tristan and Rahaman, Nasim and Ke, Rosemary and Lachapelle, S{\\'e}bastien and Bilaniuk, Olexa and Goyal, Anirudh and Pal, Christopher http://arxiv.org/abs/1901.10912 Generalize Across Tasks: Efficient Algorithms for Linear Representation Learning by Bullins, Brian and Hazan, Elad and Kalai, Adam and Livni, Roi http://proceedings.mlr.press/v98/bullins19a.html Incremental Learning-to-Learn with Statistical Guarantees by Denevi, Giulia and Ciliberto, Carlo and Stamos, Dimitris and Pontil, Massimiliano http://arxiv.org/abs/1803.08089 A Model of Inductive Bias Learning by Baxter, J http://arxiv.org/abs/1106.0245 Efficient Off-Policy Meta-Reinforcement Learning via Probabilistic Context Variables by Rakelly, Kate and Zhou, Aurick and Quillen, Deirdre and Finn, Chelsea and Levine, Sergey http://arxiv.org/abs/1903.08254 Continual Learning with Tiny Episodic Memories by Chaudhry, Arslan and Rohrbach, Marcus and Elhoseiny, Mohamed and Ajanthan, Thalaiyasingam and Dokania, Puneet K and Torr, Philip H S and Ranzato, Marc'aurelio http://arxiv.org/abs/1902.10486 Online Meta-Learning by Finn, Chelsea and Rajeswaran, Aravind and Kakade, Sham and Levine, Sergey http://arxiv.org/abs/1902.08438 Modulating transfer between tasks in gradient-based meta-learning by Grant, Erin and Jerfel, Ghassen and Heller, Katherine and Griffiths, Thomas L https://openreview.net/pdf?id=HyxpNnRcFX Learning to Adapt in Dynamic, Real-World Environments Through Meta-Reinforcement Learning by Nagabandi, Anusha and Clavera, Ignasi and Liu, Simin and Fearing, Ronald S and Abbeel, Pieter and Levine, Sergey and Finn, Chelsea http://arxiv.org/abs/1803.11347 Meta-Learning with Latent Embedding Optimization by Rusu, Andrei A and Rao, Dushyant and Sygnowski, Jakub and Vinyals, Oriol and Pascanu, Razvan and Osindero, Simon and Hadsell, Raia http://arxiv.org/abs/1807.05960 Learning to Generalize: Meta-Learning for Domain Generalization by Li, Da and Yang, Yongxin and Song, Yi-Zhe and Hospedales, Timothy M http://arxiv.org/abs/1710.03463 Some Considerations on Learning to Explore via Meta-Reinforcement Learning by Stadie, Bradly C and Yang, Ge and Houthooft, Rein and Chen, Xi and Duan, Yan and Wu, Yuhuai and Abbeel, Pieter and Sutskever, Ilya http://arxiv.org/abs/1803.01118 How to train your MAML by Antoniou, Antreas and Edwards, Harrison and Storkey, Amos http://arxiv.org/abs/1810.09502 Bayesian Model-Agnostic Meta-Learning by Kim, Taesup and Yoon, Jaesik and Dia, Ousmane and Kim, Sungwoong and Bengio, Yoshua and Ahn, Sungjin http://arxiv.org/abs/1806.03836 Probabilistic Model-Agnostic Meta-Learning by Finn, Chelsea and Xu, Kelvin and Levine, Sergey http://arxiv.org/abs/1806.02817 The effects of negative adaptation in Model-Agnostic Meta-Learning by Deleu, Tristan and Bengio, Yoshua http://arxiv.org/abs/1812.02159 Memory-based Parameter Adaptation by Sprechmann, Pablo and Jayakumar, Siddhant M and Rae, Jack W and Pritzel, Alexander and Badia, Adri{`a} Puigdom{`e}nech and Uria, Benigno and Vinyals, Oriol and Hassabis, Demis and Pascanu, Razvan and Blundell, Charles http://arxiv.org/abs/1802.10542 Deep Meta-Learning: Learning to Learn in the Concept Space by Zhou, Fengwei and Wu, Bin and Li, Zhenguo http://arxiv.org/abs/1802.03596 Deep Prior by Lacoste, Alexandre and Boquet, Thomas and Rostamzadeh, Negar and Oreshkin, Boris and Chung, Wonchang and Krueger, David http://arxiv.org/abs/1712.05016 Recasting Gradient-Based Meta-Learning as Hierarchical Bayes by Grant, Erin and Finn, Chelsea and Levine, Sergey and Darrell, Trevor and Griffiths, Thomas http://arxiv.org/abs/1801.08930 WNGrad: Learn the Learning Rate in Gradient Descent by Wu, Xiaoxia and Ward, Rachel and Bottou, L{\\'e}on http://arxiv.org/abs/1803.02865 Learning to Learn by Finn, Chelsea http://bair.berkeley.edu/blog/2017/07/18/learning-to-learn/ Continuous Adaptation via Meta-Learning in Nonstationary and Competitive Environments by Al-Shedivat, Maruan and Bansal, Trapit and Burda, Yuri and Sutskever, Ilya and Mordatch, Igor and Abbeel, Pieter http://arxiv.org/abs/1710.03641 Submission Form \u00b6 Loading\u2026","title":"Paper List"},{"location":"paper_list/#paper-list","text":"The following papers were announced on the learn2learn Twitter account . You can submit unannounced and meta-learning related papers through the following Google Form. (It does not matter if they are old or new, but they shouldn't be already announced.) Info Announce any paper via the Google Form to announce papers , also available below.","title":"Paper List"},{"location":"paper_list/#submitted-papers","text":"Grounded Language Learning Fast and Slow by Hill, Felix and Tieleman, Olivier and von Glehn, Tamara and Wong, Nathaniel and Merzic, Hamza and Clark, Stephen http://arxiv.org/abs/2009.01719 Sparse Meta Networks for Sequential Adaptation and its Application to Adaptive Language Modelling by Munkhdalai, Tsendsuren http://arxiv.org/abs/2009.01803 Learning with Differentiable Perturbed Optimizers by Berthet, Quentin and Blondel, Mathieu and Teboul, Olivier and Cuturi, Marco and Vert, Jean-Philippe and Bach, Francis http://arxiv.org/abs/2002.08676 What is being transferred in transfer learning? by Neyshabur, Behnam and Sedghi, Hanie and Zhang, Chiyuan http://arxiv.org/abs/2008.11687 On modulating the gradient for meta-learning by Simon, Christian and Koniusz, Piotr and Nock, Richard and Harandi, Mehrtash https://www.ecva.net/papers/eccv_2020/papers_ECCV/papers/123530545.pdf Meta-Learning with Shared Amortized Variational Inference by Iakovleva, Ekaterina and Verbeek, Jakob and Alahari, Karteek http://arxiv.org/abs/2008.12037 learn2learn: A Library for Meta-Learning Research by Arnold, S\u00e9bastien M R and Mahajan, Praateek and Datta, Debajyoti and Bunner, Ian and Zarkias, Konstantinos Saitas http://arxiv.org/abs/2008.12284 A Universal Representation Transformer Layer for Few-Shot Image Classification by Liu, Lu and Hamilton, William and Long, Guodong and Jiang, Jing and Larochelle, Hugo http://arxiv.org/abs/2006.11702 Safe Model-Based Meta-Reinforcement Learning: A Sequential Exploration-Exploitation Framework by Lew, Thomas and Sharma, Apoorva and Harrison, James and Pavone, Marco http://arxiv.org/abs/2008.11700 Learning to Learn in a Semi-Supervised Fashion by Chen, Yun-Chun and Chou, Chao-Te and Wang, Yu-Chiang Frank http://arxiv.org/abs/2008.11203 The Advantage of Conditional Meta-Learning for Biased Regularization and Fine-Tuning by Denevi, Giulia and Pontil, Massimiliano and Ciliberto, Carlo http://arxiv.org/abs/2008.10857 Adaptive Multi-level Hyper-gradient Descent by Jie, Renlong and Gao, Junbin and Vasnev, Andrey and Tran, Minh-Ngoc http://arxiv.org/abs/2008.07277 Few-Shot Image Classification via Contrastive Self-Supervised Learning by Li, Jianyi and Liu, Guizhong http://arxiv.org/abs/2008.09942 Does MAML really want feature reuse only? by Oh, Jaehoon and Yoo, Hyungjun and Kim, Changhwan and Yun, Se-Young http://arxiv.org/abs/2008.08882 Meta Learning MPC using Finite-Dimensional Gaussian Process Approximations by Arcari, Elena and Carron, Andrea and Zeilinger, Melanie N http://arxiv.org/abs/2008.05984 Offline Meta-Reinforcement Learning with Advantage Weighting by Mitchell, Eric and Rafailov, Rafael and Peng, Xue Bin and Levine, Sergey and Finn, Chelsea http://arxiv.org/abs/2008.06043 Explore then Execute: Adapting without Rewards via Factorized Meta-Reinforcement Learning by Liu, Evan Zheran and Raghunathan, Aditi and Liang, Percy and Finn, Chelsea http://arxiv.org/abs/2008.02790 Offline Meta Reinforcement Learning by Dorfman, Ron and Tamar, Aviv http://arxiv.org/abs/2008.02598 Few-Shot Learning via Learning the Representation, Provably by Du, Simon S and Hu, Wei and Kakade, Sham M and Lee, Jason D and Lei, Qi http://arxiv.org/abs/2002.09434 Multi-Task Reinforcement Learning as a Hidden-Parameter Block MDP by Zhang, Amy and Sodhani, Shagun and Khetarpal, Khimya and Pineau, Joelle http://arxiv.org/abs/2007.07206 CAMPs: Learning Context-Specific Abstractions for Efficient Planning in Factored MDPs by Chitnis, Rohan and Silver, Tom and Kim, Beomjoon and Kaelbling, Leslie Pack and Lozano-Perez, Tomas http://arxiv.org/abs/2007.13202 Unsupervised Learning of Visual Features by Contrasting Cluster Assignments by Caron, Mathilde and Misra, Ishan and Mairal, Julien and Goyal, Priya and Bojanowski, Piotr and Joulin, Armand http://arxiv.org/abs/2006.09882 MiCo: Mixup Co-Training for Semi-Supervised Domain Adaptation by Yang, Luyu and Wang, Yan and Gao, Mingfei and Shrivastava, Abhinav and Weinberger, Kilian Q and Chao, Wei-Lun and Lim, Ser-Nam http://arxiv.org/abs/2007.12684 Adaptive Task Sampling for Meta-Learning by Liu, Chenghao and Wang, Zhihao and Sahoo, Doyen and Fang, Yuan and Zhang, Kun and Hoi, Steven C H http://arxiv.org/abs/2007.08735 Discovering Reinforcement Learning Algorithms by Oh, Junhyuk and Hessel, Matteo and Czarnecki, Wojciech M and Xu, Zhongwen and van Hasselt, Hado and Singh, Satinder and Silver, David http://arxiv.org/abs/2007.08794 On the Outsized Importance of Learning Rates in Local Update Methods by Charles, Zachary and Kone{\\v c}n{\\'y}, Jakub http://arxiv.org/abs/2007.00878 Global Convergence and Induced Kernels of Gradient-Based Meta-Learning with Neural Nets by Wang, Haoxiang and Sun, Ruoyu and Li, Bo http://arxiv.org/abs/2006.14606 On the Iteration Complexity of Hypergradient Computation by Grazzi, Riccardo and Franceschi, Luca and Pontil, Massimiliano and Salzo, Saverio http://arxiv.org/abs/2006.16218 On the Outsized Importance of Learning Rates in Local Update Methods by Charles, Zachary and Kone{\\v c}n{\\'y}, Jakub http://arxiv.org/abs/2007.00878 Meta-SAC: Auto-tune the Entropy Temperature of Soft Actor-Critic via Metagradient by Wang, Yufei and Ni, Tianwei http://arxiv.org/abs/2007.01932 Meta Learning in the Continuous Time Limit by Xu, Ruitu and Chen, Lin and Karbasi, Amin http://arxiv.org/abs/2006.10921 Expert Training: Task Hardness Aware Meta-Learning for Few-Shot Classification by Zhou, Yucan and Wang, Yu and Cai, Jianfei and Zhou, Yu and Hu, Qinghua and Wang, Weiping http://arxiv.org/abs/2007.06240 MTL2L: A Context Aware Neural Optimiser by Kuo, Nicholas I-Hsien and Harandi, Mehrtash and Fourrier, Nicolas and Walder, Christian and Ferraro, Gabriela and Suominen, Hanna http://arxiv.org/abs/2007.09343 Navigating the Trade-Off between Multi-Task Learning and Learning to Multitask in Deep Neural Networks by Ravi, Sachin and Musslick, Sebastian and Hamin, Maia and Willke, Theodore L and Cohen, Jonathan D http://arxiv.org/abs/2007.10527 Balanced Meta-Softmax for Long-Tailed Visual Recognition by Ren, Jiawei and Yu, Cunjun and Sheng, Shunan and Ma, Xiao and Zhao, Haiyu and Yi, Shuai and Li, Hongsheng http://arxiv.org/abs/2007.10740 CrossTransformers: spatially-aware few-shot transfer by Doersch, Carl and Gupta, Ankush and Zisserman, Andrew http://arxiv.org/abs/2007.11498 Meta-Learning a Dynamical Language Model by Wolf, Thomas and Chaumond, Julien and Delangue, Clement http://arxiv.org/abs/1803.10631 Meta-Learning Requires Meta-Augmentation by Rajendran, Janarthanan and Irpan, Alex and Jang, Eric http://arxiv.org/abs/2007.05549 Adaptive Risk Minimization: A Meta-Learning Approach for Tackling Group Shift by Zhang, Marvin and Marklund, Henrik and Gupta, Abhishek and Levine, Sergey and Finn, Chelsea http://arxiv.org/abs/2007.02931 Meta-Learning Symmetries by Reparameterization by Zhou, Allan and Knowles, Tom and Finn, Chelsea http://arxiv.org/abs/2007.02933 Adaptive Risk Minimization: A Meta-Learning Approach for Tackling Group Shift by Zhang, Marvin and Marklund, Henrik and Gupta, Abhishek and Levine, Sergey and Finn, Chelsea http://arxiv.org/abs/2007.02931 A Brief Look at Generalization in Visual Meta-Reinforcement Learning by Alver, Safa and Precup, Doina http://arxiv.org/abs/2006.07262 Learning Representations by Stochastic Meta-Gradient Descent in Neural Networks by Veeriah, Vivek and Zhang, Shangtong and Sutton, Richard S http://arxiv.org/abs/1612.02879 PACOH: Bayes-Optimal Meta-Learning with PAC-Guarantees by Rothfuss, Jonas and Fortuin, Vincent and Krause, Andreas http://arxiv.org/abs/2002.05551 Meta-Meta-Classification for One-Shot Learning by Chowdhury, Arkabandhu and Chaudhari, Dipak and Chaudhuri, Swarat and Jermaine, Chris http://arxiv.org/abs/2004.08083 Relatedness Measures to Aid the Transfer of Building Blocks among Multiple Tasks by Nguyen, Trung B and Browne, Will N and Zhang, Mengjie http://arxiv.org/abs/2005.03947 Information-Theoretic Generalization Bounds for Meta-Learning and Applications by Jose, Sharu Theresa and Simeone, Osvaldo http://arxiv.org/abs/2005.04372 On Learning Intrinsic Rewards for Policy Gradient Methods by Zheng, Zeyu and Oh, Junhyuk and Singh, Satinder http://arxiv.org/abs/1804.06459 A Sample Complexity Separation between Non-Convex and Convex Meta-Learning by Saunshi, Nikunj and Zhang, Yi and Khodak, Mikhail and Arora, Sanjeev http://arxiv.org/abs/2002.11172 Bayesian Online Meta-Learning with Laplace Approximation by Yap, Pau Ching and Ritter, Hippolyt and Barber, David http://arxiv.org/abs/2005.00146 Meta-Reinforcement Learning for Robotic Industrial Insertion Tasks by Schoettler, Gerrit and Nair, Ashvin and Ojea, Juan Aparicio and Levine, Sergey and Solowjow, Eugen http://arxiv.org/abs/2004.14404 Continual Deep Learning by Functional Regularisation of Memorable Past by Pan, Pingbo and Swaroop, Siddharth and Immer, Alexander and Eschenhagen, Runa and Turner, Richard E and Khan, Mohammad Emtiyaz http://arxiv.org/abs/2004.14070 Jelly Bean World: A Testbed for Never-Ending Learning by Platanios, Emmanouil Antonios and Saparov, Abulhair and Mitchell, Tom https://openreview.net/pdf?id=Byx_YAVYPH Encouraging behavioral diversity in evolutionary robotics: an empirical study by Mouret, J-B and Doncieux, S http://dx.doi.org/10.1162/EVCO_a_00048 Defining Benchmarks for Continual Few-Shot Learning by Antoniou, Antreas and Patacchiola, Massimiliano and Ochal, Mateusz and Storkey, Amos http://arxiv.org/abs/2004.11967 Emergent Real-World Robotic Skills via Unsupervised Off-Policy Reinforcement Learning by Sharma, Archit and Ahn, Michael and Levine, Sergey and Kumar, Vikash and Hausman, Karol and Gu, Shixiang http://arxiv.org/abs/2004.12974 Empirical Bayes Transductive Meta-Learning with Synthetic Gradients by Hu, Shell Xu and Moreno, Pablo G and Xiao, Yang and Shen, Xi and Obozinski, Guillaume and Lawrence, Neil D and Damianou, Andreas http://arxiv.org/abs/2004.12696 Evolving Inborn Knowledge For Fast Adaptation in Dynamic POMDP Problems by Ben-Iwhiwhu, Eseoghene and Ladosz, Pawel and Dick, Jeffery and Chen, Wen-Hua and Pilly, Praveen and Soltoggio, Andrea http://arxiv.org/abs/2004.12846 Meta-World: A Benchmark and Evaluation for Multi-Task and Meta Reinforcement Learning by Yu, Tianhe and Quillen, Deirdre and He, Zhanpeng and Julian, Ryan and Hausman, Karol and Finn, Chelsea and Levine, Sergey http://arxiv.org/abs/1910.10897 Meta reinforcement learning as task inference by Humplik, Jan and Galashov, Alexandre and Hasenclever, Leonard and Ortega, Pedro A and Teh, Yee Whye and Heess, Nicolas http://arxiv.org/abs/1905.06424 Meta-Gradient Reinforcement Learning by Xu, Zhongwen and van Hasselt, Hado and Silver, David http://arxiv.org/abs/1805.09801 Self-Paced Deep Reinforcement Learning by Klink, Pascal and D'Eramo, Carlo and Peters, Jan and Pajarinen, Joni http://arxiv.org/abs/2004.11812 Scheduling the Learning Rate Via Hypergradients: New Insights and a New Algorithm by Donini, Michele and Franceschi, Luca and Majumder, Orchid and Pontil, Massimiliano and Frasconi, Paolo https://openreview.net/pdf?id=Ske6qJSKPH Learning Stabilizable Nonlinear Dynamics with Contraction-Based Regularization by Singh, Sumeet and Richards, Spencer M and Sindhwani, Vikas and Slotine, Jean-Jacques E and Pavone, Marco http://arxiv.org/abs/1907.13122 A Comprehensive Overview and Survey of Recent Advances in Meta-Learning by Peng, Huimin http://arxiv.org/abs/2004.11149 Learning a Formula of Interpretability to Learn Interpretable Formulas by Virgolin, Marco and De Lorenzo, Andrea and Medvet, Eric and Randone, Francesca http://arxiv.org/abs/2004.11170 Model-Based Meta-Reinforcement Learning for Flight with Suspended Payloads by Belkhale, Suneel and Li, Rachel and Kahn, Gregory and McAllister, Rowan and Calandra, Roberto and Levine, Sergey http://arxiv.org/abs/2004.11345 Frustratingly Simple Few-Shot Object Detection by Wang, Xin and Huang, Thomas E and Darrell, Trevor and Gonzalez, Joseph E and Yu, Fisher http://arxiv.org/abs/2003.06957 Meta Pseudo Labels by Pham, Hieu and Xie, Qizhe and Dai, Zihang and Le, Quoc V http://arxiv.org/abs/2003.10580 0e56da12-a2f0-4288-b745-c15deec9183a by Unknown http://learn2learn.net Finding online neural update rules by learning to remember by Gregor, Karol http://arxiv.org/abs/2003.03124 A New Meta-Baseline for Few-Shot Learning by Chen, Yinbo and Wang, Xiaolong and Liu, Zhuang and Xu, Huijuan and Darrell, Trevor http://arxiv.org/abs/2003.04390 Learning to be Global Optimizer by Zhang, Haotian and Sun, Jianyong and Xu, Zongben http://arxiv.org/abs/2003.04521 Scalable Multi-Task Imitation Learning with Autonomous Improvement by Singh, Avi and Jang, Eric and Irpan, Alexander and Kappler, Daniel and Dalal, Murtaza and Levine, Sergey and Khansari, Mohi and Finn, Chelsea http://arxiv.org/abs/2003.02636 Meta-learning for mixed linear regression by Kong, Weihao and Somani, Raghav and Song, Zhao and Kakade, Sham and Oh, Sewoong http://arxiv.org/abs/2002.08936 Provable Meta-Learning of Linear Representations by Tripuraneni, Nilesh and Jin, Chi and Jordan, Michael I http://arxiv.org/abs/2002.11684 Learning to Continually Learn by Beaulieu, Shawn and Frati, Lapo and Miconi, Thomas and Lehman, Joel and Stanley, Kenneth O and Clune, Jeff and Cheney, Nick http://arxiv.org/abs/2002.09571 PACOH: Bayes-Optimal Meta-Learning with PAC-Guarantees by Rothfuss, Jonas and Fortuin, Vincent and Krause, Andreas http://arxiv.org/abs/2002.05551 Incremental Learning for Metric-Based Meta-Learners by Liu, Qing and Majumder, Orchid and Ravichandran, Avinash and Bhotika, Rahul and Soatto, Stefano http://arxiv.org/abs/2002.04162 Hyper-Meta Reinforcement Learning with Sparse Reward by Hua, Yun and Wang, Xiangfeng and Jin, Bo and Li, Wenhao and Yan, Junchi and He, Xiaofeng and Zha, Hongyuan http://arxiv.org/abs/2002.04238 Meta-Learning across Meta-Tasks for Few-Shot Learning by Fei, Nanyi and Lu, Zhiwu and Gao, Yizhao and Tian, Jia and Xiang, Tao and Wen, Ji-Rong http://arxiv.org/abs/2002.04274 Distribution-Agnostic Model-Agnostic Meta-Learning by Collins, Liam and Mokhtari, Aryan and Shakkottai, Sanjay http://arxiv.org/abs/2002.04766 Provably Convergent Policy Gradient Methods for Model-Agnostic Meta-Reinforcement Learning by Fallah, Alireza and Mokhtari, Aryan and Ozdaglar, Asuman http://arxiv.org/abs/2002.05135 Meta-learning framework with applications to zero-shot time-series forecasting by Oreshkin, Boris N and Carpov, Dmitri and Chapados, Nicolas and Bengio, Yoshua http://arxiv.org/abs/2002.02887 A Loss-Function for Causal Machine-Learning by Yang, I-Sheng http://arxiv.org/abs/2001.00629 Self-Tuning Deep Reinforcement Learning by Zahavy, Tom and Xu, Zhongwen and Veeriah, Vivek and Hessel, Matteo and Van Hasslet, Hado and Silver, David and Singh, Satinder http://arxiv.org/abs/2002.12928 Learning Adaptive Loss for Robust Learning with Noisy Labels by Shu, Jun and Zhao, Qian and Chen, Keyu and Xu, Zongben and Meng, Deyu http://arxiv.org/abs/2002.06482 A Structured Prediction Approach for Conditional Meta-Learning by Wang, Ruohan and Demiris, Yiannis and Ciliberto, Carlo http://arxiv.org/abs/2002.08799 Curriculum in Gradient-Based Meta-Reinforcement Learning by Mehta, Bhairav and Deleu, Tristan and Raparthy, Sharath Chandra and Pal, Chris J and Paull, Liam http://arxiv.org/abs/2002.07956 Multi-Step Model-Agnostic Meta-Learning: Convergence and Improved Algorithms by Ji, Kaiyi and Yang, Junjie and Liang, Yingbin http://arxiv.org/abs/2002.07836 Local Nonparametric Meta-Learning by Goo, Wonjoon and Niekum, Scott http://arxiv.org/abs/2002.03272 Revisiting Meta-Learning as Supervised Learning by Chao, Wei-Lun and Ye, Han-Jia and Zhan, De-Chuan and Campbell, Mark and Weinberger, Kilian Q http://arxiv.org/abs/2002.00573 SimpleShot: Revisiting Nearest-Neighbor Classification for Few-Shot Learning by Wang, Yan and Chao, Wei-Lun and Weinberger, Kilian Q and van der Maaten, Laurens http://arxiv.org/abs/1911.04623 Fast and Generalized Adaptation for Few-Shot Learning by Song, Liang and Liu, Jinlu and Qin, Yongqiang http://arxiv.org/abs/1911.10807 Meta-Learning without Memorization by Yin, Mingzhang and Tucker, George and Zhou, Mingyuan and Levine, Sergey and Finn, Chelsea http://arxiv.org/abs/1912.03820 Your Classifier is Secretly an Energy Based Model and You Should Treat it Like One by Grathwohl, Will and Wang, Kuan-Chieh and Jacobsen, J{\\\"o}rn-Henrik and Duvenaud, David and Norouzi, Mohammad and Swersky, Kevin http://arxiv.org/abs/1912.03263 MAME : Model-Agnostic Meta-Exploration by Gurumurthy, Swaminathan and Kumar, Sumit and Sycara, Katia http://arxiv.org/abs/1911.04024 Constructing Multiple Tasks for Augmentation: Improving Neural Image Classification With K-means Features by Gui, Tao and Qing, Lizhi and Zhang, Qi and Ye, Jiacheng and Yan, Hang and Fei, Zichu and Huang, Xuanjing http://arxiv.org/abs/1911.07518 Meta Adaptation using Importance Weighted Demonstrations by Lekkala, Kiran and Abu-El-Haija, Sami and Itti, Laurent http://arxiv.org/abs/1911.10322 VIABLE: Fast Adaptation via Backpropagating Learned Loss by Feng, Leo and Zintgraf, Luisa and Peng, Bei and Whiteson, Shimon http://arxiv.org/abs/1911.13159 Decoupling Adaptation from Modeling with Meta-Optimizers for Meta Learning by Arnold, S{\\'e}bastien M R and Iqbal, Shariq and Sha, Fei http://arxiv.org/abs/1910.13603 TADAM: Task dependent adaptive metric for improved few-shot learning by Oreshkin, Boris and Rodr{\\'\\i}guez L{\\'o}pez, Pau and Lacoste, Alexandre http://papers.nips.cc/paper/7352-tadam-task-dependent-adaptive-metric-for-improved-few-shot-learning.pdf Learning to Few-Shot Learn Across Diverse Natural Language Classification Tasks by Bansal, Trapit and Jha, Rishikesh and McCallum, Andrew http://arxiv.org/abs/1911.03863 Optimizing Millions of Hyperparameters by Implicit Differentiation by Lorraine, Jonathan and Vicol, Paul and Duvenaud, David http://arxiv.org/abs/1911.02590 Meta-data: Characterization of Input Features for Meta-learning by Castiello, Ciro and Castellano, Giovanna and Fanelli, Anna Maria http://dx.doi.org/10.1007/11526018_45 Meta-Learning for Low-resource Natural Language Generation in Task-oriented Dialogue Systems by Mi, Fei and Huang, Minlie and Zhang, Jiyong and Faltings, Boi http://arxiv.org/abs/1905.05644 Domain Generalization via Model-Agnostic Learning of Semantic Features by Dou, Qi and Castro, Daniel C and Kamnitsas, Konstantinos and Glocker, Ben http://arxiv.org/abs/1910.13580 Hierarchical Expert Networks for Meta-Learning by Hihn, Heinke and Braun, Daniel A http://arxiv.org/abs/1911.00348 Online Meta-Learning on Non-convex Setting by Zhuang, Zhenxun and Wang, Yunlong and Yu, Kezi and Lu, Songtao http://arxiv.org/abs/1910.10196 Learning-to-Learn Stochastic Gradient Descent with Biased Regularization by Denevi, Giulia and Ciliberto, Carlo and Grazzi, Riccardo and Pontil, Massimiliano http://arxiv.org/abs/1903.10399 Provable Guarantees for Gradient-Based Meta-Learning by Khodak, Mikhail and Balcan, Maria-Florina and Talwalkar, Ameet http://arxiv.org/abs/1902.10644 The TCGA Meta-Dataset Clinical Benchmark by Samiei, Mandana and W{\\\"u}rfl, Tobias and Deleu, Tristan and Weiss, Martin and Dutil, Francis and Fevens, Thomas and Boucher, Genevi{`e}ve and Lemieux, Sebastien and Cohen, Joseph Paul http://arxiv.org/abs/1910.08636 VariBAD: A Very Good Method for Bayes-Adaptive Deep RL via Meta-Learning by Zintgraf, Luisa and Shiarlis, Kyriacos and Igl, Maximilian and Schulze, Sebastian and Gal, Yarin and Hofmann, Katja and Whiteson, Shimon http://arxiv.org/abs/1910.08348 Meta-Transfer Learning through Hard Tasks by Sun, Qianru and Liu, Yaoyao and Chen, Zhaozheng and Chua, Tat-Seng and Schiele, Bernt http://arxiv.org/abs/1910.03648 Model-Agnostic Meta-Learning using Runge-Kutta Methods by Im, Daniel Jiwoong and Jiang, Yibo and Verma, Nakul http://arxiv.org/abs/1910.07368 Improving Generalization in Meta Reinforcement Learning using Learned Objectives by Kirsch, Louis and van Steenkiste, Sjoerd and Schmidhuber, J{\\\"u}rgen http://arxiv.org/abs/1910.04098 Generalized Inner Loop Meta-Learning by Grefenstette, Edward and Amos, Brandon and Yarats, Denis and Htut, Phu Mon and Molchanov, Artem and Meier, Franziska and Kiela, Douwe and Cho, Kyunghyun and Chintala, Soumith http://arxiv.org/abs/1910.01727 Is Fast Adaptation All You Need? by Javed, Khurram and Yao, Hengshuai and White, Martha http://arxiv.org/abs/1910.01705 Deep Reinforcement Learning for Single-Shot Diagnosis and Adaptation in Damaged Robots by Verma, Shresth and Nair, Haritha S and Agarwal, Gaurav and Dhar, Joydip and Shukla, Anupam http://arxiv.org/abs/1910.01240 ES-MAML: Simple Hessian-Free Meta Learning by Song, Xingyou and Gao, Wenbo and Yang, Yuxiang and Choromanski, Krzysztof and Pacchiano, Aldo and Tang, Yunhao http://arxiv.org/abs/1910.01215 Meta-Q-Learning by Fakoor, Rasool and Chaudhari, Pratik and Soatto, Stefano and Smola, Alexander J http://arxiv.org/abs/1910.00125 Efficient meta reinforcement learning via meta goal generation by Fu, Haotian and Tang, Hongyao and Hao, Jianye http://arxiv.org/abs/1909.13607 Chameleon: Learning Model Initializations Across Tasks With Different Schemas by Brinkmeyer, Lukas and Drumond, Rafael Rego and Scholz, Randolf and Grabocka, Josif and Schmidt-Thieme, Lars http://arxiv.org/abs/1909.13576 Learning Fast Adaptation with Meta Strategy Optimization by Yu, Wenhao and Tan, Jie and Bai, Yunfei and Coumans, Erwin and Ha, Sehoon http://arxiv.org/abs/1909.12995 Meta-Inverse Reinforcement Learning with Probabilistic Context Variables by Yu, Lantao and Yu, Tianhe and Finn, Chelsea and Ermon, Stefano http://arxiv.org/abs/1909.09314 Modular Meta-Learning with Shrinkage by Chen, Yutian and Friesen, Abram L and Behbahani, Feryal and Budden, David and Hoffman, Matthew W and Doucet, Arnaud and de Freitas, Nando http://arxiv.org/abs/1909.05557 Loaded DiCE: Trading off Bias and Variance in Any-Order Score Function Estimators for Reinforcement Learning by Farquhar, Gregory and Whiteson, Shimon and Foerster, Jakob http://arxiv.org/abs/1909.10549 Rapid Learning or Feature Reuse? Towards Understanding the Effectiveness of MAML by Raghu, Aniruddh and Raghu, Maithra and Bengio, Samy and Vinyals, Oriol http://arxiv.org/abs/1909.09157 Meta-Learning by Vanschoren, Joaquin https://doi.org/10.1007/978-3-030-05318-5_2 Understanding Short-Horizon Bias in Stochastic Meta-Optimization by Wu, Yuhuai and Ren, Mengye and Liao, Renjie and Grosse, Roger http://arxiv.org/abs/1803.02021 On First-Order Meta-Learning Algorithms by Nichol, Alex and Achiam, Joshua and Schulman, John http://arxiv.org/abs/1803.02999 Towards Understanding Generalization in Gradient-Based Meta-Learning by Guiroy, Simon and Verma, Vikas and Pal, Christopher http://arxiv.org/abs/1907.07287 They empirically study the landscape of fast-adaptation in MAML. The most interesting claim is that when meta-overfitting, the loss landscape becomes flatter on test tasks. On the Convergence Theory of Gradient-Based Model-Agnostic Meta-Learning Algorithms by Fallah, Alireza and Mokhtari, Aryan and Ozdaglar, Asuman http://arxiv.org/abs/1908.10400 Learning to Learn with Gradients by Finn, Chelsea http://learn2learn.net Acetylcholine and memory by Hasselmo, M E and Bower, J M https://www.ncbi.nlm.nih.gov/pubmed/7688162 A THEORY OF META-LEARNING AND PRINCIPLES OF FACILITATION: AN ORGANISMIC PERSPECTIVE by Maudsley, Donald B https://uosc.primo.exlibrisgroup.com/discovery/fulldisplay?docid=proquest302999651&context=PC&vid=01USC_INST:01USC&lang=en&search_scope=MyInst_and_CI&adaptor=Primo%20Central&tab=Everything&mode=Basic THE ROLE OF METALEARNING IN STUDY PROCESSES by Biggs, J B http://doi.wiley.com/10.1111/j.2044-8279.1985.tb02625.x Understanding and correcting pathologies in the training of learned optimizers by Metz, Luke and Maheswaranathan, Niru and Nixon, Jeremy and Daniel Freeman, C and Sohl-Dickstein, Jascha http://arxiv.org/abs/1810.10180 Provides many tricks (e.g. split train batch for model \\& opt, average gradient estimators) for training differentiable optimizers online. They also have a couple of interesting observations specific to recurrent optimizers. Learned Optimizers that Scale and Generalize by Wichrowska, Olga and Maheswaranathan, Niru and Hoffman, Matthew W and Colmenarejo, Sergio Gomez and Denil, Misha and de Freitas, Nando and Sohl-Dickstein, Jascha http://arxiv.org/abs/1703.04813 Using learned optimizers to make models robust to input noise by Metz, Luke and Maheswaranathan, Niru and Shlens, Jonathon and Sohl-Dickstein, Jascha and Cubuk, Ekin D http://arxiv.org/abs/1906.03367 Learning to Optimize Neural Nets by Li, Ke and Malik, Jitendra http://arxiv.org/abs/1703.00441 Meta-Learning Update Rules for Unsupervised Representation Learning by Metz, Luke and Maheswaranathan, Niru and Cheung, Brian and Sohl-Dickstein, Jascha http://arxiv.org/abs/1804.00222 Learning to Optimize by Li, Ke and Malik, Jitendra http://arxiv.org/abs/1606.01885 Learning to learn by gradient descent by gradient descent by Andrychowicz, M and Denil, M and Gomez, S http://learn2learn.net Online Learning Rate Adaptation with Hypergradient Descent by Baydin, Atilim Gunes and Cornish, Robert and Rubio, David Martinez and Schmidt, Mark and Wood, Frank http://arxiv.org/abs/1703.04782 They adapt the learning rate of SGD by differentiating the loss of the next parameters w.r.t. the learning rate. They observe that the gradient of the learning rate is simply the inner product of the last two gradients. Adapting Bias by Gradient Descent: An Incremental Version of Delta-Bar-Delta by Sutton, Richard S http://dx.doi.org/ What's mostly interesting in this paper is the adaptation of delta-bar-delta to the online scenario. The idea of representing the learning rate as an exponential is nice. Also nice to see that the derivation suggests a full-matrix adaptive case. Gain adaptation beats least squares by Sutton, Richard S https://pdfs.semanticscholar.org/7ec8/876f219b3b3d5c894a3f395c89c382029cc5.pdf This paper extends IDBD as algorithms K1 and K2, but from my quick read, it isn't clear what's the motivation for those modifications. (Seems to work in a `normalized space'', {\\ a} la natural gradient ?)They do work better. Local Gain Adaptation in Stochastic Gradient Descent by Schraudolph, Nicol N https://pdfs.semanticscholar.org/31a0/b86c3cd04e6539626f34b80db7ff79d23f40.pdf This algorithm extends IDBD (Sutton) to the non-linear setting. Interestingly, they have a few brief discussionson the difficulties to optimize at the meta-level. (c.f. Meta-level conditioning section.) Overall, it shines light on the ground idea behind IDBD. TIDBD: Adapting Temporal-difference Step-sizes Through Stochastic Meta-descent by Kearney, Alex and Veeriah, Vivek and Travnik, Jaden B and Sutton, Richard S and Pilarski, Patrick M http://arxiv.org/abs/1804.03334 Increased rates of convergence through learning rate adaptation by Jacobs, Robert A http://www.sciencedirect.com/science/article/pii/0893608088900032 This paper argues that we need (at least) four ingredients to improve optimization of connectionist networks: 1. each parameter has its own stepsize, 2. stepsizes vary over time, 3. if consecutive gradients of a stepsize have the same sign, the stepsize should be increased, 4. conversely, if the stepsize should be decreased if its gradients have opposite signs. It also proposes to use two improvements: 1. Momentum (i.e. Polyak's heavyball), 2. delta-bar-delta (i.e. learning the stepsize). It has an interesting comment on the difficulty of learning the stepsize, and therefore comes up with a ``hack'' that outperforms momentum. Meta-descent for Online, Continual Prediction by Jacobsen, Andrew and Schlegel, Matthew and Linke, Cameron and Degris, Thomas and White, Adam and White, Martha http://arxiv.org/abs/1907.07751 The idea is to learn the learning rate so as to minimize the norm of the gradient. They argue that for the continual learning setting, this forces the algorithm to stay ``as stable as possible''. No theorems, small-scale (but interesting) experiments. Adaptation of learning rate parameters by Sutton, Rich http://learn2learn.net Gradient-Based Meta-Learning with Learned Layerwise Metric and Subspace by Lee, Yoonho and Choi, Seungjin http://arxiv.org/abs/1801.05558 Meta-Learning with Warped Gradient Descent by Flennerhag, Sebastian and Rusu, Andrei A and Pascanu, Razvan and Yin, Hujun and Hadsell, Raia http://arxiv.org/abs/1909.00025 Meta-Learning via Learned Loss by Chebotar, Yevgen and Molchanov, Artem and Bechtle, Sarah and Righetti, Ludovic and Meier, Franziska and Sukhatme, Gaurav http://arxiv.org/abs/1906.05374 They learn the loss as a NN, and that loss's objective is to maximize the sum of rewards. It is provided a bunch of things, including inputs, outputs, goals. Meta-Curvature by Park, Eunbyung and Oliva, Junier B http://arxiv.org/abs/1902.03356 Alpha MAML: Adaptive Model-Agnostic Meta-Learning by Behl, Harkirat Singh and Baydin, At{\\i}l{\\i}m G{\\\"u}ne{\\c s} and Torr, Philip H S http://arxiv.org/abs/1905.07435 They combine hypergradient and MAML: adapt all learning rates at all times. Meta-SGD: Learning to Learn Quickly for Few-Shot Learning by Li, Zhenguo and Zhou, Fengwei and Chen, Fei and Li, Hang http://arxiv.org/abs/1707.09835 ProMP: Proximal Meta-Policy Search by Rothfuss, Jonas and Lee, Dennis and Clavera, Ignasi and Asfour, Tamim and Abbeel, Pieter http://arxiv.org/abs/1810.06784 Model-Agnostic Meta-Learning for Fast Adaptation of Deep Networks by Finn, Chelsea and Abbeel, Pieter and Levine, Sergey http://learn2learn.net Optimization as a model for few-shot learning by Ravi, Sachin and Larochelle, Hugo https://openreview.net/pdf?id=rJY0-Kcll Fast Context Adaptation via Meta-Learning by Zintgraf, Luisa M and Shiarlis, Kyriacos and Kurin, Vitaly and Hofmann, Katja and Whiteson, Shimon http://arxiv.org/abs/1810.03642 Meta-Learning with Implicit Gradients by Rajeswaran, Aravind and Finn, Chelsea and Kakade, Sham and Levine, Sergey http://arxiv.org/abs/1909.04630 Natural Neural Networks by Desjardins, Guillaume and Simonyan, Karen and Pascanu, Razvan and Kavukcuoglu, Koray http://dl.acm.org/citation.cfm?id=2969442.2969471 A Baseline for Few-Shot Image Classification by Dhillon, Guneet S and Chaudhari, Pratik and Ravichandran, Avinash and Soatto, Stefano http://arxiv.org/abs/1909.02729 A CLOSER LOOK AT FEW-SHOT CLASSIFICATION by Chen, Wei-Yu and Liu, Yen-Cheng and Kira, Zsolt https://openreview.net/pdf?id=HkxLXnAcFQ Suggests that meta-learning papers haven't been tested against classical baselines. When considering those baselines, they perform better than many of the recent meta-learning techniques. Meta-learning with differentiable closed-form solvers by Bertinetto, Luca and Henriques, Joao F and Torr, Philip and Vedaldi, Andrea https://openreview.net/forum?id=HyxnZh0ct7 Uncertainty in Model-Agnostic Meta-Learning using Variational Inference by Nguyen, Cuong and Do, Thanh-Toan and Carneiro, Gustavo http://arxiv.org/abs/1907.11864 Meta-Reinforcement Learning of Structured Exploration Strategies by Gupta, Abhishek and Mendonca, Russell and Liu, Yuxuan and Abbeel, Pieter and Levine, Sergey http://arxiv.org/abs/1802.07245 Metalearned Neural Memory by Munkhdalai, Tsendsuren and Sordoni, Alessandro and Wang, Tong and Trischler, Adam http://arxiv.org/abs/1907.09720 Accelerated Stochastic Approximation by Kesten, Harry https://projecteuclid.org/euclid.aoms/1177706705 Meta-Learning for Black-box Optimization by Vishnu, T V and Malhotra, Pankaj and Narwariya, Jyoti and Vig, Lovekesh and Shroff, Gautam http://arxiv.org/abs/1907.06901 They essentially extend the recurrent meta-learning framework in a few ways: 1. Use regret instead of objective improvement as meta-learning objective. 2. Normalize the objective so as to make it play nice with LSTMs. 3. Incorporate domain-constraints, so that the LSTM always outputs feasible solutions. All are described in page 3. Task Agnostic Continual Learning via Meta Learning by He, Xu and Sygnowski, Jakub and Galashov, Alexandre and Rusu, Andrei A and Teh, Yee Whye and Pascanu, Razvan http://arxiv.org/abs/1906.05201 Watch, Try, Learn: Meta-Learning from Demonstrations and Reward by Zhou, Allan and Jang, Eric and Kappler, Daniel and Herzog, Alex and Khansari, Mohi and Wohlhart, Paul and Bai, Yunfei and Kalakrishnan, Mrinal and Levine, Sergey and Finn, Chelsea http://arxiv.org/abs/1906.03352 Meta-Learning Representations for Continual Learning by Javed, Khurram and White, Martha http://arxiv.org/abs/1905.12588 TapNet: Neural Network Augmented with Task-Adaptive Projection for Few-Shot Learning by Yoon, Sung Whan and Seo, Jun and Moon, Jaekyun http://arxiv.org/abs/1905.06549 Meta Reinforcement Learning with Task Embedding and Shared Policy by Lan, Lin and Li, Zhenguo and Guan, Xiaohong and Wang, Pinghui http://arxiv.org/abs/1905.06527 Hierarchically Structured Meta-learning by Yao, Huaxiu and Wei, Ying and Huang, Junzhou and Li, Zhenhui http://arxiv.org/abs/1905.05301 Curious Meta-Controller: Adaptive Alternation between Model-Based and Model-Free Control in Deep Reinforcement Learning by Hafez, Muhammad Burhan and Weber, Cornelius and Kerzel, Matthias and Wermter, Stefan http://arxiv.org/abs/1905.01718 Learning to Learn in Simulation by Teng, Ervin and Iannucci, Bob http://arxiv.org/abs/1902.01569 Meta-Learning with Differentiable Convex Optimization by Lee, Kwonjoon and Maji, Subhransu and Ravichandran, Avinash and Soatto, Stefano http://arxiv.org/abs/1904.03758 Functional Regularisation for Continual Learning by Titsias, Michalis K and Schwarz, Jonathan and de G. Matthews, Alexander G and Pascanu, Razvan and Teh, Yee Whye http://arxiv.org/abs/1901.11356 Learning to Forget for Meta-Learning by Baik, Sungyong and Hong, Seokil and Lee, Kyoung Mu http://arxiv.org/abs/1906.05895 Meta-learning of Sequential Strategies by Ortega, Pedro A and Wang, Jane X and Rowland, Mark and Genewein, Tim and Kurth-Nelson, Zeb and Pascanu, Razvan and Heess, Nicolas and Veness, Joel and Pritzel, Alex and Sprechmann, Pablo and Jayakumar, Siddhant M and McGrath, Tom and Miller, Kevin and Azar, Mohammad and Osband, Ian and Rabinowitz, Neil and Gy{\\\"o}rgy, Andr{\\'a}s and Chiappa, Silvia and Osindero, Simon and Teh, Yee Whye and van Hasselt, Hado and de Freitas, Nando and Botvinick, Matthew and Legg, Shane http://arxiv.org/abs/1905.03030 This paper essentially provides a theoretical framework to ground the fact that recurrent meta-learning (RL^2, LLGD^2) performs Bayesian inference during adaptation. Auto-Meta: Automated Gradient Based Meta Learner Search by Kim, Jaehong and Lee, Sangyeul and Kim, Sungwan and Cha, Moonsu and Lee, Jung Kwon and Choi, Youngduck and Choi, Yongseok and Cho, Dong-Yeon and Kim, Jiwon http://arxiv.org/abs/1806.06927 Adaptive Gradient-Based Meta-Learning Methods by Khodak, Mikhail and Florina-Balcan, Maria and Talwalkar, Ameet http://arxiv.org/abs/1906.02717 Embedded Meta-Learning: Toward more flexible deep-learning models by Lampinen, Andrew K and McClelland, James L http://arxiv.org/abs/1905.09950 Modular meta-learning by Alet, Ferran and Lozano-P{\\'e}rez, Tom{\\'a}s and Kaelbling, Leslie P http://arxiv.org/abs/1806.10166 MetaPred: Meta-Learning for Clinical Risk Prediction with Limited Patient Electronic Health Records by Zhang, Xi Sheryl and Tang, Fengyi and Dodge, Hiroko and Zhou, Jiayu and Wang, Fei http://arxiv.org/abs/1905.03218 Prototypical Networks for Few-shot Learning by Snell, Jake and Swersky, Kevin and Zemel, Richard S http://arxiv.org/abs/1703.05175 Meta-learners' learning dynamics are unlike learners' by Rabinowitz, Neil C http://arxiv.org/abs/1905.01320 Backpropamine: training self-modifying neural networks with differentiable neuromodulated plasticity by Miconi, Thomas and Rawal, Aditya and Clune, Jeff and Stanley, Kenneth O https://openreview.net/forum?id=r1lrAiA5Ym Reinforcement Learning, Fast and Slow by Botvinick, Matthew and Ritter, Sam and Wang, Jane X and Kurth-Nelson, Zeb and Blundell, Charles and Hassabis, Demis http://dx.doi.org/10.1016/j.tics.2019.02.006 Been There, Done That: Meta-Learning with Episodic Recall by Ritter, Samuel and Wang, Jane X and Kurth-Nelson, Zeb and Jayakumar, Siddhant M and Blundell, Charles and Pascanu, Razvan and Botvinick, Matthew http://arxiv.org/abs/1805.09692 Guided Meta-Policy Search by Mendonca, Russell and Gupta, Abhishek and Kralev, Rosen and Abbeel, Pieter and Levine, Sergey and Finn, Chelsea http://arxiv.org/abs/1904.00956 Hierarchical Meta Learning by Zou, Yingtian and Feng, Jiashi http://arxiv.org/abs/1904.09081 A Meta-Transfer Objective for Learning to Disentangle Causal Mechanisms by Bengio, Yoshua and Deleu, Tristan and Rahaman, Nasim and Ke, Rosemary and Lachapelle, S{\\'e}bastien and Bilaniuk, Olexa and Goyal, Anirudh and Pal, Christopher http://arxiv.org/abs/1901.10912 Generalize Across Tasks: Efficient Algorithms for Linear Representation Learning by Bullins, Brian and Hazan, Elad and Kalai, Adam and Livni, Roi http://proceedings.mlr.press/v98/bullins19a.html Incremental Learning-to-Learn with Statistical Guarantees by Denevi, Giulia and Ciliberto, Carlo and Stamos, Dimitris and Pontil, Massimiliano http://arxiv.org/abs/1803.08089 A Model of Inductive Bias Learning by Baxter, J http://arxiv.org/abs/1106.0245 Efficient Off-Policy Meta-Reinforcement Learning via Probabilistic Context Variables by Rakelly, Kate and Zhou, Aurick and Quillen, Deirdre and Finn, Chelsea and Levine, Sergey http://arxiv.org/abs/1903.08254 Continual Learning with Tiny Episodic Memories by Chaudhry, Arslan and Rohrbach, Marcus and Elhoseiny, Mohamed and Ajanthan, Thalaiyasingam and Dokania, Puneet K and Torr, Philip H S and Ranzato, Marc'aurelio http://arxiv.org/abs/1902.10486 Online Meta-Learning by Finn, Chelsea and Rajeswaran, Aravind and Kakade, Sham and Levine, Sergey http://arxiv.org/abs/1902.08438 Modulating transfer between tasks in gradient-based meta-learning by Grant, Erin and Jerfel, Ghassen and Heller, Katherine and Griffiths, Thomas L https://openreview.net/pdf?id=HyxpNnRcFX Learning to Adapt in Dynamic, Real-World Environments Through Meta-Reinforcement Learning by Nagabandi, Anusha and Clavera, Ignasi and Liu, Simin and Fearing, Ronald S and Abbeel, Pieter and Levine, Sergey and Finn, Chelsea http://arxiv.org/abs/1803.11347 Meta-Learning with Latent Embedding Optimization by Rusu, Andrei A and Rao, Dushyant and Sygnowski, Jakub and Vinyals, Oriol and Pascanu, Razvan and Osindero, Simon and Hadsell, Raia http://arxiv.org/abs/1807.05960 Learning to Generalize: Meta-Learning for Domain Generalization by Li, Da and Yang, Yongxin and Song, Yi-Zhe and Hospedales, Timothy M http://arxiv.org/abs/1710.03463 Some Considerations on Learning to Explore via Meta-Reinforcement Learning by Stadie, Bradly C and Yang, Ge and Houthooft, Rein and Chen, Xi and Duan, Yan and Wu, Yuhuai and Abbeel, Pieter and Sutskever, Ilya http://arxiv.org/abs/1803.01118 How to train your MAML by Antoniou, Antreas and Edwards, Harrison and Storkey, Amos http://arxiv.org/abs/1810.09502 Bayesian Model-Agnostic Meta-Learning by Kim, Taesup and Yoon, Jaesik and Dia, Ousmane and Kim, Sungwoong and Bengio, Yoshua and Ahn, Sungjin http://arxiv.org/abs/1806.03836 Probabilistic Model-Agnostic Meta-Learning by Finn, Chelsea and Xu, Kelvin and Levine, Sergey http://arxiv.org/abs/1806.02817 The effects of negative adaptation in Model-Agnostic Meta-Learning by Deleu, Tristan and Bengio, Yoshua http://arxiv.org/abs/1812.02159 Memory-based Parameter Adaptation by Sprechmann, Pablo and Jayakumar, Siddhant M and Rae, Jack W and Pritzel, Alexander and Badia, Adri{`a} Puigdom{`e}nech and Uria, Benigno and Vinyals, Oriol and Hassabis, Demis and Pascanu, Razvan and Blundell, Charles http://arxiv.org/abs/1802.10542 Deep Meta-Learning: Learning to Learn in the Concept Space by Zhou, Fengwei and Wu, Bin and Li, Zhenguo http://arxiv.org/abs/1802.03596 Deep Prior by Lacoste, Alexandre and Boquet, Thomas and Rostamzadeh, Negar and Oreshkin, Boris and Chung, Wonchang and Krueger, David http://arxiv.org/abs/1712.05016 Recasting Gradient-Based Meta-Learning as Hierarchical Bayes by Grant, Erin and Finn, Chelsea and Levine, Sergey and Darrell, Trevor and Griffiths, Thomas http://arxiv.org/abs/1801.08930 WNGrad: Learn the Learning Rate in Gradient Descent by Wu, Xiaoxia and Ward, Rachel and Bottou, L{\\'e}on http://arxiv.org/abs/1803.02865 Learning to Learn by Finn, Chelsea http://bair.berkeley.edu/blog/2017/07/18/learning-to-learn/ Continuous Adaptation via Meta-Learning in Nonstationary and Competitive Environments by Al-Shedivat, Maruan and Bansal, Trapit and Burda, Yuri and Sutskever, Ilya and Mordatch, Igor and Abbeel, Pieter http://arxiv.org/abs/1710.03641","title":"Submitted Papers"},{"location":"paper_list/#submission-form","text":"Loading\u2026","title":"Submission Form"},{"location":"_build/pydocmd/","text":"learn2learn is a software library for meta-learning research. learn2learn builds on top of PyTorch to accelerate two aspects of the meta-learning research cycle: fast prototyping , essential in letting researchers quickly try new ideas, and correct reproducibility , ensuring that these ideas are evaluated fairly. learn2learn provides low-level utilities and unified interface to create new algorithms and domains, together with high-quality implementations of existing algorithms and standardized benchmarks. It retains compatibility with torchvision , torchaudio , torchtext , cherry , and any other PyTorch-based library you might be using. To learn more, see our whitepaper: arXiv:2008.12284 Overview learn2learn.data : TaskDataset and transforms to create few-shot tasks from any PyTorch dataset. learn2learn.vision : Models, datasets, and benchmarks for computer vision and few-shot learning. learn2learn.gym : Environment and utilities for meta-reinforcement learning. learn2learn.algorithms : High-level wrappers for existing meta-learning algorithms. learn2learn.optim : Utilities and algorithms for differentiable optimization and meta-descent. Resources Website: http://learn2learn.net/ Documentation: http://learn2learn.net/docs/learn2learn Tutorials: http://learn2learn.net/tutorials/getting_started/ Examples: https://github.com/learnables/learn2learn/tree/master/examples GitHub: https://github.com/learnables/learn2learn/ Slack: http://slack.learn2learn.net/ Installation \u00b6 1 pip install learn2learn Snippets & Examples \u00b6 The following snippets provide a sneak peek at the functionalities of learn2learn. High-level Wrappers \u00b6 Few-Shot Learning with MAML For more algorithms (ProtoNets, ANIL, Meta-SGD, Reptile, Meta-Curvature, KFO) refer to the examples folder. Most of them can be implemented with with the `GBML` wrapper. ( documentation ). 1 2 3 4 5 6 7 8 9 10 maml = l2l . algorithms . MAML ( model , lr = 0.1 ) opt = torch . optim . SGD ( maml . parameters (), lr = 0.001 ) for iteration in range ( 10 ): opt . zero_grad () task_model = maml . clone () # torch.clone() for nn.Modules adaptation_loss = compute_loss ( task_model ) task_model . adapt ( adaptation_loss ) # computes gradient, update task_model in-place evaluation_loss = compute_loss ( task_model ) evaluation_loss . backward () # gradients w.r.t. maml.parameters() opt . step () Meta-Descent with Hypergradient Learn any kind of optimization algorithm with the `LearnableOptimizer`. ( example and documentation ) 1 2 3 4 5 6 7 8 9 10 11 linear = nn . Linear ( 784 , 10 ) transform = l2l . optim . ModuleTransform ( l2l . nn . Scale ) metaopt = l2l . optim . LearnableOptimizer ( linear , transform , lr = 0.01 ) # metaopt has .step() opt = torch . optim . SGD ( metaopt . parameters (), lr = 0.001 ) # metaopt also has .parameters() metaopt . zero_grad () opt . zero_grad () error = loss ( linear ( X ), y ) error . backward () opt . step () # update metaopt metaopt . step () # update linear Learning Domains \u00b6 Custom Few-Shot Dataset Many standardized datasets (Omniglot, mini-/tiered-ImageNet, FC100, CIFAR-FS) are readily available in `learn2learn.vision.datasets`. ( documentation ) 1 2 3 4 5 6 7 8 9 10 dataset = l2l . data . MetaDataset ( MyDataset ()) # any PyTorch dataset transforms = [ # Easy to define your own transform l2l . data . transforms . NWays ( dataset , n = 5 ), l2l . data . transforms . KShots ( dataset , k = 1 ), l2l . data . transforms . LoadData ( dataset ), ] taskset = TaskDataset ( dataset , transforms , num_tasks = 20000 ) for task in taskset : X , y = task # Meta-train on the task Environments and Utilities for Meta-RL Parallelize your own meta-environments with `AsyncVectorEnv`, or use the standardized ones. ( documentation ) 1 2 3 4 5 6 7 8 9 10 11 def make_env (): env = l2l . gym . HalfCheetahForwardBackwardEnv () env = cherry . envs . ActionSpaceScaler ( env ) return env env = l2l . gym . AsyncVectorEnv ([ make_env for _ in range ( 16 )]) # uses 16 threads for task_config in env . sample_tasks ( 20 ): env . set_task ( task ) # all threads receive the same task state = env . reset () # use standard Gym API action = my_policy ( env ) env . step ( action ) Low-Level Utilities \u00b6 Differentiable Optimization Learn and differentiate through updates of PyTorch Modules. ( documentation ) 1 2 3 4 5 6 7 8 9 10 11 12 13 model = MyModel () transform = l2l . optim . KroneckerTransform ( l2l . nn . KroneckerLinear ) learned_update = l2l . optim . ParameterUpdate ( # learnable update function model . parameters (), transform ) clone = l2l . clone_module ( model ) # torch.clone() for nn.Modules error = loss ( clone ( X ), y ) updates = learned_update ( # similar API as torch.autograd.grad error , clone . parameters (), create_graph = True , ) l2l . update_module ( clone , updates = updates ) loss ( clone ( X ), y ) . backward () # Gradients w.r.t model.parameters() and learned_update.parameters() Changelog \u00b6 A human-readable changelog is available in the CHANGELOG.md file. Citation \u00b6 To cite the learn2learn repository in your academic publications, please use the following reference. Arnold, Sebastien M. R., Praateek Mahajan, Debajyoti Datta, Ian Bunner, and Konstantinos Saitas Zarkias. 2020. \u201clearn2learn: A Library for Meta-Learning Research.\u201d arXiv [cs.LG]. http://arxiv.org/abs/2008.12284. You can also use the following Bibtex entry. 1 2 3 4 5 6 7 8 9 10 11 @article { Arnold2020-ss , title = \"learn2learn: A Library for {Meta-Learning} Research\" , author = \"Arnold, S{\\'e}bastien M R and Mahajan, Praateek and Datta, Debajyoti and Bunner, Ian and Zarkias, Konstantinos Saitas\" , month = aug , year = 2020 , url = \"http://arxiv.org/abs/2008.12284\" , archivePrefix = \"arXiv\" , primaryClass = \"cs.LG\" , eprint = \"2008.12284\" } Acknowledgements & Friends \u00b6 TorchMeta is similar library, with a focus on datasets for supervised meta-learning. higher is a PyTorch library that enables differentiating through optimization inner-loops. While they monkey-patch nn.Module to be stateless, learn2learn retains the stateful PyTorch look-and-feel. For more information, refer to their ArXiv paper . We are thankful to the following open-source implementations which helped guide the design of learn2learn: Tristan Deleu's pytorch-maml-rl Jonas Rothfuss' ProMP Kwonjoon Lee's MetaOptNet Han-Jia Ye's and Hexiang Hu's FEAT","title":"Index"},{"location":"_build/pydocmd/#installation","text":"1 pip install learn2learn","title":"Installation"},{"location":"_build/pydocmd/#snippets-examples","text":"The following snippets provide a sneak peek at the functionalities of learn2learn.","title":"Snippets &amp; Examples"},{"location":"_build/pydocmd/#high-level-wrappers","text":"Few-Shot Learning with MAML For more algorithms (ProtoNets, ANIL, Meta-SGD, Reptile, Meta-Curvature, KFO) refer to the examples folder. Most of them can be implemented with with the `GBML` wrapper. ( documentation ). 1 2 3 4 5 6 7 8 9 10 maml = l2l . algorithms . MAML ( model , lr = 0.1 ) opt = torch . optim . SGD ( maml . parameters (), lr = 0.001 ) for iteration in range ( 10 ): opt . zero_grad () task_model = maml . clone () # torch.clone() for nn.Modules adaptation_loss = compute_loss ( task_model ) task_model . adapt ( adaptation_loss ) # computes gradient, update task_model in-place evaluation_loss = compute_loss ( task_model ) evaluation_loss . backward () # gradients w.r.t. maml.parameters() opt . step () Meta-Descent with Hypergradient Learn any kind of optimization algorithm with the `LearnableOptimizer`. ( example and documentation ) 1 2 3 4 5 6 7 8 9 10 11 linear = nn . Linear ( 784 , 10 ) transform = l2l . optim . ModuleTransform ( l2l . nn . Scale ) metaopt = l2l . optim . LearnableOptimizer ( linear , transform , lr = 0.01 ) # metaopt has .step() opt = torch . optim . SGD ( metaopt . parameters (), lr = 0.001 ) # metaopt also has .parameters() metaopt . zero_grad () opt . zero_grad () error = loss ( linear ( X ), y ) error . backward () opt . step () # update metaopt metaopt . step () # update linear","title":"High-level Wrappers"},{"location":"_build/pydocmd/#learning-domains","text":"Custom Few-Shot Dataset Many standardized datasets (Omniglot, mini-/tiered-ImageNet, FC100, CIFAR-FS) are readily available in `learn2learn.vision.datasets`. ( documentation ) 1 2 3 4 5 6 7 8 9 10 dataset = l2l . data . MetaDataset ( MyDataset ()) # any PyTorch dataset transforms = [ # Easy to define your own transform l2l . data . transforms . NWays ( dataset , n = 5 ), l2l . data . transforms . KShots ( dataset , k = 1 ), l2l . data . transforms . LoadData ( dataset ), ] taskset = TaskDataset ( dataset , transforms , num_tasks = 20000 ) for task in taskset : X , y = task # Meta-train on the task Environments and Utilities for Meta-RL Parallelize your own meta-environments with `AsyncVectorEnv`, or use the standardized ones. ( documentation ) 1 2 3 4 5 6 7 8 9 10 11 def make_env (): env = l2l . gym . HalfCheetahForwardBackwardEnv () env = cherry . envs . ActionSpaceScaler ( env ) return env env = l2l . gym . AsyncVectorEnv ([ make_env for _ in range ( 16 )]) # uses 16 threads for task_config in env . sample_tasks ( 20 ): env . set_task ( task ) # all threads receive the same task state = env . reset () # use standard Gym API action = my_policy ( env ) env . step ( action )","title":"Learning Domains"},{"location":"_build/pydocmd/#low-level-utilities","text":"Differentiable Optimization Learn and differentiate through updates of PyTorch Modules. ( documentation ) 1 2 3 4 5 6 7 8 9 10 11 12 13 model = MyModel () transform = l2l . optim . KroneckerTransform ( l2l . nn . KroneckerLinear ) learned_update = l2l . optim . ParameterUpdate ( # learnable update function model . parameters (), transform ) clone = l2l . clone_module ( model ) # torch.clone() for nn.Modules error = loss ( clone ( X ), y ) updates = learned_update ( # similar API as torch.autograd.grad error , clone . parameters (), create_graph = True , ) l2l . update_module ( clone , updates = updates ) loss ( clone ( X ), y ) . backward () # Gradients w.r.t model.parameters() and learned_update.parameters()","title":"Low-Level Utilities"},{"location":"_build/pydocmd/#changelog","text":"A human-readable changelog is available in the CHANGELOG.md file.","title":"Changelog"},{"location":"_build/pydocmd/#citation","text":"To cite the learn2learn repository in your academic publications, please use the following reference. Arnold, Sebastien M. R., Praateek Mahajan, Debajyoti Datta, Ian Bunner, and Konstantinos Saitas Zarkias. 2020. \u201clearn2learn: A Library for Meta-Learning Research.\u201d arXiv [cs.LG]. http://arxiv.org/abs/2008.12284. You can also use the following Bibtex entry. 1 2 3 4 5 6 7 8 9 10 11 @article { Arnold2020-ss , title = \"learn2learn: A Library for {Meta-Learning} Research\" , author = \"Arnold, S{\\'e}bastien M R and Mahajan, Praateek and Datta, Debajyoti and Bunner, Ian and Zarkias, Konstantinos Saitas\" , month = aug , year = 2020 , url = \"http://arxiv.org/abs/2008.12284\" , archivePrefix = \"arXiv\" , primaryClass = \"cs.LG\" , eprint = \"2008.12284\" }","title":"Citation"},{"location":"_build/pydocmd/#acknowledgements-friends","text":"TorchMeta is similar library, with a focus on datasets for supervised meta-learning. higher is a PyTorch library that enables differentiating through optimization inner-loops. While they monkey-patch nn.Module to be stateless, learn2learn retains the stateful PyTorch look-and-feel. For more information, refer to their ArXiv paper . We are thankful to the following open-source implementations which helped guide the design of learn2learn: Tristan Deleu's pytorch-maml-rl Jonas Rothfuss' ProMP Kwonjoon Lee's MetaOptNet Han-Jia Ye's and Hexiang Hu's FEAT","title":"Acknowledgements &amp; Friends"},{"location":"_build/pydocmd/changelog/","text":"Changelog \u00b6 All notable changes to this project will be documented in this file. The format is based on Keep a Changelog , and this project adheres to Semantic Versioning . [Unreleased] \u00b6 Added \u00b6 Changed \u00b6 Fixed \u00b6 v0.1.6 \u00b6 Added \u00b6 PyTorch Lightning interface to MAML, ANIL, ProtoNet, MetaOptNet. Automatic batcher for Lightning: l2l.data.EpisodicBatcher . l2l.nn.PrototypicalClassifier and l2l.nn.SVMClassifier . Add l2l.vision.models.WRN28 . Separate modules for CNN4Backbone , ResNet12Backbone , WRN28Backbones w/ pretrained weights. Add l2l.data.OnDeviceDataset and implement device parameter for benchmarks. (Beta) Add l2l.data.partition_task and l2l.data.InfiniteIterator . Changed \u00b6 Renamed and clarify dropout parameters for ResNet12 . Fixed \u00b6 Improved support for 1D inputs in l2l.nn.KroneckerLinear . (@timweiland) v0.1.5 \u00b6 Fixed \u00b6 Fix setup.py for windows installs. v0.1.4 \u00b6 Added \u00b6 FilteredMetaDatasest filter the classes used to sample tasks. UnionMetaDatasest to get the union of multiple MetaDatasets. Alias MiniImageNetCNN to CNN4 and add embedding_size argument. Optional data augmentation schemes for vision benchmarks. l2l.vision.models.ResNet12 l2l.vision.datasets.DescribableTextures l2l.vision.datasets.Quickdraw l2l.vision.datasets.FGVCFungi Add labels_to_indices and indices_to_labels as optional arguments to l2l.data.MetaDataset . Changed \u00b6 Updated reference for citations. v0.1.3 \u00b6 Added \u00b6 l2l.vision.datasets.CUBirds200 . Changed \u00b6 Optimization transforms can be accessed directly through l2l.optim , e.g. l2l.optim.KroneckerTransform . All vision models adhere to the .features and .classifier interface. Fixed \u00b6 Fix clone_module for Modules whose submodules share parameters. v0.1.2 \u00b6 Added \u00b6 New example: Meta-World example with MAML-TRPO with it's own env wrapper. (@ Kostis-S-Z ) l2l.vision.benchmarks interface. Differentiable optimization utilities in l2l.optim . (including l2l.optim.LearnableOptimizer for meta-descent) General gradient-based meta-learning wrapper in l2l.algorithms.GBML . Various nn.Modules in l2l.nn . l2l.update_module as a more general alternative to l2l.algorithms.maml_update . Changed \u00b6 Fixed \u00b6 clone_module supports non-Module objects. VGG flowers now relies on tarfile.open() instead of tarfile.TarFile(). v0.1.1 \u00b6 Added \u00b6 New tutorial: 'Feature Reuse with ANIL'. (@ewinapun) Changed \u00b6 Mujoco imports optional for docs: the import error is postponed to first method call. Fixed \u00b6 MAML() and clone_module support for RNN modules. v0.1.0.1 \u00b6 Fixed \u00b6 Remove Cython dependency when installing from PyPI and clean up package distribution. v0.1.0 \u00b6 Added \u00b6 A CHANGELOG.md file. New vision datasets: FC100, tiered-Imagenet, FGVCAircraft, VGGFlowers102. New vision examples: Reptile & ANIL. Extensive benchmarks of all vision examples. Changed \u00b6 Re-wrote TaskDataset and task transforms in Cython, for a 20x speed-up. Travis testing with different versions of Python (3.6, 3.7), torch (1.1, 1.2, 1.3, 1.4), and torchvision (0.3, 0.4, 0.5). New Material doc theme with links to changelog and examples. Fixed \u00b6 Support for RandomClassRotation with newer versions of torchvision. Various minor fixes in the examples. Add Dropbox download if GDrive fails for FC100.","title":"Changelog"},{"location":"_build/pydocmd/changelog/#changelog","text":"All notable changes to this project will be documented in this file. The format is based on Keep a Changelog , and this project adheres to Semantic Versioning .","title":"Changelog"},{"location":"_build/pydocmd/changelog/#unreleased","text":"","title":"[Unreleased]"},{"location":"_build/pydocmd/changelog/#added","text":"","title":"Added"},{"location":"_build/pydocmd/changelog/#changed","text":"","title":"Changed"},{"location":"_build/pydocmd/changelog/#fixed","text":"","title":"Fixed"},{"location":"_build/pydocmd/changelog/#v016","text":"","title":"v0.1.6"},{"location":"_build/pydocmd/changelog/#added_1","text":"PyTorch Lightning interface to MAML, ANIL, ProtoNet, MetaOptNet. Automatic batcher for Lightning: l2l.data.EpisodicBatcher . l2l.nn.PrototypicalClassifier and l2l.nn.SVMClassifier . Add l2l.vision.models.WRN28 . Separate modules for CNN4Backbone , ResNet12Backbone , WRN28Backbones w/ pretrained weights. Add l2l.data.OnDeviceDataset and implement device parameter for benchmarks. (Beta) Add l2l.data.partition_task and l2l.data.InfiniteIterator .","title":"Added"},{"location":"_build/pydocmd/changelog/#changed_1","text":"Renamed and clarify dropout parameters for ResNet12 .","title":"Changed"},{"location":"_build/pydocmd/changelog/#fixed_1","text":"Improved support for 1D inputs in l2l.nn.KroneckerLinear . (@timweiland)","title":"Fixed"},{"location":"_build/pydocmd/changelog/#v015","text":"","title":"v0.1.5"},{"location":"_build/pydocmd/changelog/#fixed_2","text":"Fix setup.py for windows installs.","title":"Fixed"},{"location":"_build/pydocmd/changelog/#v014","text":"","title":"v0.1.4"},{"location":"_build/pydocmd/changelog/#added_2","text":"FilteredMetaDatasest filter the classes used to sample tasks. UnionMetaDatasest to get the union of multiple MetaDatasets. Alias MiniImageNetCNN to CNN4 and add embedding_size argument. Optional data augmentation schemes for vision benchmarks. l2l.vision.models.ResNet12 l2l.vision.datasets.DescribableTextures l2l.vision.datasets.Quickdraw l2l.vision.datasets.FGVCFungi Add labels_to_indices and indices_to_labels as optional arguments to l2l.data.MetaDataset .","title":"Added"},{"location":"_build/pydocmd/changelog/#changed_2","text":"Updated reference for citations.","title":"Changed"},{"location":"_build/pydocmd/changelog/#v013","text":"","title":"v0.1.3"},{"location":"_build/pydocmd/changelog/#added_3","text":"l2l.vision.datasets.CUBirds200 .","title":"Added"},{"location":"_build/pydocmd/changelog/#changed_3","text":"Optimization transforms can be accessed directly through l2l.optim , e.g. l2l.optim.KroneckerTransform . All vision models adhere to the .features and .classifier interface.","title":"Changed"},{"location":"_build/pydocmd/changelog/#fixed_3","text":"Fix clone_module for Modules whose submodules share parameters.","title":"Fixed"},{"location":"_build/pydocmd/changelog/#v012","text":"","title":"v0.1.2"},{"location":"_build/pydocmd/changelog/#added_4","text":"New example: Meta-World example with MAML-TRPO with it's own env wrapper. (@ Kostis-S-Z ) l2l.vision.benchmarks interface. Differentiable optimization utilities in l2l.optim . (including l2l.optim.LearnableOptimizer for meta-descent) General gradient-based meta-learning wrapper in l2l.algorithms.GBML . Various nn.Modules in l2l.nn . l2l.update_module as a more general alternative to l2l.algorithms.maml_update .","title":"Added"},{"location":"_build/pydocmd/changelog/#changed_4","text":"","title":"Changed"},{"location":"_build/pydocmd/changelog/#fixed_4","text":"clone_module supports non-Module objects. VGG flowers now relies on tarfile.open() instead of tarfile.TarFile().","title":"Fixed"},{"location":"_build/pydocmd/changelog/#v011","text":"","title":"v0.1.1"},{"location":"_build/pydocmd/changelog/#added_5","text":"New tutorial: 'Feature Reuse with ANIL'. (@ewinapun)","title":"Added"},{"location":"_build/pydocmd/changelog/#changed_5","text":"Mujoco imports optional for docs: the import error is postponed to first method call.","title":"Changed"},{"location":"_build/pydocmd/changelog/#fixed_5","text":"MAML() and clone_module support for RNN modules.","title":"Fixed"},{"location":"_build/pydocmd/changelog/#v0101","text":"","title":"v0.1.0.1"},{"location":"_build/pydocmd/changelog/#fixed_6","text":"Remove Cython dependency when installing from PyPI and clean up package distribution.","title":"Fixed"},{"location":"_build/pydocmd/changelog/#v010","text":"","title":"v0.1.0"},{"location":"_build/pydocmd/changelog/#added_6","text":"A CHANGELOG.md file. New vision datasets: FC100, tiered-Imagenet, FGVCAircraft, VGGFlowers102. New vision examples: Reptile & ANIL. Extensive benchmarks of all vision examples.","title":"Added"},{"location":"_build/pydocmd/changelog/#changed_6","text":"Re-wrote TaskDataset and task transforms in Cython, for a 20x speed-up. Travis testing with different versions of Python (3.6, 3.7), torch (1.1, 1.2, 1.3, 1.4), and torchvision (0.3, 0.4, 0.5). New Material doc theme with links to changelog and examples.","title":"Changed"},{"location":"_build/pydocmd/changelog/#fixed_7","text":"Support for RandomClassRotation with newer versions of torchvision. Various minor fixes in the examples. Add Dropbox download if GDrive fails for FC100.","title":"Fixed"},{"location":"_build/pydocmd/community/","text":"Community \u00b6 learn2learn is built by a small but active community \u2014 this page acknowledges the institutions enabling those contributors and their work. For individual contributions, please refer to our Changelog . Universities \u00b6 Companies \u00b6 Publications \u00b6 A non-exhaustive list of papers built on top of learn2learn. Ping S\u00e9b to get yours listed, or open an issue . Uniform Sampling over Episode Difficulty [ ArXiv , code ] S.M.R. Arnold*, G. S. Dhillon*, A. Ravichandran, S. Soatto , NeurIPS 2021 Bridging Multi-Task Learning and Meta-Learning: Towards Efficient Training and Effective Adaptation [ ArXiv , code ] H. Wang, H. Zhao, B. Li , ICML 2021 Embedding Adaptation is Still Needed for Few-Shot Learning [ ArXiv ] S.M.R. Arnold, F. Sha , ArXiv 2021 When MAML Can Adapt Fast and How to Assist When It Cannot [ ArXiv , code ] S.M.R. Arnold, S. Iqbal, F. Sha , AISTATS 2021 learn2learn: A Library for Meta-Learning Research [ ArXiv , code ] S.M.R. Arnold, P. Mahajan, D. Datta, I. Bunner, K.S. Zarkias , ArXiv 2020","title":"Community"},{"location":"_build/pydocmd/community/#community","text":"learn2learn is built by a small but active community \u2014 this page acknowledges the institutions enabling those contributors and their work. For individual contributions, please refer to our Changelog .","title":"Community"},{"location":"_build/pydocmd/community/#universities","text":"","title":"Universities"},{"location":"_build/pydocmd/community/#companies","text":"","title":"Companies"},{"location":"_build/pydocmd/community/#publications","text":"A non-exhaustive list of papers built on top of learn2learn. Ping S\u00e9b to get yours listed, or open an issue . Uniform Sampling over Episode Difficulty [ ArXiv , code ] S.M.R. Arnold*, G. S. Dhillon*, A. Ravichandran, S. Soatto , NeurIPS 2021 Bridging Multi-Task Learning and Meta-Learning: Towards Efficient Training and Effective Adaptation [ ArXiv , code ] H. Wang, H. Zhao, B. Li , ICML 2021 Embedding Adaptation is Still Needed for Few-Shot Learning [ ArXiv ] S.M.R. Arnold, F. Sha , ArXiv 2021 When MAML Can Adapt Fast and How to Assist When It Cannot [ ArXiv , code ] S.M.R. Arnold, S. Iqbal, F. Sha , AISTATS 2021 learn2learn: A Library for Meta-Learning Research [ ArXiv , code ] S.M.R. Arnold, P. Mahajan, D. Datta, I. Bunner, K.S. Zarkias , ArXiv 2020","title":"Publications"},{"location":"_build/pydocmd/examples.optim/","text":"Meta-Optimization \u00b6 This directory contains examples of using learn2learn for meta-optimization or meta-descent. Hypergradient \u00b6 The script hypergrad_mnist.py demonstrates how to implement a slightly modified version of \" Online Learning Rate Adaptation with Hypergradient Descent \". The implementation departs from the algorithm presented in the paper in two ways. We forgo the analytical formulation of the learning rate's gradient to demonstrate the capability of the LearnableOptimizer class. We adapt per-parameter learning rates instead of updating a single learning rate shared by all parameters. Usage Warning The parameters for this script were not carefully tuned. Manually edit the script and run: 1 python examples/optimization/hypergrad_mnist.py","title":"Meta-Optimization"},{"location":"_build/pydocmd/examples.optim/#meta-optimization","text":"This directory contains examples of using learn2learn for meta-optimization or meta-descent.","title":"Meta-Optimization"},{"location":"_build/pydocmd/examples.optim/#hypergradient","text":"The script hypergrad_mnist.py demonstrates how to implement a slightly modified version of \" Online Learning Rate Adaptation with Hypergradient Descent \". The implementation departs from the algorithm presented in the paper in two ways. We forgo the analytical formulation of the learning rate's gradient to demonstrate the capability of the LearnableOptimizer class. We adapt per-parameter learning rates instead of updating a single learning rate shared by all parameters. Usage Warning The parameters for this script were not carefully tuned. Manually edit the script and run: 1 python examples/optimization/hypergrad_mnist.py","title":"Hypergradient"},{"location":"_build/pydocmd/examples.rl/","text":"Meta-Reinforcement Learning \u00b6 Warning Meta-RL results are particularly finicky to compare. Different papers use different environment implementations, which in turn produce different convergence and rewards. The plots below only serve to indicate what kind of performance you can expect with learn2learn. MAML \u00b6 The above results are obtained by running maml_trpo.py on HalfCheetahForwardBackwardEnv and AntForwardBackwardEnv for 300 updates. The figures show the expected sum of rewards over all tasks. The line and shadow are the mean and standard deviation computed over 3 random seeds. Info Those results were obtained in August 2019, and might be outdated.","title":"Meta-Reinforcement Learning"},{"location":"_build/pydocmd/examples.rl/#meta-reinforcement-learning","text":"Warning Meta-RL results are particularly finicky to compare. Different papers use different environment implementations, which in turn produce different convergence and rewards. The plots below only serve to indicate what kind of performance you can expect with learn2learn.","title":"Meta-Reinforcement Learning"},{"location":"_build/pydocmd/examples.rl/#maml","text":"The above results are obtained by running maml_trpo.py on HalfCheetahForwardBackwardEnv and AntForwardBackwardEnv for 300 updates. The figures show the expected sum of rewards over all tasks. The line and shadow are the mean and standard deviation computed over 3 random seeds. Info Those results were obtained in August 2019, and might be outdated.","title":"MAML"},{"location":"_build/pydocmd/examples.vision/","text":"Meta-Learning & Computer Vision \u00b6 This directory contains meta-learning examples and reproductions for common computer vision benchmarks. MAML \u00b6 The following files reproduce MAML on the Omniglot and mini -ImageNet datasets. The FOMAML results can be obtained by setting first_order=True in the MAML wrapper. On Omniglot, the CNN results can be obtained by swapping OmniglotFC with OmniglotCNN . maml_omniglot.py - MAML on the Omniglot dataset with a fully-connected network. maml_miniimagenet.py - MAML on the mini -ImageNet dataset with the standard convolutional network. Note that the original MAML paper trains with 5 fast adaptation step, but tests with 10 steps. This implementation only provides the training code. Results When adapting the code to different datasets, we obtained the following results. Only the fast-adaptation learning rate needs a bit of tuning, and good values usually lie in a 0.5-2x range of the original value. Dataset Architecture Ways Shots Original learn2learn Omniglot FC 5 1 89.7% 88.9% Omniglot CNN 5 1 98.7% 99.1% mini-ImageNet CNN 5 1 48.7% 48.3% mini-ImageNet CNN 5 5 63.1% 65.4% CIFAR-FS CNN 5 5 71.5% 73.6% FC100 CNN 5 5 n/a 49.0% Usage Manually edit the respective files and run: 1 python examples/vision/maml_omniglot.py or 1 python examples/vision/maml_miniimagenet.py Prototypical Networks \u00b6 The file protonet_miniimagenet.py reproduces Prototypical Networks on the mini -ImageNet dataset. This implementation provides training and testing code. Results Dataset Architecture Ways Shots Original learn2learn mini-ImageNet CNN 5 1 49.4% 49.1% mini-ImageNet CNN 5 5 68.2% 66.5% Usage For 1 shot 5 ways: 1 python examples/vision/protonet_miniimagenet.py For 5 shot 5 ways: 1 python examples/vision/protonet_miniimagenet.py --shot 5 --train-way 20 ANIL \u00b6 The file anil_fc100.py implements ANIL on the FC100 dataset. Results While ANIL only used mini -ImageNet as a benchmark, we provide results for CIFAR-FS and FC100 as well. Dataset Architecture Ways Shots Original learn2learn mini-ImageNet CNN 5 5 61.5% 63.2% CIFAR-FS CNN 5 5 n/a 68.3% FC100 CNN 5 5 n/a 47.6% Usage Manually edit the above file and run: 1 python examples/vision/anil_fc100.py Reptile \u00b6 The file reptile_miniimagenet.py reproduces Reptile on the mini -ImageNet dataset. Results The mini -ImageNet file can easily be adapted to obtain results on Omniglot and CIFAR-FS as well. Dataset Architecture Ways Shots Original learn2learn Omniglot CNN 5 5 99.5% 99.5% mini-ImageNet CNN 5 5 66.0% 65.5% CIFAR-FS CNN 10 3 n/a 46.3% Usage Manually edit the above file and run: 1 python examples/vision/reptile_miniimagenet.py","title":"Meta-Learning & Computer Vision"},{"location":"_build/pydocmd/examples.vision/#meta-learning-computer-vision","text":"This directory contains meta-learning examples and reproductions for common computer vision benchmarks.","title":"Meta-Learning &amp; Computer Vision"},{"location":"_build/pydocmd/examples.vision/#maml","text":"The following files reproduce MAML on the Omniglot and mini -ImageNet datasets. The FOMAML results can be obtained by setting first_order=True in the MAML wrapper. On Omniglot, the CNN results can be obtained by swapping OmniglotFC with OmniglotCNN . maml_omniglot.py - MAML on the Omniglot dataset with a fully-connected network. maml_miniimagenet.py - MAML on the mini -ImageNet dataset with the standard convolutional network. Note that the original MAML paper trains with 5 fast adaptation step, but tests with 10 steps. This implementation only provides the training code. Results When adapting the code to different datasets, we obtained the following results. Only the fast-adaptation learning rate needs a bit of tuning, and good values usually lie in a 0.5-2x range of the original value. Dataset Architecture Ways Shots Original learn2learn Omniglot FC 5 1 89.7% 88.9% Omniglot CNN 5 1 98.7% 99.1% mini-ImageNet CNN 5 1 48.7% 48.3% mini-ImageNet CNN 5 5 63.1% 65.4% CIFAR-FS CNN 5 5 71.5% 73.6% FC100 CNN 5 5 n/a 49.0% Usage Manually edit the respective files and run: 1 python examples/vision/maml_omniglot.py or 1 python examples/vision/maml_miniimagenet.py","title":"MAML"},{"location":"_build/pydocmd/examples.vision/#prototypical-networks","text":"The file protonet_miniimagenet.py reproduces Prototypical Networks on the mini -ImageNet dataset. This implementation provides training and testing code. Results Dataset Architecture Ways Shots Original learn2learn mini-ImageNet CNN 5 1 49.4% 49.1% mini-ImageNet CNN 5 5 68.2% 66.5% Usage For 1 shot 5 ways: 1 python examples/vision/protonet_miniimagenet.py For 5 shot 5 ways: 1 python examples/vision/protonet_miniimagenet.py --shot 5 --train-way 20","title":"Prototypical Networks"},{"location":"_build/pydocmd/examples.vision/#anil","text":"The file anil_fc100.py implements ANIL on the FC100 dataset. Results While ANIL only used mini -ImageNet as a benchmark, we provide results for CIFAR-FS and FC100 as well. Dataset Architecture Ways Shots Original learn2learn mini-ImageNet CNN 5 5 61.5% 63.2% CIFAR-FS CNN 5 5 n/a 68.3% FC100 CNN 5 5 n/a 47.6% Usage Manually edit the above file and run: 1 python examples/vision/anil_fc100.py","title":"ANIL"},{"location":"_build/pydocmd/examples.vision/#reptile","text":"The file reptile_miniimagenet.py reproduces Reptile on the mini -ImageNet dataset. Results The mini -ImageNet file can easily be adapted to obtain results on Omniglot and CIFAR-FS as well. Dataset Architecture Ways Shots Original learn2learn Omniglot CNN 5 5 99.5% 99.5% mini-ImageNet CNN 5 5 66.0% 65.5% CIFAR-FS CNN 10 3 n/a 46.3% Usage Manually edit the above file and run: 1 python examples/vision/reptile_miniimagenet.py","title":"Reptile"},{"location":"_build/pydocmd/paper_list/","text":"Paper List \u00b6 The following papers were announced on the learn2learn Twitter account . You can submit unannounced and meta-learning related papers through the following Google Form. (It does not matter if they are old or new, but they shouldn't be already announced.) Info Announce any paper via the Google Form to announce papers , also available below. Submitted Papers \u00b6 Grounded Language Learning Fast and Slow by Hill, Felix and Tieleman, Olivier and von Glehn, Tamara and Wong, Nathaniel and Merzic, Hamza and Clark, Stephen http://arxiv.org/abs/2009.01719 Sparse Meta Networks for Sequential Adaptation and its Application to Adaptive Language Modelling by Munkhdalai, Tsendsuren http://arxiv.org/abs/2009.01803 Learning with Differentiable Perturbed Optimizers by Berthet, Quentin and Blondel, Mathieu and Teboul, Olivier and Cuturi, Marco and Vert, Jean-Philippe and Bach, Francis http://arxiv.org/abs/2002.08676 What is being transferred in transfer learning? by Neyshabur, Behnam and Sedghi, Hanie and Zhang, Chiyuan http://arxiv.org/abs/2008.11687 On modulating the gradient for meta-learning by Simon, Christian and Koniusz, Piotr and Nock, Richard and Harandi, Mehrtash https://www.ecva.net/papers/eccv_2020/papers_ECCV/papers/123530545.pdf Meta-Learning with Shared Amortized Variational Inference by Iakovleva, Ekaterina and Verbeek, Jakob and Alahari, Karteek http://arxiv.org/abs/2008.12037 learn2learn: A Library for Meta-Learning Research by Arnold, S\u00e9bastien M R and Mahajan, Praateek and Datta, Debajyoti and Bunner, Ian and Zarkias, Konstantinos Saitas http://arxiv.org/abs/2008.12284 A Universal Representation Transformer Layer for Few-Shot Image Classification by Liu, Lu and Hamilton, William and Long, Guodong and Jiang, Jing and Larochelle, Hugo http://arxiv.org/abs/2006.11702 Safe Model-Based Meta-Reinforcement Learning: A Sequential Exploration-Exploitation Framework by Lew, Thomas and Sharma, Apoorva and Harrison, James and Pavone, Marco http://arxiv.org/abs/2008.11700 Learning to Learn in a Semi-Supervised Fashion by Chen, Yun-Chun and Chou, Chao-Te and Wang, Yu-Chiang Frank http://arxiv.org/abs/2008.11203 The Advantage of Conditional Meta-Learning for Biased Regularization and Fine-Tuning by Denevi, Giulia and Pontil, Massimiliano and Ciliberto, Carlo http://arxiv.org/abs/2008.10857 Adaptive Multi-level Hyper-gradient Descent by Jie, Renlong and Gao, Junbin and Vasnev, Andrey and Tran, Minh-Ngoc http://arxiv.org/abs/2008.07277 Few-Shot Image Classification via Contrastive Self-Supervised Learning by Li, Jianyi and Liu, Guizhong http://arxiv.org/abs/2008.09942 Does MAML really want feature reuse only? by Oh, Jaehoon and Yoo, Hyungjun and Kim, Changhwan and Yun, Se-Young http://arxiv.org/abs/2008.08882 Meta Learning MPC using Finite-Dimensional Gaussian Process Approximations by Arcari, Elena and Carron, Andrea and Zeilinger, Melanie N http://arxiv.org/abs/2008.05984 Offline Meta-Reinforcement Learning with Advantage Weighting by Mitchell, Eric and Rafailov, Rafael and Peng, Xue Bin and Levine, Sergey and Finn, Chelsea http://arxiv.org/abs/2008.06043 Explore then Execute: Adapting without Rewards via Factorized Meta-Reinforcement Learning by Liu, Evan Zheran and Raghunathan, Aditi and Liang, Percy and Finn, Chelsea http://arxiv.org/abs/2008.02790 Offline Meta Reinforcement Learning by Dorfman, Ron and Tamar, Aviv http://arxiv.org/abs/2008.02598 Few-Shot Learning via Learning the Representation, Provably by Du, Simon S and Hu, Wei and Kakade, Sham M and Lee, Jason D and Lei, Qi http://arxiv.org/abs/2002.09434 Multi-Task Reinforcement Learning as a Hidden-Parameter Block MDP by Zhang, Amy and Sodhani, Shagun and Khetarpal, Khimya and Pineau, Joelle http://arxiv.org/abs/2007.07206 CAMPs: Learning Context-Specific Abstractions for Efficient Planning in Factored MDPs by Chitnis, Rohan and Silver, Tom and Kim, Beomjoon and Kaelbling, Leslie Pack and Lozano-Perez, Tomas http://arxiv.org/abs/2007.13202 Unsupervised Learning of Visual Features by Contrasting Cluster Assignments by Caron, Mathilde and Misra, Ishan and Mairal, Julien and Goyal, Priya and Bojanowski, Piotr and Joulin, Armand http://arxiv.org/abs/2006.09882 MiCo: Mixup Co-Training for Semi-Supervised Domain Adaptation by Yang, Luyu and Wang, Yan and Gao, Mingfei and Shrivastava, Abhinav and Weinberger, Kilian Q and Chao, Wei-Lun and Lim, Ser-Nam http://arxiv.org/abs/2007.12684 Adaptive Task Sampling for Meta-Learning by Liu, Chenghao and Wang, Zhihao and Sahoo, Doyen and Fang, Yuan and Zhang, Kun and Hoi, Steven C H http://arxiv.org/abs/2007.08735 Discovering Reinforcement Learning Algorithms by Oh, Junhyuk and Hessel, Matteo and Czarnecki, Wojciech M and Xu, Zhongwen and van Hasselt, Hado and Singh, Satinder and Silver, David http://arxiv.org/abs/2007.08794 On the Outsized Importance of Learning Rates in Local Update Methods by Charles, Zachary and Kone{\\v c}n{\\'y}, Jakub http://arxiv.org/abs/2007.00878 Global Convergence and Induced Kernels of Gradient-Based Meta-Learning with Neural Nets by Wang, Haoxiang and Sun, Ruoyu and Li, Bo http://arxiv.org/abs/2006.14606 On the Iteration Complexity of Hypergradient Computation by Grazzi, Riccardo and Franceschi, Luca and Pontil, Massimiliano and Salzo, Saverio http://arxiv.org/abs/2006.16218 On the Outsized Importance of Learning Rates in Local Update Methods by Charles, Zachary and Kone{\\v c}n{\\'y}, Jakub http://arxiv.org/abs/2007.00878 Meta-SAC: Auto-tune the Entropy Temperature of Soft Actor-Critic via Metagradient by Wang, Yufei and Ni, Tianwei http://arxiv.org/abs/2007.01932 Meta Learning in the Continuous Time Limit by Xu, Ruitu and Chen, Lin and Karbasi, Amin http://arxiv.org/abs/2006.10921 Expert Training: Task Hardness Aware Meta-Learning for Few-Shot Classification by Zhou, Yucan and Wang, Yu and Cai, Jianfei and Zhou, Yu and Hu, Qinghua and Wang, Weiping http://arxiv.org/abs/2007.06240 MTL2L: A Context Aware Neural Optimiser by Kuo, Nicholas I-Hsien and Harandi, Mehrtash and Fourrier, Nicolas and Walder, Christian and Ferraro, Gabriela and Suominen, Hanna http://arxiv.org/abs/2007.09343 Navigating the Trade-Off between Multi-Task Learning and Learning to Multitask in Deep Neural Networks by Ravi, Sachin and Musslick, Sebastian and Hamin, Maia and Willke, Theodore L and Cohen, Jonathan D http://arxiv.org/abs/2007.10527 Balanced Meta-Softmax for Long-Tailed Visual Recognition by Ren, Jiawei and Yu, Cunjun and Sheng, Shunan and Ma, Xiao and Zhao, Haiyu and Yi, Shuai and Li, Hongsheng http://arxiv.org/abs/2007.10740 CrossTransformers: spatially-aware few-shot transfer by Doersch, Carl and Gupta, Ankush and Zisserman, Andrew http://arxiv.org/abs/2007.11498 Meta-Learning a Dynamical Language Model by Wolf, Thomas and Chaumond, Julien and Delangue, Clement http://arxiv.org/abs/1803.10631 Meta-Learning Requires Meta-Augmentation by Rajendran, Janarthanan and Irpan, Alex and Jang, Eric http://arxiv.org/abs/2007.05549 Adaptive Risk Minimization: A Meta-Learning Approach for Tackling Group Shift by Zhang, Marvin and Marklund, Henrik and Gupta, Abhishek and Levine, Sergey and Finn, Chelsea http://arxiv.org/abs/2007.02931 Meta-Learning Symmetries by Reparameterization by Zhou, Allan and Knowles, Tom and Finn, Chelsea http://arxiv.org/abs/2007.02933 Adaptive Risk Minimization: A Meta-Learning Approach for Tackling Group Shift by Zhang, Marvin and Marklund, Henrik and Gupta, Abhishek and Levine, Sergey and Finn, Chelsea http://arxiv.org/abs/2007.02931 A Brief Look at Generalization in Visual Meta-Reinforcement Learning by Alver, Safa and Precup, Doina http://arxiv.org/abs/2006.07262 Learning Representations by Stochastic Meta-Gradient Descent in Neural Networks by Veeriah, Vivek and Zhang, Shangtong and Sutton, Richard S http://arxiv.org/abs/1612.02879 PACOH: Bayes-Optimal Meta-Learning with PAC-Guarantees by Rothfuss, Jonas and Fortuin, Vincent and Krause, Andreas http://arxiv.org/abs/2002.05551 Meta-Meta-Classification for One-Shot Learning by Chowdhury, Arkabandhu and Chaudhari, Dipak and Chaudhuri, Swarat and Jermaine, Chris http://arxiv.org/abs/2004.08083 Relatedness Measures to Aid the Transfer of Building Blocks among Multiple Tasks by Nguyen, Trung B and Browne, Will N and Zhang, Mengjie http://arxiv.org/abs/2005.03947 Information-Theoretic Generalization Bounds for Meta-Learning and Applications by Jose, Sharu Theresa and Simeone, Osvaldo http://arxiv.org/abs/2005.04372 On Learning Intrinsic Rewards for Policy Gradient Methods by Zheng, Zeyu and Oh, Junhyuk and Singh, Satinder http://arxiv.org/abs/1804.06459 A Sample Complexity Separation between Non-Convex and Convex Meta-Learning by Saunshi, Nikunj and Zhang, Yi and Khodak, Mikhail and Arora, Sanjeev http://arxiv.org/abs/2002.11172 Bayesian Online Meta-Learning with Laplace Approximation by Yap, Pau Ching and Ritter, Hippolyt and Barber, David http://arxiv.org/abs/2005.00146 Meta-Reinforcement Learning for Robotic Industrial Insertion Tasks by Schoettler, Gerrit and Nair, Ashvin and Ojea, Juan Aparicio and Levine, Sergey and Solowjow, Eugen http://arxiv.org/abs/2004.14404 Continual Deep Learning by Functional Regularisation of Memorable Past by Pan, Pingbo and Swaroop, Siddharth and Immer, Alexander and Eschenhagen, Runa and Turner, Richard E and Khan, Mohammad Emtiyaz http://arxiv.org/abs/2004.14070 Jelly Bean World: A Testbed for Never-Ending Learning by Platanios, Emmanouil Antonios and Saparov, Abulhair and Mitchell, Tom https://openreview.net/pdf?id=Byx_YAVYPH Encouraging behavioral diversity in evolutionary robotics: an empirical study by Mouret, J-B and Doncieux, S http://dx.doi.org/10.1162/EVCO_a_00048 Defining Benchmarks for Continual Few-Shot Learning by Antoniou, Antreas and Patacchiola, Massimiliano and Ochal, Mateusz and Storkey, Amos http://arxiv.org/abs/2004.11967 Emergent Real-World Robotic Skills via Unsupervised Off-Policy Reinforcement Learning by Sharma, Archit and Ahn, Michael and Levine, Sergey and Kumar, Vikash and Hausman, Karol and Gu, Shixiang http://arxiv.org/abs/2004.12974 Empirical Bayes Transductive Meta-Learning with Synthetic Gradients by Hu, Shell Xu and Moreno, Pablo G and Xiao, Yang and Shen, Xi and Obozinski, Guillaume and Lawrence, Neil D and Damianou, Andreas http://arxiv.org/abs/2004.12696 Evolving Inborn Knowledge For Fast Adaptation in Dynamic POMDP Problems by Ben-Iwhiwhu, Eseoghene and Ladosz, Pawel and Dick, Jeffery and Chen, Wen-Hua and Pilly, Praveen and Soltoggio, Andrea http://arxiv.org/abs/2004.12846 Meta-World: A Benchmark and Evaluation for Multi-Task and Meta Reinforcement Learning by Yu, Tianhe and Quillen, Deirdre and He, Zhanpeng and Julian, Ryan and Hausman, Karol and Finn, Chelsea and Levine, Sergey http://arxiv.org/abs/1910.10897 Meta reinforcement learning as task inference by Humplik, Jan and Galashov, Alexandre and Hasenclever, Leonard and Ortega, Pedro A and Teh, Yee Whye and Heess, Nicolas http://arxiv.org/abs/1905.06424 Meta-Gradient Reinforcement Learning by Xu, Zhongwen and van Hasselt, Hado and Silver, David http://arxiv.org/abs/1805.09801 Self-Paced Deep Reinforcement Learning by Klink, Pascal and D'Eramo, Carlo and Peters, Jan and Pajarinen, Joni http://arxiv.org/abs/2004.11812 Scheduling the Learning Rate Via Hypergradients: New Insights and a New Algorithm by Donini, Michele and Franceschi, Luca and Majumder, Orchid and Pontil, Massimiliano and Frasconi, Paolo https://openreview.net/pdf?id=Ske6qJSKPH Learning Stabilizable Nonlinear Dynamics with Contraction-Based Regularization by Singh, Sumeet and Richards, Spencer M and Sindhwani, Vikas and Slotine, Jean-Jacques E and Pavone, Marco http://arxiv.org/abs/1907.13122 A Comprehensive Overview and Survey of Recent Advances in Meta-Learning by Peng, Huimin http://arxiv.org/abs/2004.11149 Learning a Formula of Interpretability to Learn Interpretable Formulas by Virgolin, Marco and De Lorenzo, Andrea and Medvet, Eric and Randone, Francesca http://arxiv.org/abs/2004.11170 Model-Based Meta-Reinforcement Learning for Flight with Suspended Payloads by Belkhale, Suneel and Li, Rachel and Kahn, Gregory and McAllister, Rowan and Calandra, Roberto and Levine, Sergey http://arxiv.org/abs/2004.11345 Frustratingly Simple Few-Shot Object Detection by Wang, Xin and Huang, Thomas E and Darrell, Trevor and Gonzalez, Joseph E and Yu, Fisher http://arxiv.org/abs/2003.06957 Meta Pseudo Labels by Pham, Hieu and Xie, Qizhe and Dai, Zihang and Le, Quoc V http://arxiv.org/abs/2003.10580 0e56da12-a2f0-4288-b745-c15deec9183a by Unknown http://learn2learn.net Finding online neural update rules by learning to remember by Gregor, Karol http://arxiv.org/abs/2003.03124 A New Meta-Baseline for Few-Shot Learning by Chen, Yinbo and Wang, Xiaolong and Liu, Zhuang and Xu, Huijuan and Darrell, Trevor http://arxiv.org/abs/2003.04390 Learning to be Global Optimizer by Zhang, Haotian and Sun, Jianyong and Xu, Zongben http://arxiv.org/abs/2003.04521 Scalable Multi-Task Imitation Learning with Autonomous Improvement by Singh, Avi and Jang, Eric and Irpan, Alexander and Kappler, Daniel and Dalal, Murtaza and Levine, Sergey and Khansari, Mohi and Finn, Chelsea http://arxiv.org/abs/2003.02636 Meta-learning for mixed linear regression by Kong, Weihao and Somani, Raghav and Song, Zhao and Kakade, Sham and Oh, Sewoong http://arxiv.org/abs/2002.08936 Provable Meta-Learning of Linear Representations by Tripuraneni, Nilesh and Jin, Chi and Jordan, Michael I http://arxiv.org/abs/2002.11684 Learning to Continually Learn by Beaulieu, Shawn and Frati, Lapo and Miconi, Thomas and Lehman, Joel and Stanley, Kenneth O and Clune, Jeff and Cheney, Nick http://arxiv.org/abs/2002.09571 PACOH: Bayes-Optimal Meta-Learning with PAC-Guarantees by Rothfuss, Jonas and Fortuin, Vincent and Krause, Andreas http://arxiv.org/abs/2002.05551 Incremental Learning for Metric-Based Meta-Learners by Liu, Qing and Majumder, Orchid and Ravichandran, Avinash and Bhotika, Rahul and Soatto, Stefano http://arxiv.org/abs/2002.04162 Hyper-Meta Reinforcement Learning with Sparse Reward by Hua, Yun and Wang, Xiangfeng and Jin, Bo and Li, Wenhao and Yan, Junchi and He, Xiaofeng and Zha, Hongyuan http://arxiv.org/abs/2002.04238 Meta-Learning across Meta-Tasks for Few-Shot Learning by Fei, Nanyi and Lu, Zhiwu and Gao, Yizhao and Tian, Jia and Xiang, Tao and Wen, Ji-Rong http://arxiv.org/abs/2002.04274 Distribution-Agnostic Model-Agnostic Meta-Learning by Collins, Liam and Mokhtari, Aryan and Shakkottai, Sanjay http://arxiv.org/abs/2002.04766 Provably Convergent Policy Gradient Methods for Model-Agnostic Meta-Reinforcement Learning by Fallah, Alireza and Mokhtari, Aryan and Ozdaglar, Asuman http://arxiv.org/abs/2002.05135 Meta-learning framework with applications to zero-shot time-series forecasting by Oreshkin, Boris N and Carpov, Dmitri and Chapados, Nicolas and Bengio, Yoshua http://arxiv.org/abs/2002.02887 A Loss-Function for Causal Machine-Learning by Yang, I-Sheng http://arxiv.org/abs/2001.00629 Self-Tuning Deep Reinforcement Learning by Zahavy, Tom and Xu, Zhongwen and Veeriah, Vivek and Hessel, Matteo and Van Hasslet, Hado and Silver, David and Singh, Satinder http://arxiv.org/abs/2002.12928 Learning Adaptive Loss for Robust Learning with Noisy Labels by Shu, Jun and Zhao, Qian and Chen, Keyu and Xu, Zongben and Meng, Deyu http://arxiv.org/abs/2002.06482 A Structured Prediction Approach for Conditional Meta-Learning by Wang, Ruohan and Demiris, Yiannis and Ciliberto, Carlo http://arxiv.org/abs/2002.08799 Curriculum in Gradient-Based Meta-Reinforcement Learning by Mehta, Bhairav and Deleu, Tristan and Raparthy, Sharath Chandra and Pal, Chris J and Paull, Liam http://arxiv.org/abs/2002.07956 Multi-Step Model-Agnostic Meta-Learning: Convergence and Improved Algorithms by Ji, Kaiyi and Yang, Junjie and Liang, Yingbin http://arxiv.org/abs/2002.07836 Local Nonparametric Meta-Learning by Goo, Wonjoon and Niekum, Scott http://arxiv.org/abs/2002.03272 Revisiting Meta-Learning as Supervised Learning by Chao, Wei-Lun and Ye, Han-Jia and Zhan, De-Chuan and Campbell, Mark and Weinberger, Kilian Q http://arxiv.org/abs/2002.00573 SimpleShot: Revisiting Nearest-Neighbor Classification for Few-Shot Learning by Wang, Yan and Chao, Wei-Lun and Weinberger, Kilian Q and van der Maaten, Laurens http://arxiv.org/abs/1911.04623 Fast and Generalized Adaptation for Few-Shot Learning by Song, Liang and Liu, Jinlu and Qin, Yongqiang http://arxiv.org/abs/1911.10807 Meta-Learning without Memorization by Yin, Mingzhang and Tucker, George and Zhou, Mingyuan and Levine, Sergey and Finn, Chelsea http://arxiv.org/abs/1912.03820 Your Classifier is Secretly an Energy Based Model and You Should Treat it Like One by Grathwohl, Will and Wang, Kuan-Chieh and Jacobsen, J{\\\"o}rn-Henrik and Duvenaud, David and Norouzi, Mohammad and Swersky, Kevin http://arxiv.org/abs/1912.03263 MAME : Model-Agnostic Meta-Exploration by Gurumurthy, Swaminathan and Kumar, Sumit and Sycara, Katia http://arxiv.org/abs/1911.04024 Constructing Multiple Tasks for Augmentation: Improving Neural Image Classification With K-means Features by Gui, Tao and Qing, Lizhi and Zhang, Qi and Ye, Jiacheng and Yan, Hang and Fei, Zichu and Huang, Xuanjing http://arxiv.org/abs/1911.07518 Meta Adaptation using Importance Weighted Demonstrations by Lekkala, Kiran and Abu-El-Haija, Sami and Itti, Laurent http://arxiv.org/abs/1911.10322 VIABLE: Fast Adaptation via Backpropagating Learned Loss by Feng, Leo and Zintgraf, Luisa and Peng, Bei and Whiteson, Shimon http://arxiv.org/abs/1911.13159 Decoupling Adaptation from Modeling with Meta-Optimizers for Meta Learning by Arnold, S{\\'e}bastien M R and Iqbal, Shariq and Sha, Fei http://arxiv.org/abs/1910.13603 TADAM: Task dependent adaptive metric for improved few-shot learning by Oreshkin, Boris and Rodr{\\'\\i}guez L{\\'o}pez, Pau and Lacoste, Alexandre http://papers.nips.cc/paper/7352-tadam-task-dependent-adaptive-metric-for-improved-few-shot-learning.pdf Learning to Few-Shot Learn Across Diverse Natural Language Classification Tasks by Bansal, Trapit and Jha, Rishikesh and McCallum, Andrew http://arxiv.org/abs/1911.03863 Optimizing Millions of Hyperparameters by Implicit Differentiation by Lorraine, Jonathan and Vicol, Paul and Duvenaud, David http://arxiv.org/abs/1911.02590 Meta-data: Characterization of Input Features for Meta-learning by Castiello, Ciro and Castellano, Giovanna and Fanelli, Anna Maria http://dx.doi.org/10.1007/11526018_45 Meta-Learning for Low-resource Natural Language Generation in Task-oriented Dialogue Systems by Mi, Fei and Huang, Minlie and Zhang, Jiyong and Faltings, Boi http://arxiv.org/abs/1905.05644 Domain Generalization via Model-Agnostic Learning of Semantic Features by Dou, Qi and Castro, Daniel C and Kamnitsas, Konstantinos and Glocker, Ben http://arxiv.org/abs/1910.13580 Hierarchical Expert Networks for Meta-Learning by Hihn, Heinke and Braun, Daniel A http://arxiv.org/abs/1911.00348 Online Meta-Learning on Non-convex Setting by Zhuang, Zhenxun and Wang, Yunlong and Yu, Kezi and Lu, Songtao http://arxiv.org/abs/1910.10196 Learning-to-Learn Stochastic Gradient Descent with Biased Regularization by Denevi, Giulia and Ciliberto, Carlo and Grazzi, Riccardo and Pontil, Massimiliano http://arxiv.org/abs/1903.10399 Provable Guarantees for Gradient-Based Meta-Learning by Khodak, Mikhail and Balcan, Maria-Florina and Talwalkar, Ameet http://arxiv.org/abs/1902.10644 The TCGA Meta-Dataset Clinical Benchmark by Samiei, Mandana and W{\\\"u}rfl, Tobias and Deleu, Tristan and Weiss, Martin and Dutil, Francis and Fevens, Thomas and Boucher, Genevi{`e}ve and Lemieux, Sebastien and Cohen, Joseph Paul http://arxiv.org/abs/1910.08636 VariBAD: A Very Good Method for Bayes-Adaptive Deep RL via Meta-Learning by Zintgraf, Luisa and Shiarlis, Kyriacos and Igl, Maximilian and Schulze, Sebastian and Gal, Yarin and Hofmann, Katja and Whiteson, Shimon http://arxiv.org/abs/1910.08348 Meta-Transfer Learning through Hard Tasks by Sun, Qianru and Liu, Yaoyao and Chen, Zhaozheng and Chua, Tat-Seng and Schiele, Bernt http://arxiv.org/abs/1910.03648 Model-Agnostic Meta-Learning using Runge-Kutta Methods by Im, Daniel Jiwoong and Jiang, Yibo and Verma, Nakul http://arxiv.org/abs/1910.07368 Improving Generalization in Meta Reinforcement Learning using Learned Objectives by Kirsch, Louis and van Steenkiste, Sjoerd and Schmidhuber, J{\\\"u}rgen http://arxiv.org/abs/1910.04098 Generalized Inner Loop Meta-Learning by Grefenstette, Edward and Amos, Brandon and Yarats, Denis and Htut, Phu Mon and Molchanov, Artem and Meier, Franziska and Kiela, Douwe and Cho, Kyunghyun and Chintala, Soumith http://arxiv.org/abs/1910.01727 Is Fast Adaptation All You Need? by Javed, Khurram and Yao, Hengshuai and White, Martha http://arxiv.org/abs/1910.01705 Deep Reinforcement Learning for Single-Shot Diagnosis and Adaptation in Damaged Robots by Verma, Shresth and Nair, Haritha S and Agarwal, Gaurav and Dhar, Joydip and Shukla, Anupam http://arxiv.org/abs/1910.01240 ES-MAML: Simple Hessian-Free Meta Learning by Song, Xingyou and Gao, Wenbo and Yang, Yuxiang and Choromanski, Krzysztof and Pacchiano, Aldo and Tang, Yunhao http://arxiv.org/abs/1910.01215 Meta-Q-Learning by Fakoor, Rasool and Chaudhari, Pratik and Soatto, Stefano and Smola, Alexander J http://arxiv.org/abs/1910.00125 Efficient meta reinforcement learning via meta goal generation by Fu, Haotian and Tang, Hongyao and Hao, Jianye http://arxiv.org/abs/1909.13607 Chameleon: Learning Model Initializations Across Tasks With Different Schemas by Brinkmeyer, Lukas and Drumond, Rafael Rego and Scholz, Randolf and Grabocka, Josif and Schmidt-Thieme, Lars http://arxiv.org/abs/1909.13576 Learning Fast Adaptation with Meta Strategy Optimization by Yu, Wenhao and Tan, Jie and Bai, Yunfei and Coumans, Erwin and Ha, Sehoon http://arxiv.org/abs/1909.12995 Meta-Inverse Reinforcement Learning with Probabilistic Context Variables by Yu, Lantao and Yu, Tianhe and Finn, Chelsea and Ermon, Stefano http://arxiv.org/abs/1909.09314 Modular Meta-Learning with Shrinkage by Chen, Yutian and Friesen, Abram L and Behbahani, Feryal and Budden, David and Hoffman, Matthew W and Doucet, Arnaud and de Freitas, Nando http://arxiv.org/abs/1909.05557 Loaded DiCE: Trading off Bias and Variance in Any-Order Score Function Estimators for Reinforcement Learning by Farquhar, Gregory and Whiteson, Shimon and Foerster, Jakob http://arxiv.org/abs/1909.10549 Rapid Learning or Feature Reuse? Towards Understanding the Effectiveness of MAML by Raghu, Aniruddh and Raghu, Maithra and Bengio, Samy and Vinyals, Oriol http://arxiv.org/abs/1909.09157 Meta-Learning by Vanschoren, Joaquin https://doi.org/10.1007/978-3-030-05318-5_2 Understanding Short-Horizon Bias in Stochastic Meta-Optimization by Wu, Yuhuai and Ren, Mengye and Liao, Renjie and Grosse, Roger http://arxiv.org/abs/1803.02021 On First-Order Meta-Learning Algorithms by Nichol, Alex and Achiam, Joshua and Schulman, John http://arxiv.org/abs/1803.02999 Towards Understanding Generalization in Gradient-Based Meta-Learning by Guiroy, Simon and Verma, Vikas and Pal, Christopher http://arxiv.org/abs/1907.07287 They empirically study the landscape of fast-adaptation in MAML. The most interesting claim is that when meta-overfitting, the loss landscape becomes flatter on test tasks. On the Convergence Theory of Gradient-Based Model-Agnostic Meta-Learning Algorithms by Fallah, Alireza and Mokhtari, Aryan and Ozdaglar, Asuman http://arxiv.org/abs/1908.10400 Learning to Learn with Gradients by Finn, Chelsea http://learn2learn.net Acetylcholine and memory by Hasselmo, M E and Bower, J M https://www.ncbi.nlm.nih.gov/pubmed/7688162 A THEORY OF META-LEARNING AND PRINCIPLES OF FACILITATION: AN ORGANISMIC PERSPECTIVE by Maudsley, Donald B https://uosc.primo.exlibrisgroup.com/discovery/fulldisplay?docid=proquest302999651&context=PC&vid=01USC_INST:01USC&lang=en&search_scope=MyInst_and_CI&adaptor=Primo%20Central&tab=Everything&mode=Basic THE ROLE OF METALEARNING IN STUDY PROCESSES by Biggs, J B http://doi.wiley.com/10.1111/j.2044-8279.1985.tb02625.x Understanding and correcting pathologies in the training of learned optimizers by Metz, Luke and Maheswaranathan, Niru and Nixon, Jeremy and Daniel Freeman, C and Sohl-Dickstein, Jascha http://arxiv.org/abs/1810.10180 Provides many tricks (e.g. split train batch for model \\& opt, average gradient estimators) for training differentiable optimizers online. They also have a couple of interesting observations specific to recurrent optimizers. Learned Optimizers that Scale and Generalize by Wichrowska, Olga and Maheswaranathan, Niru and Hoffman, Matthew W and Colmenarejo, Sergio Gomez and Denil, Misha and de Freitas, Nando and Sohl-Dickstein, Jascha http://arxiv.org/abs/1703.04813 Using learned optimizers to make models robust to input noise by Metz, Luke and Maheswaranathan, Niru and Shlens, Jonathon and Sohl-Dickstein, Jascha and Cubuk, Ekin D http://arxiv.org/abs/1906.03367 Learning to Optimize Neural Nets by Li, Ke and Malik, Jitendra http://arxiv.org/abs/1703.00441 Meta-Learning Update Rules for Unsupervised Representation Learning by Metz, Luke and Maheswaranathan, Niru and Cheung, Brian and Sohl-Dickstein, Jascha http://arxiv.org/abs/1804.00222 Learning to Optimize by Li, Ke and Malik, Jitendra http://arxiv.org/abs/1606.01885 Learning to learn by gradient descent by gradient descent by Andrychowicz, M and Denil, M and Gomez, S http://learn2learn.net Online Learning Rate Adaptation with Hypergradient Descent by Baydin, Atilim Gunes and Cornish, Robert and Rubio, David Martinez and Schmidt, Mark and Wood, Frank http://arxiv.org/abs/1703.04782 They adapt the learning rate of SGD by differentiating the loss of the next parameters w.r.t. the learning rate. They observe that the gradient of the learning rate is simply the inner product of the last two gradients. Adapting Bias by Gradient Descent: An Incremental Version of Delta-Bar-Delta by Sutton, Richard S http://dx.doi.org/ What's mostly interesting in this paper is the adaptation of delta-bar-delta to the online scenario. The idea of representing the learning rate as an exponential is nice. Also nice to see that the derivation suggests a full-matrix adaptive case. Gain adaptation beats least squares by Sutton, Richard S https://pdfs.semanticscholar.org/7ec8/876f219b3b3d5c894a3f395c89c382029cc5.pdf This paper extends IDBD as algorithms K1 and K2, but from my quick read, it isn't clear what's the motivation for those modifications. (Seems to work in a `normalized space'', {\\ a} la natural gradient ?)They do work better. Local Gain Adaptation in Stochastic Gradient Descent by Schraudolph, Nicol N https://pdfs.semanticscholar.org/31a0/b86c3cd04e6539626f34b80db7ff79d23f40.pdf This algorithm extends IDBD (Sutton) to the non-linear setting. Interestingly, they have a few brief discussionson the difficulties to optimize at the meta-level. (c.f. Meta-level conditioning section.) Overall, it shines light on the ground idea behind IDBD. TIDBD: Adapting Temporal-difference Step-sizes Through Stochastic Meta-descent by Kearney, Alex and Veeriah, Vivek and Travnik, Jaden B and Sutton, Richard S and Pilarski, Patrick M http://arxiv.org/abs/1804.03334 Increased rates of convergence through learning rate adaptation by Jacobs, Robert A http://www.sciencedirect.com/science/article/pii/0893608088900032 This paper argues that we need (at least) four ingredients to improve optimization of connectionist networks: 1. each parameter has its own stepsize, 2. stepsizes vary over time, 3. if consecutive gradients of a stepsize have the same sign, the stepsize should be increased, 4. conversely, if the stepsize should be decreased if its gradients have opposite signs. It also proposes to use two improvements: 1. Momentum (i.e. Polyak's heavyball), 2. delta-bar-delta (i.e. learning the stepsize). It has an interesting comment on the difficulty of learning the stepsize, and therefore comes up with a ``hack'' that outperforms momentum. Meta-descent for Online, Continual Prediction by Jacobsen, Andrew and Schlegel, Matthew and Linke, Cameron and Degris, Thomas and White, Adam and White, Martha http://arxiv.org/abs/1907.07751 The idea is to learn the learning rate so as to minimize the norm of the gradient. They argue that for the continual learning setting, this forces the algorithm to stay ``as stable as possible''. No theorems, small-scale (but interesting) experiments. Adaptation of learning rate parameters by Sutton, Rich http://learn2learn.net Gradient-Based Meta-Learning with Learned Layerwise Metric and Subspace by Lee, Yoonho and Choi, Seungjin http://arxiv.org/abs/1801.05558 Meta-Learning with Warped Gradient Descent by Flennerhag, Sebastian and Rusu, Andrei A and Pascanu, Razvan and Yin, Hujun and Hadsell, Raia http://arxiv.org/abs/1909.00025 Meta-Learning via Learned Loss by Chebotar, Yevgen and Molchanov, Artem and Bechtle, Sarah and Righetti, Ludovic and Meier, Franziska and Sukhatme, Gaurav http://arxiv.org/abs/1906.05374 They learn the loss as a NN, and that loss's objective is to maximize the sum of rewards. It is provided a bunch of things, including inputs, outputs, goals. Meta-Curvature by Park, Eunbyung and Oliva, Junier B http://arxiv.org/abs/1902.03356 Alpha MAML: Adaptive Model-Agnostic Meta-Learning by Behl, Harkirat Singh and Baydin, At{\\i}l{\\i}m G{\\\"u}ne{\\c s} and Torr, Philip H S http://arxiv.org/abs/1905.07435 They combine hypergradient and MAML: adapt all learning rates at all times. Meta-SGD: Learning to Learn Quickly for Few-Shot Learning by Li, Zhenguo and Zhou, Fengwei and Chen, Fei and Li, Hang http://arxiv.org/abs/1707.09835 ProMP: Proximal Meta-Policy Search by Rothfuss, Jonas and Lee, Dennis and Clavera, Ignasi and Asfour, Tamim and Abbeel, Pieter http://arxiv.org/abs/1810.06784 Model-Agnostic Meta-Learning for Fast Adaptation of Deep Networks by Finn, Chelsea and Abbeel, Pieter and Levine, Sergey http://learn2learn.net Optimization as a model for few-shot learning by Ravi, Sachin and Larochelle, Hugo https://openreview.net/pdf?id=rJY0-Kcll Fast Context Adaptation via Meta-Learning by Zintgraf, Luisa M and Shiarlis, Kyriacos and Kurin, Vitaly and Hofmann, Katja and Whiteson, Shimon http://arxiv.org/abs/1810.03642 Meta-Learning with Implicit Gradients by Rajeswaran, Aravind and Finn, Chelsea and Kakade, Sham and Levine, Sergey http://arxiv.org/abs/1909.04630 Natural Neural Networks by Desjardins, Guillaume and Simonyan, Karen and Pascanu, Razvan and Kavukcuoglu, Koray http://dl.acm.org/citation.cfm?id=2969442.2969471 A Baseline for Few-Shot Image Classification by Dhillon, Guneet S and Chaudhari, Pratik and Ravichandran, Avinash and Soatto, Stefano http://arxiv.org/abs/1909.02729 A CLOSER LOOK AT FEW-SHOT CLASSIFICATION by Chen, Wei-Yu and Liu, Yen-Cheng and Kira, Zsolt https://openreview.net/pdf?id=HkxLXnAcFQ Suggests that meta-learning papers haven't been tested against classical baselines. When considering those baselines, they perform better than many of the recent meta-learning techniques. Meta-learning with differentiable closed-form solvers by Bertinetto, Luca and Henriques, Joao F and Torr, Philip and Vedaldi, Andrea https://openreview.net/forum?id=HyxnZh0ct7 Uncertainty in Model-Agnostic Meta-Learning using Variational Inference by Nguyen, Cuong and Do, Thanh-Toan and Carneiro, Gustavo http://arxiv.org/abs/1907.11864 Meta-Reinforcement Learning of Structured Exploration Strategies by Gupta, Abhishek and Mendonca, Russell and Liu, Yuxuan and Abbeel, Pieter and Levine, Sergey http://arxiv.org/abs/1802.07245 Metalearned Neural Memory by Munkhdalai, Tsendsuren and Sordoni, Alessandro and Wang, Tong and Trischler, Adam http://arxiv.org/abs/1907.09720 Accelerated Stochastic Approximation by Kesten, Harry https://projecteuclid.org/euclid.aoms/1177706705 Meta-Learning for Black-box Optimization by Vishnu, T V and Malhotra, Pankaj and Narwariya, Jyoti and Vig, Lovekesh and Shroff, Gautam http://arxiv.org/abs/1907.06901 They essentially extend the recurrent meta-learning framework in a few ways: 1. Use regret instead of objective improvement as meta-learning objective. 2. Normalize the objective so as to make it play nice with LSTMs. 3. Incorporate domain-constraints, so that the LSTM always outputs feasible solutions. All are described in page 3. Task Agnostic Continual Learning via Meta Learning by He, Xu and Sygnowski, Jakub and Galashov, Alexandre and Rusu, Andrei A and Teh, Yee Whye and Pascanu, Razvan http://arxiv.org/abs/1906.05201 Watch, Try, Learn: Meta-Learning from Demonstrations and Reward by Zhou, Allan and Jang, Eric and Kappler, Daniel and Herzog, Alex and Khansari, Mohi and Wohlhart, Paul and Bai, Yunfei and Kalakrishnan, Mrinal and Levine, Sergey and Finn, Chelsea http://arxiv.org/abs/1906.03352 Meta-Learning Representations for Continual Learning by Javed, Khurram and White, Martha http://arxiv.org/abs/1905.12588 TapNet: Neural Network Augmented with Task-Adaptive Projection for Few-Shot Learning by Yoon, Sung Whan and Seo, Jun and Moon, Jaekyun http://arxiv.org/abs/1905.06549 Meta Reinforcement Learning with Task Embedding and Shared Policy by Lan, Lin and Li, Zhenguo and Guan, Xiaohong and Wang, Pinghui http://arxiv.org/abs/1905.06527 Hierarchically Structured Meta-learning by Yao, Huaxiu and Wei, Ying and Huang, Junzhou and Li, Zhenhui http://arxiv.org/abs/1905.05301 Curious Meta-Controller: Adaptive Alternation between Model-Based and Model-Free Control in Deep Reinforcement Learning by Hafez, Muhammad Burhan and Weber, Cornelius and Kerzel, Matthias and Wermter, Stefan http://arxiv.org/abs/1905.01718 Learning to Learn in Simulation by Teng, Ervin and Iannucci, Bob http://arxiv.org/abs/1902.01569 Meta-Learning with Differentiable Convex Optimization by Lee, Kwonjoon and Maji, Subhransu and Ravichandran, Avinash and Soatto, Stefano http://arxiv.org/abs/1904.03758 Functional Regularisation for Continual Learning by Titsias, Michalis K and Schwarz, Jonathan and de G. Matthews, Alexander G and Pascanu, Razvan and Teh, Yee Whye http://arxiv.org/abs/1901.11356 Learning to Forget for Meta-Learning by Baik, Sungyong and Hong, Seokil and Lee, Kyoung Mu http://arxiv.org/abs/1906.05895 Meta-learning of Sequential Strategies by Ortega, Pedro A and Wang, Jane X and Rowland, Mark and Genewein, Tim and Kurth-Nelson, Zeb and Pascanu, Razvan and Heess, Nicolas and Veness, Joel and Pritzel, Alex and Sprechmann, Pablo and Jayakumar, Siddhant M and McGrath, Tom and Miller, Kevin and Azar, Mohammad and Osband, Ian and Rabinowitz, Neil and Gy{\\\"o}rgy, Andr{\\'a}s and Chiappa, Silvia and Osindero, Simon and Teh, Yee Whye and van Hasselt, Hado and de Freitas, Nando and Botvinick, Matthew and Legg, Shane http://arxiv.org/abs/1905.03030 This paper essentially provides a theoretical framework to ground the fact that recurrent meta-learning (RL^2, LLGD^2) performs Bayesian inference during adaptation. Auto-Meta: Automated Gradient Based Meta Learner Search by Kim, Jaehong and Lee, Sangyeul and Kim, Sungwan and Cha, Moonsu and Lee, Jung Kwon and Choi, Youngduck and Choi, Yongseok and Cho, Dong-Yeon and Kim, Jiwon http://arxiv.org/abs/1806.06927 Adaptive Gradient-Based Meta-Learning Methods by Khodak, Mikhail and Florina-Balcan, Maria and Talwalkar, Ameet http://arxiv.org/abs/1906.02717 Embedded Meta-Learning: Toward more flexible deep-learning models by Lampinen, Andrew K and McClelland, James L http://arxiv.org/abs/1905.09950 Modular meta-learning by Alet, Ferran and Lozano-P{\\'e}rez, Tom{\\'a}s and Kaelbling, Leslie P http://arxiv.org/abs/1806.10166 MetaPred: Meta-Learning for Clinical Risk Prediction with Limited Patient Electronic Health Records by Zhang, Xi Sheryl and Tang, Fengyi and Dodge, Hiroko and Zhou, Jiayu and Wang, Fei http://arxiv.org/abs/1905.03218 Prototypical Networks for Few-shot Learning by Snell, Jake and Swersky, Kevin and Zemel, Richard S http://arxiv.org/abs/1703.05175 Meta-learners' learning dynamics are unlike learners' by Rabinowitz, Neil C http://arxiv.org/abs/1905.01320 Backpropamine: training self-modifying neural networks with differentiable neuromodulated plasticity by Miconi, Thomas and Rawal, Aditya and Clune, Jeff and Stanley, Kenneth O https://openreview.net/forum?id=r1lrAiA5Ym Reinforcement Learning, Fast and Slow by Botvinick, Matthew and Ritter, Sam and Wang, Jane X and Kurth-Nelson, Zeb and Blundell, Charles and Hassabis, Demis http://dx.doi.org/10.1016/j.tics.2019.02.006 Been There, Done That: Meta-Learning with Episodic Recall by Ritter, Samuel and Wang, Jane X and Kurth-Nelson, Zeb and Jayakumar, Siddhant M and Blundell, Charles and Pascanu, Razvan and Botvinick, Matthew http://arxiv.org/abs/1805.09692 Guided Meta-Policy Search by Mendonca, Russell and Gupta, Abhishek and Kralev, Rosen and Abbeel, Pieter and Levine, Sergey and Finn, Chelsea http://arxiv.org/abs/1904.00956 Hierarchical Meta Learning by Zou, Yingtian and Feng, Jiashi http://arxiv.org/abs/1904.09081 A Meta-Transfer Objective for Learning to Disentangle Causal Mechanisms by Bengio, Yoshua and Deleu, Tristan and Rahaman, Nasim and Ke, Rosemary and Lachapelle, S{\\'e}bastien and Bilaniuk, Olexa and Goyal, Anirudh and Pal, Christopher http://arxiv.org/abs/1901.10912 Generalize Across Tasks: Efficient Algorithms for Linear Representation Learning by Bullins, Brian and Hazan, Elad and Kalai, Adam and Livni, Roi http://proceedings.mlr.press/v98/bullins19a.html Incremental Learning-to-Learn with Statistical Guarantees by Denevi, Giulia and Ciliberto, Carlo and Stamos, Dimitris and Pontil, Massimiliano http://arxiv.org/abs/1803.08089 A Model of Inductive Bias Learning by Baxter, J http://arxiv.org/abs/1106.0245 Efficient Off-Policy Meta-Reinforcement Learning via Probabilistic Context Variables by Rakelly, Kate and Zhou, Aurick and Quillen, Deirdre and Finn, Chelsea and Levine, Sergey http://arxiv.org/abs/1903.08254 Continual Learning with Tiny Episodic Memories by Chaudhry, Arslan and Rohrbach, Marcus and Elhoseiny, Mohamed and Ajanthan, Thalaiyasingam and Dokania, Puneet K and Torr, Philip H S and Ranzato, Marc'aurelio http://arxiv.org/abs/1902.10486 Online Meta-Learning by Finn, Chelsea and Rajeswaran, Aravind and Kakade, Sham and Levine, Sergey http://arxiv.org/abs/1902.08438 Modulating transfer between tasks in gradient-based meta-learning by Grant, Erin and Jerfel, Ghassen and Heller, Katherine and Griffiths, Thomas L https://openreview.net/pdf?id=HyxpNnRcFX Learning to Adapt in Dynamic, Real-World Environments Through Meta-Reinforcement Learning by Nagabandi, Anusha and Clavera, Ignasi and Liu, Simin and Fearing, Ronald S and Abbeel, Pieter and Levine, Sergey and Finn, Chelsea http://arxiv.org/abs/1803.11347 Meta-Learning with Latent Embedding Optimization by Rusu, Andrei A and Rao, Dushyant and Sygnowski, Jakub and Vinyals, Oriol and Pascanu, Razvan and Osindero, Simon and Hadsell, Raia http://arxiv.org/abs/1807.05960 Learning to Generalize: Meta-Learning for Domain Generalization by Li, Da and Yang, Yongxin and Song, Yi-Zhe and Hospedales, Timothy M http://arxiv.org/abs/1710.03463 Some Considerations on Learning to Explore via Meta-Reinforcement Learning by Stadie, Bradly C and Yang, Ge and Houthooft, Rein and Chen, Xi and Duan, Yan and Wu, Yuhuai and Abbeel, Pieter and Sutskever, Ilya http://arxiv.org/abs/1803.01118 How to train your MAML by Antoniou, Antreas and Edwards, Harrison and Storkey, Amos http://arxiv.org/abs/1810.09502 Bayesian Model-Agnostic Meta-Learning by Kim, Taesup and Yoon, Jaesik and Dia, Ousmane and Kim, Sungwoong and Bengio, Yoshua and Ahn, Sungjin http://arxiv.org/abs/1806.03836 Probabilistic Model-Agnostic Meta-Learning by Finn, Chelsea and Xu, Kelvin and Levine, Sergey http://arxiv.org/abs/1806.02817 The effects of negative adaptation in Model-Agnostic Meta-Learning by Deleu, Tristan and Bengio, Yoshua http://arxiv.org/abs/1812.02159 Memory-based Parameter Adaptation by Sprechmann, Pablo and Jayakumar, Siddhant M and Rae, Jack W and Pritzel, Alexander and Badia, Adri{`a} Puigdom{`e}nech and Uria, Benigno and Vinyals, Oriol and Hassabis, Demis and Pascanu, Razvan and Blundell, Charles http://arxiv.org/abs/1802.10542 Deep Meta-Learning: Learning to Learn in the Concept Space by Zhou, Fengwei and Wu, Bin and Li, Zhenguo http://arxiv.org/abs/1802.03596 Deep Prior by Lacoste, Alexandre and Boquet, Thomas and Rostamzadeh, Negar and Oreshkin, Boris and Chung, Wonchang and Krueger, David http://arxiv.org/abs/1712.05016 Recasting Gradient-Based Meta-Learning as Hierarchical Bayes by Grant, Erin and Finn, Chelsea and Levine, Sergey and Darrell, Trevor and Griffiths, Thomas http://arxiv.org/abs/1801.08930 WNGrad: Learn the Learning Rate in Gradient Descent by Wu, Xiaoxia and Ward, Rachel and Bottou, L{\\'e}on http://arxiv.org/abs/1803.02865 Learning to Learn by Finn, Chelsea http://bair.berkeley.edu/blog/2017/07/18/learning-to-learn/ Continuous Adaptation via Meta-Learning in Nonstationary and Competitive Environments by Al-Shedivat, Maruan and Bansal, Trapit and Burda, Yuri and Sutskever, Ilya and Mordatch, Igor and Abbeel, Pieter http://arxiv.org/abs/1710.03641 Submission Form \u00b6 Loading\u2026","title":"Paper List"},{"location":"_build/pydocmd/paper_list/#paper-list","text":"The following papers were announced on the learn2learn Twitter account . You can submit unannounced and meta-learning related papers through the following Google Form. (It does not matter if they are old or new, but they shouldn't be already announced.) Info Announce any paper via the Google Form to announce papers , also available below.","title":"Paper List"},{"location":"_build/pydocmd/paper_list/#submitted-papers","text":"Grounded Language Learning Fast and Slow by Hill, Felix and Tieleman, Olivier and von Glehn, Tamara and Wong, Nathaniel and Merzic, Hamza and Clark, Stephen http://arxiv.org/abs/2009.01719 Sparse Meta Networks for Sequential Adaptation and its Application to Adaptive Language Modelling by Munkhdalai, Tsendsuren http://arxiv.org/abs/2009.01803 Learning with Differentiable Perturbed Optimizers by Berthet, Quentin and Blondel, Mathieu and Teboul, Olivier and Cuturi, Marco and Vert, Jean-Philippe and Bach, Francis http://arxiv.org/abs/2002.08676 What is being transferred in transfer learning? by Neyshabur, Behnam and Sedghi, Hanie and Zhang, Chiyuan http://arxiv.org/abs/2008.11687 On modulating the gradient for meta-learning by Simon, Christian and Koniusz, Piotr and Nock, Richard and Harandi, Mehrtash https://www.ecva.net/papers/eccv_2020/papers_ECCV/papers/123530545.pdf Meta-Learning with Shared Amortized Variational Inference by Iakovleva, Ekaterina and Verbeek, Jakob and Alahari, Karteek http://arxiv.org/abs/2008.12037 learn2learn: A Library for Meta-Learning Research by Arnold, S\u00e9bastien M R and Mahajan, Praateek and Datta, Debajyoti and Bunner, Ian and Zarkias, Konstantinos Saitas http://arxiv.org/abs/2008.12284 A Universal Representation Transformer Layer for Few-Shot Image Classification by Liu, Lu and Hamilton, William and Long, Guodong and Jiang, Jing and Larochelle, Hugo http://arxiv.org/abs/2006.11702 Safe Model-Based Meta-Reinforcement Learning: A Sequential Exploration-Exploitation Framework by Lew, Thomas and Sharma, Apoorva and Harrison, James and Pavone, Marco http://arxiv.org/abs/2008.11700 Learning to Learn in a Semi-Supervised Fashion by Chen, Yun-Chun and Chou, Chao-Te and Wang, Yu-Chiang Frank http://arxiv.org/abs/2008.11203 The Advantage of Conditional Meta-Learning for Biased Regularization and Fine-Tuning by Denevi, Giulia and Pontil, Massimiliano and Ciliberto, Carlo http://arxiv.org/abs/2008.10857 Adaptive Multi-level Hyper-gradient Descent by Jie, Renlong and Gao, Junbin and Vasnev, Andrey and Tran, Minh-Ngoc http://arxiv.org/abs/2008.07277 Few-Shot Image Classification via Contrastive Self-Supervised Learning by Li, Jianyi and Liu, Guizhong http://arxiv.org/abs/2008.09942 Does MAML really want feature reuse only? by Oh, Jaehoon and Yoo, Hyungjun and Kim, Changhwan and Yun, Se-Young http://arxiv.org/abs/2008.08882 Meta Learning MPC using Finite-Dimensional Gaussian Process Approximations by Arcari, Elena and Carron, Andrea and Zeilinger, Melanie N http://arxiv.org/abs/2008.05984 Offline Meta-Reinforcement Learning with Advantage Weighting by Mitchell, Eric and Rafailov, Rafael and Peng, Xue Bin and Levine, Sergey and Finn, Chelsea http://arxiv.org/abs/2008.06043 Explore then Execute: Adapting without Rewards via Factorized Meta-Reinforcement Learning by Liu, Evan Zheran and Raghunathan, Aditi and Liang, Percy and Finn, Chelsea http://arxiv.org/abs/2008.02790 Offline Meta Reinforcement Learning by Dorfman, Ron and Tamar, Aviv http://arxiv.org/abs/2008.02598 Few-Shot Learning via Learning the Representation, Provably by Du, Simon S and Hu, Wei and Kakade, Sham M and Lee, Jason D and Lei, Qi http://arxiv.org/abs/2002.09434 Multi-Task Reinforcement Learning as a Hidden-Parameter Block MDP by Zhang, Amy and Sodhani, Shagun and Khetarpal, Khimya and Pineau, Joelle http://arxiv.org/abs/2007.07206 CAMPs: Learning Context-Specific Abstractions for Efficient Planning in Factored MDPs by Chitnis, Rohan and Silver, Tom and Kim, Beomjoon and Kaelbling, Leslie Pack and Lozano-Perez, Tomas http://arxiv.org/abs/2007.13202 Unsupervised Learning of Visual Features by Contrasting Cluster Assignments by Caron, Mathilde and Misra, Ishan and Mairal, Julien and Goyal, Priya and Bojanowski, Piotr and Joulin, Armand http://arxiv.org/abs/2006.09882 MiCo: Mixup Co-Training for Semi-Supervised Domain Adaptation by Yang, Luyu and Wang, Yan and Gao, Mingfei and Shrivastava, Abhinav and Weinberger, Kilian Q and Chao, Wei-Lun and Lim, Ser-Nam http://arxiv.org/abs/2007.12684 Adaptive Task Sampling for Meta-Learning by Liu, Chenghao and Wang, Zhihao and Sahoo, Doyen and Fang, Yuan and Zhang, Kun and Hoi, Steven C H http://arxiv.org/abs/2007.08735 Discovering Reinforcement Learning Algorithms by Oh, Junhyuk and Hessel, Matteo and Czarnecki, Wojciech M and Xu, Zhongwen and van Hasselt, Hado and Singh, Satinder and Silver, David http://arxiv.org/abs/2007.08794 On the Outsized Importance of Learning Rates in Local Update Methods by Charles, Zachary and Kone{\\v c}n{\\'y}, Jakub http://arxiv.org/abs/2007.00878 Global Convergence and Induced Kernels of Gradient-Based Meta-Learning with Neural Nets by Wang, Haoxiang and Sun, Ruoyu and Li, Bo http://arxiv.org/abs/2006.14606 On the Iteration Complexity of Hypergradient Computation by Grazzi, Riccardo and Franceschi, Luca and Pontil, Massimiliano and Salzo, Saverio http://arxiv.org/abs/2006.16218 On the Outsized Importance of Learning Rates in Local Update Methods by Charles, Zachary and Kone{\\v c}n{\\'y}, Jakub http://arxiv.org/abs/2007.00878 Meta-SAC: Auto-tune the Entropy Temperature of Soft Actor-Critic via Metagradient by Wang, Yufei and Ni, Tianwei http://arxiv.org/abs/2007.01932 Meta Learning in the Continuous Time Limit by Xu, Ruitu and Chen, Lin and Karbasi, Amin http://arxiv.org/abs/2006.10921 Expert Training: Task Hardness Aware Meta-Learning for Few-Shot Classification by Zhou, Yucan and Wang, Yu and Cai, Jianfei and Zhou, Yu and Hu, Qinghua and Wang, Weiping http://arxiv.org/abs/2007.06240 MTL2L: A Context Aware Neural Optimiser by Kuo, Nicholas I-Hsien and Harandi, Mehrtash and Fourrier, Nicolas and Walder, Christian and Ferraro, Gabriela and Suominen, Hanna http://arxiv.org/abs/2007.09343 Navigating the Trade-Off between Multi-Task Learning and Learning to Multitask in Deep Neural Networks by Ravi, Sachin and Musslick, Sebastian and Hamin, Maia and Willke, Theodore L and Cohen, Jonathan D http://arxiv.org/abs/2007.10527 Balanced Meta-Softmax for Long-Tailed Visual Recognition by Ren, Jiawei and Yu, Cunjun and Sheng, Shunan and Ma, Xiao and Zhao, Haiyu and Yi, Shuai and Li, Hongsheng http://arxiv.org/abs/2007.10740 CrossTransformers: spatially-aware few-shot transfer by Doersch, Carl and Gupta, Ankush and Zisserman, Andrew http://arxiv.org/abs/2007.11498 Meta-Learning a Dynamical Language Model by Wolf, Thomas and Chaumond, Julien and Delangue, Clement http://arxiv.org/abs/1803.10631 Meta-Learning Requires Meta-Augmentation by Rajendran, Janarthanan and Irpan, Alex and Jang, Eric http://arxiv.org/abs/2007.05549 Adaptive Risk Minimization: A Meta-Learning Approach for Tackling Group Shift by Zhang, Marvin and Marklund, Henrik and Gupta, Abhishek and Levine, Sergey and Finn, Chelsea http://arxiv.org/abs/2007.02931 Meta-Learning Symmetries by Reparameterization by Zhou, Allan and Knowles, Tom and Finn, Chelsea http://arxiv.org/abs/2007.02933 Adaptive Risk Minimization: A Meta-Learning Approach for Tackling Group Shift by Zhang, Marvin and Marklund, Henrik and Gupta, Abhishek and Levine, Sergey and Finn, Chelsea http://arxiv.org/abs/2007.02931 A Brief Look at Generalization in Visual Meta-Reinforcement Learning by Alver, Safa and Precup, Doina http://arxiv.org/abs/2006.07262 Learning Representations by Stochastic Meta-Gradient Descent in Neural Networks by Veeriah, Vivek and Zhang, Shangtong and Sutton, Richard S http://arxiv.org/abs/1612.02879 PACOH: Bayes-Optimal Meta-Learning with PAC-Guarantees by Rothfuss, Jonas and Fortuin, Vincent and Krause, Andreas http://arxiv.org/abs/2002.05551 Meta-Meta-Classification for One-Shot Learning by Chowdhury, Arkabandhu and Chaudhari, Dipak and Chaudhuri, Swarat and Jermaine, Chris http://arxiv.org/abs/2004.08083 Relatedness Measures to Aid the Transfer of Building Blocks among Multiple Tasks by Nguyen, Trung B and Browne, Will N and Zhang, Mengjie http://arxiv.org/abs/2005.03947 Information-Theoretic Generalization Bounds for Meta-Learning and Applications by Jose, Sharu Theresa and Simeone, Osvaldo http://arxiv.org/abs/2005.04372 On Learning Intrinsic Rewards for Policy Gradient Methods by Zheng, Zeyu and Oh, Junhyuk and Singh, Satinder http://arxiv.org/abs/1804.06459 A Sample Complexity Separation between Non-Convex and Convex Meta-Learning by Saunshi, Nikunj and Zhang, Yi and Khodak, Mikhail and Arora, Sanjeev http://arxiv.org/abs/2002.11172 Bayesian Online Meta-Learning with Laplace Approximation by Yap, Pau Ching and Ritter, Hippolyt and Barber, David http://arxiv.org/abs/2005.00146 Meta-Reinforcement Learning for Robotic Industrial Insertion Tasks by Schoettler, Gerrit and Nair, Ashvin and Ojea, Juan Aparicio and Levine, Sergey and Solowjow, Eugen http://arxiv.org/abs/2004.14404 Continual Deep Learning by Functional Regularisation of Memorable Past by Pan, Pingbo and Swaroop, Siddharth and Immer, Alexander and Eschenhagen, Runa and Turner, Richard E and Khan, Mohammad Emtiyaz http://arxiv.org/abs/2004.14070 Jelly Bean World: A Testbed for Never-Ending Learning by Platanios, Emmanouil Antonios and Saparov, Abulhair and Mitchell, Tom https://openreview.net/pdf?id=Byx_YAVYPH Encouraging behavioral diversity in evolutionary robotics: an empirical study by Mouret, J-B and Doncieux, S http://dx.doi.org/10.1162/EVCO_a_00048 Defining Benchmarks for Continual Few-Shot Learning by Antoniou, Antreas and Patacchiola, Massimiliano and Ochal, Mateusz and Storkey, Amos http://arxiv.org/abs/2004.11967 Emergent Real-World Robotic Skills via Unsupervised Off-Policy Reinforcement Learning by Sharma, Archit and Ahn, Michael and Levine, Sergey and Kumar, Vikash and Hausman, Karol and Gu, Shixiang http://arxiv.org/abs/2004.12974 Empirical Bayes Transductive Meta-Learning with Synthetic Gradients by Hu, Shell Xu and Moreno, Pablo G and Xiao, Yang and Shen, Xi and Obozinski, Guillaume and Lawrence, Neil D and Damianou, Andreas http://arxiv.org/abs/2004.12696 Evolving Inborn Knowledge For Fast Adaptation in Dynamic POMDP Problems by Ben-Iwhiwhu, Eseoghene and Ladosz, Pawel and Dick, Jeffery and Chen, Wen-Hua and Pilly, Praveen and Soltoggio, Andrea http://arxiv.org/abs/2004.12846 Meta-World: A Benchmark and Evaluation for Multi-Task and Meta Reinforcement Learning by Yu, Tianhe and Quillen, Deirdre and He, Zhanpeng and Julian, Ryan and Hausman, Karol and Finn, Chelsea and Levine, Sergey http://arxiv.org/abs/1910.10897 Meta reinforcement learning as task inference by Humplik, Jan and Galashov, Alexandre and Hasenclever, Leonard and Ortega, Pedro A and Teh, Yee Whye and Heess, Nicolas http://arxiv.org/abs/1905.06424 Meta-Gradient Reinforcement Learning by Xu, Zhongwen and van Hasselt, Hado and Silver, David http://arxiv.org/abs/1805.09801 Self-Paced Deep Reinforcement Learning by Klink, Pascal and D'Eramo, Carlo and Peters, Jan and Pajarinen, Joni http://arxiv.org/abs/2004.11812 Scheduling the Learning Rate Via Hypergradients: New Insights and a New Algorithm by Donini, Michele and Franceschi, Luca and Majumder, Orchid and Pontil, Massimiliano and Frasconi, Paolo https://openreview.net/pdf?id=Ske6qJSKPH Learning Stabilizable Nonlinear Dynamics with Contraction-Based Regularization by Singh, Sumeet and Richards, Spencer M and Sindhwani, Vikas and Slotine, Jean-Jacques E and Pavone, Marco http://arxiv.org/abs/1907.13122 A Comprehensive Overview and Survey of Recent Advances in Meta-Learning by Peng, Huimin http://arxiv.org/abs/2004.11149 Learning a Formula of Interpretability to Learn Interpretable Formulas by Virgolin, Marco and De Lorenzo, Andrea and Medvet, Eric and Randone, Francesca http://arxiv.org/abs/2004.11170 Model-Based Meta-Reinforcement Learning for Flight with Suspended Payloads by Belkhale, Suneel and Li, Rachel and Kahn, Gregory and McAllister, Rowan and Calandra, Roberto and Levine, Sergey http://arxiv.org/abs/2004.11345 Frustratingly Simple Few-Shot Object Detection by Wang, Xin and Huang, Thomas E and Darrell, Trevor and Gonzalez, Joseph E and Yu, Fisher http://arxiv.org/abs/2003.06957 Meta Pseudo Labels by Pham, Hieu and Xie, Qizhe and Dai, Zihang and Le, Quoc V http://arxiv.org/abs/2003.10580 0e56da12-a2f0-4288-b745-c15deec9183a by Unknown http://learn2learn.net Finding online neural update rules by learning to remember by Gregor, Karol http://arxiv.org/abs/2003.03124 A New Meta-Baseline for Few-Shot Learning by Chen, Yinbo and Wang, Xiaolong and Liu, Zhuang and Xu, Huijuan and Darrell, Trevor http://arxiv.org/abs/2003.04390 Learning to be Global Optimizer by Zhang, Haotian and Sun, Jianyong and Xu, Zongben http://arxiv.org/abs/2003.04521 Scalable Multi-Task Imitation Learning with Autonomous Improvement by Singh, Avi and Jang, Eric and Irpan, Alexander and Kappler, Daniel and Dalal, Murtaza and Levine, Sergey and Khansari, Mohi and Finn, Chelsea http://arxiv.org/abs/2003.02636 Meta-learning for mixed linear regression by Kong, Weihao and Somani, Raghav and Song, Zhao and Kakade, Sham and Oh, Sewoong http://arxiv.org/abs/2002.08936 Provable Meta-Learning of Linear Representations by Tripuraneni, Nilesh and Jin, Chi and Jordan, Michael I http://arxiv.org/abs/2002.11684 Learning to Continually Learn by Beaulieu, Shawn and Frati, Lapo and Miconi, Thomas and Lehman, Joel and Stanley, Kenneth O and Clune, Jeff and Cheney, Nick http://arxiv.org/abs/2002.09571 PACOH: Bayes-Optimal Meta-Learning with PAC-Guarantees by Rothfuss, Jonas and Fortuin, Vincent and Krause, Andreas http://arxiv.org/abs/2002.05551 Incremental Learning for Metric-Based Meta-Learners by Liu, Qing and Majumder, Orchid and Ravichandran, Avinash and Bhotika, Rahul and Soatto, Stefano http://arxiv.org/abs/2002.04162 Hyper-Meta Reinforcement Learning with Sparse Reward by Hua, Yun and Wang, Xiangfeng and Jin, Bo and Li, Wenhao and Yan, Junchi and He, Xiaofeng and Zha, Hongyuan http://arxiv.org/abs/2002.04238 Meta-Learning across Meta-Tasks for Few-Shot Learning by Fei, Nanyi and Lu, Zhiwu and Gao, Yizhao and Tian, Jia and Xiang, Tao and Wen, Ji-Rong http://arxiv.org/abs/2002.04274 Distribution-Agnostic Model-Agnostic Meta-Learning by Collins, Liam and Mokhtari, Aryan and Shakkottai, Sanjay http://arxiv.org/abs/2002.04766 Provably Convergent Policy Gradient Methods for Model-Agnostic Meta-Reinforcement Learning by Fallah, Alireza and Mokhtari, Aryan and Ozdaglar, Asuman http://arxiv.org/abs/2002.05135 Meta-learning framework with applications to zero-shot time-series forecasting by Oreshkin, Boris N and Carpov, Dmitri and Chapados, Nicolas and Bengio, Yoshua http://arxiv.org/abs/2002.02887 A Loss-Function for Causal Machine-Learning by Yang, I-Sheng http://arxiv.org/abs/2001.00629 Self-Tuning Deep Reinforcement Learning by Zahavy, Tom and Xu, Zhongwen and Veeriah, Vivek and Hessel, Matteo and Van Hasslet, Hado and Silver, David and Singh, Satinder http://arxiv.org/abs/2002.12928 Learning Adaptive Loss for Robust Learning with Noisy Labels by Shu, Jun and Zhao, Qian and Chen, Keyu and Xu, Zongben and Meng, Deyu http://arxiv.org/abs/2002.06482 A Structured Prediction Approach for Conditional Meta-Learning by Wang, Ruohan and Demiris, Yiannis and Ciliberto, Carlo http://arxiv.org/abs/2002.08799 Curriculum in Gradient-Based Meta-Reinforcement Learning by Mehta, Bhairav and Deleu, Tristan and Raparthy, Sharath Chandra and Pal, Chris J and Paull, Liam http://arxiv.org/abs/2002.07956 Multi-Step Model-Agnostic Meta-Learning: Convergence and Improved Algorithms by Ji, Kaiyi and Yang, Junjie and Liang, Yingbin http://arxiv.org/abs/2002.07836 Local Nonparametric Meta-Learning by Goo, Wonjoon and Niekum, Scott http://arxiv.org/abs/2002.03272 Revisiting Meta-Learning as Supervised Learning by Chao, Wei-Lun and Ye, Han-Jia and Zhan, De-Chuan and Campbell, Mark and Weinberger, Kilian Q http://arxiv.org/abs/2002.00573 SimpleShot: Revisiting Nearest-Neighbor Classification for Few-Shot Learning by Wang, Yan and Chao, Wei-Lun and Weinberger, Kilian Q and van der Maaten, Laurens http://arxiv.org/abs/1911.04623 Fast and Generalized Adaptation for Few-Shot Learning by Song, Liang and Liu, Jinlu and Qin, Yongqiang http://arxiv.org/abs/1911.10807 Meta-Learning without Memorization by Yin, Mingzhang and Tucker, George and Zhou, Mingyuan and Levine, Sergey and Finn, Chelsea http://arxiv.org/abs/1912.03820 Your Classifier is Secretly an Energy Based Model and You Should Treat it Like One by Grathwohl, Will and Wang, Kuan-Chieh and Jacobsen, J{\\\"o}rn-Henrik and Duvenaud, David and Norouzi, Mohammad and Swersky, Kevin http://arxiv.org/abs/1912.03263 MAME : Model-Agnostic Meta-Exploration by Gurumurthy, Swaminathan and Kumar, Sumit and Sycara, Katia http://arxiv.org/abs/1911.04024 Constructing Multiple Tasks for Augmentation: Improving Neural Image Classification With K-means Features by Gui, Tao and Qing, Lizhi and Zhang, Qi and Ye, Jiacheng and Yan, Hang and Fei, Zichu and Huang, Xuanjing http://arxiv.org/abs/1911.07518 Meta Adaptation using Importance Weighted Demonstrations by Lekkala, Kiran and Abu-El-Haija, Sami and Itti, Laurent http://arxiv.org/abs/1911.10322 VIABLE: Fast Adaptation via Backpropagating Learned Loss by Feng, Leo and Zintgraf, Luisa and Peng, Bei and Whiteson, Shimon http://arxiv.org/abs/1911.13159 Decoupling Adaptation from Modeling with Meta-Optimizers for Meta Learning by Arnold, S{\\'e}bastien M R and Iqbal, Shariq and Sha, Fei http://arxiv.org/abs/1910.13603 TADAM: Task dependent adaptive metric for improved few-shot learning by Oreshkin, Boris and Rodr{\\'\\i}guez L{\\'o}pez, Pau and Lacoste, Alexandre http://papers.nips.cc/paper/7352-tadam-task-dependent-adaptive-metric-for-improved-few-shot-learning.pdf Learning to Few-Shot Learn Across Diverse Natural Language Classification Tasks by Bansal, Trapit and Jha, Rishikesh and McCallum, Andrew http://arxiv.org/abs/1911.03863 Optimizing Millions of Hyperparameters by Implicit Differentiation by Lorraine, Jonathan and Vicol, Paul and Duvenaud, David http://arxiv.org/abs/1911.02590 Meta-data: Characterization of Input Features for Meta-learning by Castiello, Ciro and Castellano, Giovanna and Fanelli, Anna Maria http://dx.doi.org/10.1007/11526018_45 Meta-Learning for Low-resource Natural Language Generation in Task-oriented Dialogue Systems by Mi, Fei and Huang, Minlie and Zhang, Jiyong and Faltings, Boi http://arxiv.org/abs/1905.05644 Domain Generalization via Model-Agnostic Learning of Semantic Features by Dou, Qi and Castro, Daniel C and Kamnitsas, Konstantinos and Glocker, Ben http://arxiv.org/abs/1910.13580 Hierarchical Expert Networks for Meta-Learning by Hihn, Heinke and Braun, Daniel A http://arxiv.org/abs/1911.00348 Online Meta-Learning on Non-convex Setting by Zhuang, Zhenxun and Wang, Yunlong and Yu, Kezi and Lu, Songtao http://arxiv.org/abs/1910.10196 Learning-to-Learn Stochastic Gradient Descent with Biased Regularization by Denevi, Giulia and Ciliberto, Carlo and Grazzi, Riccardo and Pontil, Massimiliano http://arxiv.org/abs/1903.10399 Provable Guarantees for Gradient-Based Meta-Learning by Khodak, Mikhail and Balcan, Maria-Florina and Talwalkar, Ameet http://arxiv.org/abs/1902.10644 The TCGA Meta-Dataset Clinical Benchmark by Samiei, Mandana and W{\\\"u}rfl, Tobias and Deleu, Tristan and Weiss, Martin and Dutil, Francis and Fevens, Thomas and Boucher, Genevi{`e}ve and Lemieux, Sebastien and Cohen, Joseph Paul http://arxiv.org/abs/1910.08636 VariBAD: A Very Good Method for Bayes-Adaptive Deep RL via Meta-Learning by Zintgraf, Luisa and Shiarlis, Kyriacos and Igl, Maximilian and Schulze, Sebastian and Gal, Yarin and Hofmann, Katja and Whiteson, Shimon http://arxiv.org/abs/1910.08348 Meta-Transfer Learning through Hard Tasks by Sun, Qianru and Liu, Yaoyao and Chen, Zhaozheng and Chua, Tat-Seng and Schiele, Bernt http://arxiv.org/abs/1910.03648 Model-Agnostic Meta-Learning using Runge-Kutta Methods by Im, Daniel Jiwoong and Jiang, Yibo and Verma, Nakul http://arxiv.org/abs/1910.07368 Improving Generalization in Meta Reinforcement Learning using Learned Objectives by Kirsch, Louis and van Steenkiste, Sjoerd and Schmidhuber, J{\\\"u}rgen http://arxiv.org/abs/1910.04098 Generalized Inner Loop Meta-Learning by Grefenstette, Edward and Amos, Brandon and Yarats, Denis and Htut, Phu Mon and Molchanov, Artem and Meier, Franziska and Kiela, Douwe and Cho, Kyunghyun and Chintala, Soumith http://arxiv.org/abs/1910.01727 Is Fast Adaptation All You Need? by Javed, Khurram and Yao, Hengshuai and White, Martha http://arxiv.org/abs/1910.01705 Deep Reinforcement Learning for Single-Shot Diagnosis and Adaptation in Damaged Robots by Verma, Shresth and Nair, Haritha S and Agarwal, Gaurav and Dhar, Joydip and Shukla, Anupam http://arxiv.org/abs/1910.01240 ES-MAML: Simple Hessian-Free Meta Learning by Song, Xingyou and Gao, Wenbo and Yang, Yuxiang and Choromanski, Krzysztof and Pacchiano, Aldo and Tang, Yunhao http://arxiv.org/abs/1910.01215 Meta-Q-Learning by Fakoor, Rasool and Chaudhari, Pratik and Soatto, Stefano and Smola, Alexander J http://arxiv.org/abs/1910.00125 Efficient meta reinforcement learning via meta goal generation by Fu, Haotian and Tang, Hongyao and Hao, Jianye http://arxiv.org/abs/1909.13607 Chameleon: Learning Model Initializations Across Tasks With Different Schemas by Brinkmeyer, Lukas and Drumond, Rafael Rego and Scholz, Randolf and Grabocka, Josif and Schmidt-Thieme, Lars http://arxiv.org/abs/1909.13576 Learning Fast Adaptation with Meta Strategy Optimization by Yu, Wenhao and Tan, Jie and Bai, Yunfei and Coumans, Erwin and Ha, Sehoon http://arxiv.org/abs/1909.12995 Meta-Inverse Reinforcement Learning with Probabilistic Context Variables by Yu, Lantao and Yu, Tianhe and Finn, Chelsea and Ermon, Stefano http://arxiv.org/abs/1909.09314 Modular Meta-Learning with Shrinkage by Chen, Yutian and Friesen, Abram L and Behbahani, Feryal and Budden, David and Hoffman, Matthew W and Doucet, Arnaud and de Freitas, Nando http://arxiv.org/abs/1909.05557 Loaded DiCE: Trading off Bias and Variance in Any-Order Score Function Estimators for Reinforcement Learning by Farquhar, Gregory and Whiteson, Shimon and Foerster, Jakob http://arxiv.org/abs/1909.10549 Rapid Learning or Feature Reuse? Towards Understanding the Effectiveness of MAML by Raghu, Aniruddh and Raghu, Maithra and Bengio, Samy and Vinyals, Oriol http://arxiv.org/abs/1909.09157 Meta-Learning by Vanschoren, Joaquin https://doi.org/10.1007/978-3-030-05318-5_2 Understanding Short-Horizon Bias in Stochastic Meta-Optimization by Wu, Yuhuai and Ren, Mengye and Liao, Renjie and Grosse, Roger http://arxiv.org/abs/1803.02021 On First-Order Meta-Learning Algorithms by Nichol, Alex and Achiam, Joshua and Schulman, John http://arxiv.org/abs/1803.02999 Towards Understanding Generalization in Gradient-Based Meta-Learning by Guiroy, Simon and Verma, Vikas and Pal, Christopher http://arxiv.org/abs/1907.07287 They empirically study the landscape of fast-adaptation in MAML. The most interesting claim is that when meta-overfitting, the loss landscape becomes flatter on test tasks. On the Convergence Theory of Gradient-Based Model-Agnostic Meta-Learning Algorithms by Fallah, Alireza and Mokhtari, Aryan and Ozdaglar, Asuman http://arxiv.org/abs/1908.10400 Learning to Learn with Gradients by Finn, Chelsea http://learn2learn.net Acetylcholine and memory by Hasselmo, M E and Bower, J M https://www.ncbi.nlm.nih.gov/pubmed/7688162 A THEORY OF META-LEARNING AND PRINCIPLES OF FACILITATION: AN ORGANISMIC PERSPECTIVE by Maudsley, Donald B https://uosc.primo.exlibrisgroup.com/discovery/fulldisplay?docid=proquest302999651&context=PC&vid=01USC_INST:01USC&lang=en&search_scope=MyInst_and_CI&adaptor=Primo%20Central&tab=Everything&mode=Basic THE ROLE OF METALEARNING IN STUDY PROCESSES by Biggs, J B http://doi.wiley.com/10.1111/j.2044-8279.1985.tb02625.x Understanding and correcting pathologies in the training of learned optimizers by Metz, Luke and Maheswaranathan, Niru and Nixon, Jeremy and Daniel Freeman, C and Sohl-Dickstein, Jascha http://arxiv.org/abs/1810.10180 Provides many tricks (e.g. split train batch for model \\& opt, average gradient estimators) for training differentiable optimizers online. They also have a couple of interesting observations specific to recurrent optimizers. Learned Optimizers that Scale and Generalize by Wichrowska, Olga and Maheswaranathan, Niru and Hoffman, Matthew W and Colmenarejo, Sergio Gomez and Denil, Misha and de Freitas, Nando and Sohl-Dickstein, Jascha http://arxiv.org/abs/1703.04813 Using learned optimizers to make models robust to input noise by Metz, Luke and Maheswaranathan, Niru and Shlens, Jonathon and Sohl-Dickstein, Jascha and Cubuk, Ekin D http://arxiv.org/abs/1906.03367 Learning to Optimize Neural Nets by Li, Ke and Malik, Jitendra http://arxiv.org/abs/1703.00441 Meta-Learning Update Rules for Unsupervised Representation Learning by Metz, Luke and Maheswaranathan, Niru and Cheung, Brian and Sohl-Dickstein, Jascha http://arxiv.org/abs/1804.00222 Learning to Optimize by Li, Ke and Malik, Jitendra http://arxiv.org/abs/1606.01885 Learning to learn by gradient descent by gradient descent by Andrychowicz, M and Denil, M and Gomez, S http://learn2learn.net Online Learning Rate Adaptation with Hypergradient Descent by Baydin, Atilim Gunes and Cornish, Robert and Rubio, David Martinez and Schmidt, Mark and Wood, Frank http://arxiv.org/abs/1703.04782 They adapt the learning rate of SGD by differentiating the loss of the next parameters w.r.t. the learning rate. They observe that the gradient of the learning rate is simply the inner product of the last two gradients. Adapting Bias by Gradient Descent: An Incremental Version of Delta-Bar-Delta by Sutton, Richard S http://dx.doi.org/ What's mostly interesting in this paper is the adaptation of delta-bar-delta to the online scenario. The idea of representing the learning rate as an exponential is nice. Also nice to see that the derivation suggests a full-matrix adaptive case. Gain adaptation beats least squares by Sutton, Richard S https://pdfs.semanticscholar.org/7ec8/876f219b3b3d5c894a3f395c89c382029cc5.pdf This paper extends IDBD as algorithms K1 and K2, but from my quick read, it isn't clear what's the motivation for those modifications. (Seems to work in a `normalized space'', {\\ a} la natural gradient ?)They do work better. Local Gain Adaptation in Stochastic Gradient Descent by Schraudolph, Nicol N https://pdfs.semanticscholar.org/31a0/b86c3cd04e6539626f34b80db7ff79d23f40.pdf This algorithm extends IDBD (Sutton) to the non-linear setting. Interestingly, they have a few brief discussionson the difficulties to optimize at the meta-level. (c.f. Meta-level conditioning section.) Overall, it shines light on the ground idea behind IDBD. TIDBD: Adapting Temporal-difference Step-sizes Through Stochastic Meta-descent by Kearney, Alex and Veeriah, Vivek and Travnik, Jaden B and Sutton, Richard S and Pilarski, Patrick M http://arxiv.org/abs/1804.03334 Increased rates of convergence through learning rate adaptation by Jacobs, Robert A http://www.sciencedirect.com/science/article/pii/0893608088900032 This paper argues that we need (at least) four ingredients to improve optimization of connectionist networks: 1. each parameter has its own stepsize, 2. stepsizes vary over time, 3. if consecutive gradients of a stepsize have the same sign, the stepsize should be increased, 4. conversely, if the stepsize should be decreased if its gradients have opposite signs. It also proposes to use two improvements: 1. Momentum (i.e. Polyak's heavyball), 2. delta-bar-delta (i.e. learning the stepsize). It has an interesting comment on the difficulty of learning the stepsize, and therefore comes up with a ``hack'' that outperforms momentum. Meta-descent for Online, Continual Prediction by Jacobsen, Andrew and Schlegel, Matthew and Linke, Cameron and Degris, Thomas and White, Adam and White, Martha http://arxiv.org/abs/1907.07751 The idea is to learn the learning rate so as to minimize the norm of the gradient. They argue that for the continual learning setting, this forces the algorithm to stay ``as stable as possible''. No theorems, small-scale (but interesting) experiments. Adaptation of learning rate parameters by Sutton, Rich http://learn2learn.net Gradient-Based Meta-Learning with Learned Layerwise Metric and Subspace by Lee, Yoonho and Choi, Seungjin http://arxiv.org/abs/1801.05558 Meta-Learning with Warped Gradient Descent by Flennerhag, Sebastian and Rusu, Andrei A and Pascanu, Razvan and Yin, Hujun and Hadsell, Raia http://arxiv.org/abs/1909.00025 Meta-Learning via Learned Loss by Chebotar, Yevgen and Molchanov, Artem and Bechtle, Sarah and Righetti, Ludovic and Meier, Franziska and Sukhatme, Gaurav http://arxiv.org/abs/1906.05374 They learn the loss as a NN, and that loss's objective is to maximize the sum of rewards. It is provided a bunch of things, including inputs, outputs, goals. Meta-Curvature by Park, Eunbyung and Oliva, Junier B http://arxiv.org/abs/1902.03356 Alpha MAML: Adaptive Model-Agnostic Meta-Learning by Behl, Harkirat Singh and Baydin, At{\\i}l{\\i}m G{\\\"u}ne{\\c s} and Torr, Philip H S http://arxiv.org/abs/1905.07435 They combine hypergradient and MAML: adapt all learning rates at all times. Meta-SGD: Learning to Learn Quickly for Few-Shot Learning by Li, Zhenguo and Zhou, Fengwei and Chen, Fei and Li, Hang http://arxiv.org/abs/1707.09835 ProMP: Proximal Meta-Policy Search by Rothfuss, Jonas and Lee, Dennis and Clavera, Ignasi and Asfour, Tamim and Abbeel, Pieter http://arxiv.org/abs/1810.06784 Model-Agnostic Meta-Learning for Fast Adaptation of Deep Networks by Finn, Chelsea and Abbeel, Pieter and Levine, Sergey http://learn2learn.net Optimization as a model for few-shot learning by Ravi, Sachin and Larochelle, Hugo https://openreview.net/pdf?id=rJY0-Kcll Fast Context Adaptation via Meta-Learning by Zintgraf, Luisa M and Shiarlis, Kyriacos and Kurin, Vitaly and Hofmann, Katja and Whiteson, Shimon http://arxiv.org/abs/1810.03642 Meta-Learning with Implicit Gradients by Rajeswaran, Aravind and Finn, Chelsea and Kakade, Sham and Levine, Sergey http://arxiv.org/abs/1909.04630 Natural Neural Networks by Desjardins, Guillaume and Simonyan, Karen and Pascanu, Razvan and Kavukcuoglu, Koray http://dl.acm.org/citation.cfm?id=2969442.2969471 A Baseline for Few-Shot Image Classification by Dhillon, Guneet S and Chaudhari, Pratik and Ravichandran, Avinash and Soatto, Stefano http://arxiv.org/abs/1909.02729 A CLOSER LOOK AT FEW-SHOT CLASSIFICATION by Chen, Wei-Yu and Liu, Yen-Cheng and Kira, Zsolt https://openreview.net/pdf?id=HkxLXnAcFQ Suggests that meta-learning papers haven't been tested against classical baselines. When considering those baselines, they perform better than many of the recent meta-learning techniques. Meta-learning with differentiable closed-form solvers by Bertinetto, Luca and Henriques, Joao F and Torr, Philip and Vedaldi, Andrea https://openreview.net/forum?id=HyxnZh0ct7 Uncertainty in Model-Agnostic Meta-Learning using Variational Inference by Nguyen, Cuong and Do, Thanh-Toan and Carneiro, Gustavo http://arxiv.org/abs/1907.11864 Meta-Reinforcement Learning of Structured Exploration Strategies by Gupta, Abhishek and Mendonca, Russell and Liu, Yuxuan and Abbeel, Pieter and Levine, Sergey http://arxiv.org/abs/1802.07245 Metalearned Neural Memory by Munkhdalai, Tsendsuren and Sordoni, Alessandro and Wang, Tong and Trischler, Adam http://arxiv.org/abs/1907.09720 Accelerated Stochastic Approximation by Kesten, Harry https://projecteuclid.org/euclid.aoms/1177706705 Meta-Learning for Black-box Optimization by Vishnu, T V and Malhotra, Pankaj and Narwariya, Jyoti and Vig, Lovekesh and Shroff, Gautam http://arxiv.org/abs/1907.06901 They essentially extend the recurrent meta-learning framework in a few ways: 1. Use regret instead of objective improvement as meta-learning objective. 2. Normalize the objective so as to make it play nice with LSTMs. 3. Incorporate domain-constraints, so that the LSTM always outputs feasible solutions. All are described in page 3. Task Agnostic Continual Learning via Meta Learning by He, Xu and Sygnowski, Jakub and Galashov, Alexandre and Rusu, Andrei A and Teh, Yee Whye and Pascanu, Razvan http://arxiv.org/abs/1906.05201 Watch, Try, Learn: Meta-Learning from Demonstrations and Reward by Zhou, Allan and Jang, Eric and Kappler, Daniel and Herzog, Alex and Khansari, Mohi and Wohlhart, Paul and Bai, Yunfei and Kalakrishnan, Mrinal and Levine, Sergey and Finn, Chelsea http://arxiv.org/abs/1906.03352 Meta-Learning Representations for Continual Learning by Javed, Khurram and White, Martha http://arxiv.org/abs/1905.12588 TapNet: Neural Network Augmented with Task-Adaptive Projection for Few-Shot Learning by Yoon, Sung Whan and Seo, Jun and Moon, Jaekyun http://arxiv.org/abs/1905.06549 Meta Reinforcement Learning with Task Embedding and Shared Policy by Lan, Lin and Li, Zhenguo and Guan, Xiaohong and Wang, Pinghui http://arxiv.org/abs/1905.06527 Hierarchically Structured Meta-learning by Yao, Huaxiu and Wei, Ying and Huang, Junzhou and Li, Zhenhui http://arxiv.org/abs/1905.05301 Curious Meta-Controller: Adaptive Alternation between Model-Based and Model-Free Control in Deep Reinforcement Learning by Hafez, Muhammad Burhan and Weber, Cornelius and Kerzel, Matthias and Wermter, Stefan http://arxiv.org/abs/1905.01718 Learning to Learn in Simulation by Teng, Ervin and Iannucci, Bob http://arxiv.org/abs/1902.01569 Meta-Learning with Differentiable Convex Optimization by Lee, Kwonjoon and Maji, Subhransu and Ravichandran, Avinash and Soatto, Stefano http://arxiv.org/abs/1904.03758 Functional Regularisation for Continual Learning by Titsias, Michalis K and Schwarz, Jonathan and de G. Matthews, Alexander G and Pascanu, Razvan and Teh, Yee Whye http://arxiv.org/abs/1901.11356 Learning to Forget for Meta-Learning by Baik, Sungyong and Hong, Seokil and Lee, Kyoung Mu http://arxiv.org/abs/1906.05895 Meta-learning of Sequential Strategies by Ortega, Pedro A and Wang, Jane X and Rowland, Mark and Genewein, Tim and Kurth-Nelson, Zeb and Pascanu, Razvan and Heess, Nicolas and Veness, Joel and Pritzel, Alex and Sprechmann, Pablo and Jayakumar, Siddhant M and McGrath, Tom and Miller, Kevin and Azar, Mohammad and Osband, Ian and Rabinowitz, Neil and Gy{\\\"o}rgy, Andr{\\'a}s and Chiappa, Silvia and Osindero, Simon and Teh, Yee Whye and van Hasselt, Hado and de Freitas, Nando and Botvinick, Matthew and Legg, Shane http://arxiv.org/abs/1905.03030 This paper essentially provides a theoretical framework to ground the fact that recurrent meta-learning (RL^2, LLGD^2) performs Bayesian inference during adaptation. Auto-Meta: Automated Gradient Based Meta Learner Search by Kim, Jaehong and Lee, Sangyeul and Kim, Sungwan and Cha, Moonsu and Lee, Jung Kwon and Choi, Youngduck and Choi, Yongseok and Cho, Dong-Yeon and Kim, Jiwon http://arxiv.org/abs/1806.06927 Adaptive Gradient-Based Meta-Learning Methods by Khodak, Mikhail and Florina-Balcan, Maria and Talwalkar, Ameet http://arxiv.org/abs/1906.02717 Embedded Meta-Learning: Toward more flexible deep-learning models by Lampinen, Andrew K and McClelland, James L http://arxiv.org/abs/1905.09950 Modular meta-learning by Alet, Ferran and Lozano-P{\\'e}rez, Tom{\\'a}s and Kaelbling, Leslie P http://arxiv.org/abs/1806.10166 MetaPred: Meta-Learning for Clinical Risk Prediction with Limited Patient Electronic Health Records by Zhang, Xi Sheryl and Tang, Fengyi and Dodge, Hiroko and Zhou, Jiayu and Wang, Fei http://arxiv.org/abs/1905.03218 Prototypical Networks for Few-shot Learning by Snell, Jake and Swersky, Kevin and Zemel, Richard S http://arxiv.org/abs/1703.05175 Meta-learners' learning dynamics are unlike learners' by Rabinowitz, Neil C http://arxiv.org/abs/1905.01320 Backpropamine: training self-modifying neural networks with differentiable neuromodulated plasticity by Miconi, Thomas and Rawal, Aditya and Clune, Jeff and Stanley, Kenneth O https://openreview.net/forum?id=r1lrAiA5Ym Reinforcement Learning, Fast and Slow by Botvinick, Matthew and Ritter, Sam and Wang, Jane X and Kurth-Nelson, Zeb and Blundell, Charles and Hassabis, Demis http://dx.doi.org/10.1016/j.tics.2019.02.006 Been There, Done That: Meta-Learning with Episodic Recall by Ritter, Samuel and Wang, Jane X and Kurth-Nelson, Zeb and Jayakumar, Siddhant M and Blundell, Charles and Pascanu, Razvan and Botvinick, Matthew http://arxiv.org/abs/1805.09692 Guided Meta-Policy Search by Mendonca, Russell and Gupta, Abhishek and Kralev, Rosen and Abbeel, Pieter and Levine, Sergey and Finn, Chelsea http://arxiv.org/abs/1904.00956 Hierarchical Meta Learning by Zou, Yingtian and Feng, Jiashi http://arxiv.org/abs/1904.09081 A Meta-Transfer Objective for Learning to Disentangle Causal Mechanisms by Bengio, Yoshua and Deleu, Tristan and Rahaman, Nasim and Ke, Rosemary and Lachapelle, S{\\'e}bastien and Bilaniuk, Olexa and Goyal, Anirudh and Pal, Christopher http://arxiv.org/abs/1901.10912 Generalize Across Tasks: Efficient Algorithms for Linear Representation Learning by Bullins, Brian and Hazan, Elad and Kalai, Adam and Livni, Roi http://proceedings.mlr.press/v98/bullins19a.html Incremental Learning-to-Learn with Statistical Guarantees by Denevi, Giulia and Ciliberto, Carlo and Stamos, Dimitris and Pontil, Massimiliano http://arxiv.org/abs/1803.08089 A Model of Inductive Bias Learning by Baxter, J http://arxiv.org/abs/1106.0245 Efficient Off-Policy Meta-Reinforcement Learning via Probabilistic Context Variables by Rakelly, Kate and Zhou, Aurick and Quillen, Deirdre and Finn, Chelsea and Levine, Sergey http://arxiv.org/abs/1903.08254 Continual Learning with Tiny Episodic Memories by Chaudhry, Arslan and Rohrbach, Marcus and Elhoseiny, Mohamed and Ajanthan, Thalaiyasingam and Dokania, Puneet K and Torr, Philip H S and Ranzato, Marc'aurelio http://arxiv.org/abs/1902.10486 Online Meta-Learning by Finn, Chelsea and Rajeswaran, Aravind and Kakade, Sham and Levine, Sergey http://arxiv.org/abs/1902.08438 Modulating transfer between tasks in gradient-based meta-learning by Grant, Erin and Jerfel, Ghassen and Heller, Katherine and Griffiths, Thomas L https://openreview.net/pdf?id=HyxpNnRcFX Learning to Adapt in Dynamic, Real-World Environments Through Meta-Reinforcement Learning by Nagabandi, Anusha and Clavera, Ignasi and Liu, Simin and Fearing, Ronald S and Abbeel, Pieter and Levine, Sergey and Finn, Chelsea http://arxiv.org/abs/1803.11347 Meta-Learning with Latent Embedding Optimization by Rusu, Andrei A and Rao, Dushyant and Sygnowski, Jakub and Vinyals, Oriol and Pascanu, Razvan and Osindero, Simon and Hadsell, Raia http://arxiv.org/abs/1807.05960 Learning to Generalize: Meta-Learning for Domain Generalization by Li, Da and Yang, Yongxin and Song, Yi-Zhe and Hospedales, Timothy M http://arxiv.org/abs/1710.03463 Some Considerations on Learning to Explore via Meta-Reinforcement Learning by Stadie, Bradly C and Yang, Ge and Houthooft, Rein and Chen, Xi and Duan, Yan and Wu, Yuhuai and Abbeel, Pieter and Sutskever, Ilya http://arxiv.org/abs/1803.01118 How to train your MAML by Antoniou, Antreas and Edwards, Harrison and Storkey, Amos http://arxiv.org/abs/1810.09502 Bayesian Model-Agnostic Meta-Learning by Kim, Taesup and Yoon, Jaesik and Dia, Ousmane and Kim, Sungwoong and Bengio, Yoshua and Ahn, Sungjin http://arxiv.org/abs/1806.03836 Probabilistic Model-Agnostic Meta-Learning by Finn, Chelsea and Xu, Kelvin and Levine, Sergey http://arxiv.org/abs/1806.02817 The effects of negative adaptation in Model-Agnostic Meta-Learning by Deleu, Tristan and Bengio, Yoshua http://arxiv.org/abs/1812.02159 Memory-based Parameter Adaptation by Sprechmann, Pablo and Jayakumar, Siddhant M and Rae, Jack W and Pritzel, Alexander and Badia, Adri{`a} Puigdom{`e}nech and Uria, Benigno and Vinyals, Oriol and Hassabis, Demis and Pascanu, Razvan and Blundell, Charles http://arxiv.org/abs/1802.10542 Deep Meta-Learning: Learning to Learn in the Concept Space by Zhou, Fengwei and Wu, Bin and Li, Zhenguo http://arxiv.org/abs/1802.03596 Deep Prior by Lacoste, Alexandre and Boquet, Thomas and Rostamzadeh, Negar and Oreshkin, Boris and Chung, Wonchang and Krueger, David http://arxiv.org/abs/1712.05016 Recasting Gradient-Based Meta-Learning as Hierarchical Bayes by Grant, Erin and Finn, Chelsea and Levine, Sergey and Darrell, Trevor and Griffiths, Thomas http://arxiv.org/abs/1801.08930 WNGrad: Learn the Learning Rate in Gradient Descent by Wu, Xiaoxia and Ward, Rachel and Bottou, L{\\'e}on http://arxiv.org/abs/1803.02865 Learning to Learn by Finn, Chelsea http://bair.berkeley.edu/blog/2017/07/18/learning-to-learn/ Continuous Adaptation via Meta-Learning in Nonstationary and Competitive Environments by Al-Shedivat, Maruan and Bansal, Trapit and Burda, Yuri and Sutskever, Ilya and Mordatch, Igor and Abbeel, Pieter http://arxiv.org/abs/1710.03641","title":"Submitted Papers"},{"location":"_build/pydocmd/paper_list/#submission-form","text":"Loading\u2026","title":"Submission Form"},{"location":"_build/pydocmd/docs/learn2learn.algorithms/","text":"learn2learn.algorithms \u00b6 A set of high-level algorithm implementations, with easy-to-use API. MAML \u00b6 1 MAML ( model , lr , first_order = False , allow_unused = None , allow_nograd = False ) [Source] Description High-level implementation of Model-Agnostic Meta-Learning . This class wraps an arbitrary nn.Module and augments it with clone() and adapt() methods. For the first-order version of MAML (i.e. FOMAML), set the first_order flag to True upon initialization. Arguments model (Module) - Module to be wrapped. lr (float) - Fast adaptation learning rate. first_order (bool, optional , default=False) - Whether to use the first-order approximation of MAML. (FOMAML) allow_unused (bool, optional , default=None) - Whether to allow differentiation of unused parameters. Defaults to allow_nograd . allow_nograd (bool, optional , default=False) - Whether to allow adaptation with parameters that have requires_grad = False . References Finn et al. 2017. \"Model-Agnostic Meta-Learning for Fast Adaptation of Deep Networks.\" Example 1 2 3 4 5 6 linear = l2l . algorithms . MAML ( nn . Linear ( 20 , 10 ), lr = 0.01 ) clone = linear . clone () error = loss ( clone ( X ), y ) clone . adapt ( error ) error = loss ( clone ( X ), y ) error . backward () adapt \u00b6 1 MAML . adapt ( loss , first_order = None , allow_unused = None , allow_nograd = None ) Description Takes a gradient step on the loss and updates the cloned parameters in place. Arguments loss (Tensor) - Loss to minimize upon update. first_order (bool, optional , default=None) - Whether to use first- or second-order updates. Defaults to self.first_order. allow_unused (bool, optional , default=None) - Whether to allow differentiation of unused parameters. Defaults to self.allow_unused. allow_nograd (bool, optional , default=None) - Whether to allow adaptation with parameters that have requires_grad = False . Defaults to self.allow_nograd. clone \u00b6 1 MAML . clone ( first_order = None , allow_unused = None , allow_nograd = None ) Description Returns a MAML -wrapped copy of the module whose parameters and buffers are torch.clone d from the original module. This implies that back-propagating losses on the cloned module will populate the buffers of the original module. For more information, refer to learn2learn.clone_module(). Arguments first_order (bool, optional , default=None) - Whether the clone uses first- or second-order updates. Defaults to self.first_order. allow_unused (bool, optional , default=None) - Whether to allow differentiation of unused parameters. Defaults to self.allow_unused. allow_nograd (bool, optional , default=False) - Whether to allow adaptation with parameters that have requires_grad = False . Defaults to self.allow_nograd. MetaSGD \u00b6 1 MetaSGD ( model , lr = 1.0 , first_order = False , lrs = None ) [Source] Description High-level implementation of Meta-SGD . This class wraps an arbitrary nn.Module and augments it with clone() and adapt methods. It behaves similarly to MAML , but in addition a set of per-parameters learning rates are learned for fast-adaptation. Arguments model (Module) - Module to be wrapped. lr (float) - Initialization value of the per-parameter fast adaptation learning rates. first_order (bool, optional , default=False) - Whether to use the first-order version. lrs (list of Parameters, optional , default=None) - If not None, overrides lr , and uses the list as learning rates for fast-adaptation. References Li et al. 2017. \u201cMeta-SGD: Learning to Learn Quickly for Few-Shot Learning.\u201d arXiv. Example 1 2 3 4 5 6 linear = l2l . algorithms . MetaSGD ( nn . Linear ( 20 , 10 ), lr = 0.01 ) clone = linear . clone () error = loss ( clone ( X ), y ) clone . adapt ( error ) error = loss ( clone ( X ), y ) error . backward () clone \u00b6 1 MetaSGD . clone () Descritpion Akin to MAML.clone() but for MetaSGD: it includes a set of learnable fast-adaptation learning rates. adapt \u00b6 1 MetaSGD . adapt ( loss , first_order = None ) Descritpion Akin to MAML.adapt() but for MetaSGD: it updates the model with the learnable per-parameter learning rates. GBML \u00b6 1 2 3 4 5 6 7 8 GBML ( module , transform , lr = 1.0 , adapt_transform = False , first_order = False , allow_unused = False , allow_nograd = False , ** kwargs ) [Source] Description General wrapper for gradient-based meta-learning implementations. A variety of algorithms can simply be implemented by changing the kind of transform used during fast-adaptation. For example, if the transform is Scale we recover Meta-SGD [2] with adapt_transform=False and Alpha MAML [4] with adapt_transform=True . If the transform is a Kronecker-factored module (e.g. neural network, or linear), we recover KFO from [5]. Arguments module (Module) - Module to be wrapped. tranform (Module) - Transform used to update the module. lr (float) - Fast adaptation learning rate. adapt_transform (bool, optional , default=False) - Whether to update the transform's parameters during fast-adaptation. first_order (bool, optional , default=False) - Whether to use the first-order approximation. allow_unused (bool, optional , default=None) - Whether to allow differentiation of unused parameters. Defaults to allow_nograd . allow_nograd (bool, optional , default=False) - Whether to allow adaptation with parameters that have requires_grad = False . References Finn et al. 2017. \u201cModel-Agnostic Meta-Learning for Fast Adaptation of Deep Networks.\u201d Li et al. 2017. \u201cMeta-SGD: Learning to Learn Quickly for Few-Shot Learning.\u201d Park & Oliva. 2019. \u201cMeta-Curvature.\u201d Behl et al. 2019. \u201cAlpha MAML: Adaptive Model-Agnostic Meta-Learning.\u201d Arnold et al. 2019. \u201cWhen MAML Can Adapt Fast and How to Assist When It Cannot.\u201d Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 model = SmallCNN () transform = l2l . optim . ModuleTransform ( torch . nn . Linear ) gbml = l2l . algorithms . GBML ( module = model , transform = transform , lr = 0.01 , adapt_transform = True , ) gbml . to ( device ) opt = torch . optim . SGD ( gbml . parameters (), lr = 0.001 ) __Training with 1 adaptation step__ for iteration in range ( 10 ): opt . zero_grad () task_model = gbml . clone () loss = compute_loss ( task_model ) task_model . adapt ( loss ) loss . backward () opt . step () clone \u00b6 1 2 3 4 GBML . clone ( first_order = None , allow_unused = None , allow_nograd = None , adapt_transform = None ) Description Similar to MAML.clone() . Arguments first_order (bool, optional , default=None) - Whether the clone uses first- or second-order updates. Defaults to self.first_order. allow_unused (bool, optional , default=None) - Whether to allow differentiation of unused parameters. Defaults to self.allow_unused. allow_nograd (bool, optional , default=False) - Whether to allow adaptation with parameters that have requires_grad = False . Defaults to self.allow_nograd. adapt \u00b6 1 GBML . adapt ( loss , first_order = None , allow_nograd = None , allow_unused = None ) Description Takes a gradient step on the loss and updates the cloned parameters in place. The parameters of the transform are only adapted if self.adapt_update is True . Arguments loss (Tensor) - Loss to minimize upon update. first_order (bool, optional , default=None) - Whether to use first- or second-order updates. Defaults to self.first_order. allow_unused (bool, optional , default=None) - Whether to allow differentiation of unused parameters. Defaults to self.allow_unused. allow_nograd (bool, optional , default=None) - Whether to allow adaptation with parameters that have requires_grad = False . Defaults to self.allow_nograd. LightningMAML \u00b6 1 LightningMAML ( model , loss = None , ** kwargs ) [Source] Description A PyTorch Lightning module for MAML. Arguments model (Module) - A PyTorch nn.Module. loss (Function, optional , default=CrossEntropyLoss) - Loss function which maps the cost of the events. ways (int, optional , default=5) - Number of classes in a task. shots (int, optional , default=1) - Number of samples for adaptation. adaptation_steps (int, optional , default=1) - Number of steps for adapting to new task. lr (float, optional , default=0.001) - Learning rate of meta training. adaptation_lr (float, optional , default=0.1) - Learning rate for fast adaptation. scheduler_step (int, optional , default=20) - Decay interval for lr . scheduler_decay (float, optional , default=1.0) - Decay rate for lr . References Finn et al. 2017. \"Model-Agnostic Meta-Learning for Fast Adaptation of Deep Networks.\" Example 1 2 3 4 5 6 tasksets = l2l . vision . benchmarks . get_tasksets ( 'omniglot' ) model = l2l . vision . models . OmniglotFC ( 28 ** 2 , args . ways ) maml = LightningMAML ( classifier , adaptation_lr = 0.1 , ** dict_args ) episodic_data = EpisodicBatcher ( tasksets . train , tasksets . validation , tasksets . test ) trainer = pl . Trainer . from_argparse_args ( args ) trainer . fit ( maml , episodic_data ) LightningANIL \u00b6 1 LightningANIL ( features , classifier , loss = None , ** kwargs ) [Source] Description A PyTorch Lightning module for ANIL. Arguments features (Module) - A nn.Module to extract features, which will not be adaptated. classifier (Module) - A nn.Module taking features, mapping them to classification. loss (Function, optional , default=CrossEntropyLoss) - Loss function which maps the cost of the events. ways (int, optional , default=5) - Number of classes in a task. shots (int, optional , default=1) - Number of samples for adaptation. adaptation_steps (int, optional , default=1) - Number of steps for adapting to new task. lr (float, optional , default=0.001) - Learning rate of meta training. adaptation_lr (float, optional , default=0.1) - Learning rate for fast adaptation. scheduler_step (int, optional , default=20) - Decay interval for lr . scheduler_decay (float, optional , default=1.0) - Decay rate for lr . References Raghu et al. 2020. \"Rapid Learning or Feature Reuse? Towards Understanding the Effectiveness of MAML\" Example 1 2 3 4 5 6 tasksets = l2l . vision . benchmarks . get_tasksets ( 'omniglot' ) model = l2l . vision . models . OmniglotFC ( 28 ** 2 , args . ways ) anil = LightningANIL ( model . features , model . classifier , adaptation_lr = 0.1 , ** dict_args ) episodic_data = EpisodicBatcher ( tasksets . train , tasksets . validation , tasksets . test ) trainer = pl . Trainer . from_argparse_args ( args ) trainer . fit ( anil , episodic_data ) LightningPrototypicalNetworks \u00b6 1 LightningPrototypicalNetworks ( features , loss = None , ** kwargs ) [Source] Description A PyTorch Lightning module for Prototypical Networks. Arguments features (Module) - Feature extractor which classifies input tasks. loss (Function, optional , default=CrossEntropyLoss) - Loss function which maps the cost of the events. distance_metric (str, optional , default='euclidean') - Distance metric between samples. ['euclidean', 'cosine'] train_ways (int, optional , default=5) - Number of classes in for train tasks. train_shots (int, optional , default=1) - Number of support samples for train tasks. train_queries (int, optional , default=1) - Number of query samples for train tasks. test_ways (int, optional , default=5) - Number of classes in for test tasks. test_shots (int, optional , default=1) - Number of support samples for test tasks. test_queries (int, optional , default=1) - Number of query samples for test tasks. lr (float, optional , default=0.001) - Learning rate of meta training. scheduler_step (int, optional , default=20) - Decay interval for lr . scheduler_decay (float, optional , default=1.0) - Decay rate for lr . References Snell et al. 2017. \"Prototypical Networks for Few-shot Learning\" Example 1 2 3 4 5 6 tasksets = l2l . vision . benchmarks . get_tasksets ( 'mini-imagenet' ) features = Convnet () # init model protonet = LightningPrototypicalNetworks ( features , ** dict_args ) episodic_data = EpisodicBatcher ( tasksets . train , tasksets . validation , tasksets . test ) trainer = pl . Trainer . from_argparse_args ( args ) trainer . fit ( protonet , episodic_data ) LightningMetaOptNet \u00b6 1 LightningMetaOptNet ( features , loss = None , ** kwargs ) [Source] Description A PyTorch Lightning module for MetaOptNet. Arguments features (Module) - Feature extractor which classifies input tasks. svm_C_reg (float, optional , default=0.1) - Regularization weight for SVM. svm_max_iters (int, optional , default=15) - Maximum number of iterations for SVM convergence. loss (Function, optional , default=CrossEntropyLoss) - Loss function which maps the cost of the events. train_ways (int, optional , default=5) - Number of classes in for train tasks. train_shots (int, optional , default=1) - Number of support samples for train tasks. train_queries (int, optional , default=1) - Number of query samples for train tasks. test_ways (int, optional , default=5) - Number of classes in for test tasks. test_shots (int, optional , default=1) - Number of support samples for test tasks. test_queries (int, optional , default=1) - Number of query samples for test tasks. lr (float, optional , default=0.001) - Learning rate of meta training. scheduler_step (int, optional , default=20) - Decay interval for lr . scheduler_decay (float, optional , default=1.0) - Decay rate for lr . References Lee et al. 2019. \"Meta-Learning with Differentiable Convex Optimization\" Example 1 2 3 4 5 6 tasksets = l2l . vision . benchmarks . get_tasksets ( 'mini-imagenet' ) features = Convnet () # init model metaoptnet = LightningMetaOptNet ( features , ** dict_args ) episodic_data = EpisodicBatcher ( tasksets . train , tasksets . validation , tasksets . test ) trainer = pl . Trainer . from_argparse_args ( args ) trainer . fit ( metaoptnet , episodic_data )","title":"learn2learn.algorithms"},{"location":"_build/pydocmd/docs/learn2learn.algorithms/#learn2learnalgorithms","text":"A set of high-level algorithm implementations, with easy-to-use API.","title":"learn2learn.algorithms"},{"location":"_build/pydocmd/docs/learn2learn.algorithms/#maml","text":"1 MAML ( model , lr , first_order = False , allow_unused = None , allow_nograd = False ) [Source] Description High-level implementation of Model-Agnostic Meta-Learning . This class wraps an arbitrary nn.Module and augments it with clone() and adapt() methods. For the first-order version of MAML (i.e. FOMAML), set the first_order flag to True upon initialization. Arguments model (Module) - Module to be wrapped. lr (float) - Fast adaptation learning rate. first_order (bool, optional , default=False) - Whether to use the first-order approximation of MAML. (FOMAML) allow_unused (bool, optional , default=None) - Whether to allow differentiation of unused parameters. Defaults to allow_nograd . allow_nograd (bool, optional , default=False) - Whether to allow adaptation with parameters that have requires_grad = False . References Finn et al. 2017. \"Model-Agnostic Meta-Learning for Fast Adaptation of Deep Networks.\" Example 1 2 3 4 5 6 linear = l2l . algorithms . MAML ( nn . Linear ( 20 , 10 ), lr = 0.01 ) clone = linear . clone () error = loss ( clone ( X ), y ) clone . adapt ( error ) error = loss ( clone ( X ), y ) error . backward ()","title":"MAML"},{"location":"_build/pydocmd/docs/learn2learn.algorithms/#adapt","text":"1 MAML . adapt ( loss , first_order = None , allow_unused = None , allow_nograd = None ) Description Takes a gradient step on the loss and updates the cloned parameters in place. Arguments loss (Tensor) - Loss to minimize upon update. first_order (bool, optional , default=None) - Whether to use first- or second-order updates. Defaults to self.first_order. allow_unused (bool, optional , default=None) - Whether to allow differentiation of unused parameters. Defaults to self.allow_unused. allow_nograd (bool, optional , default=None) - Whether to allow adaptation with parameters that have requires_grad = False . Defaults to self.allow_nograd.","title":"adapt"},{"location":"_build/pydocmd/docs/learn2learn.algorithms/#clone","text":"1 MAML . clone ( first_order = None , allow_unused = None , allow_nograd = None ) Description Returns a MAML -wrapped copy of the module whose parameters and buffers are torch.clone d from the original module. This implies that back-propagating losses on the cloned module will populate the buffers of the original module. For more information, refer to learn2learn.clone_module(). Arguments first_order (bool, optional , default=None) - Whether the clone uses first- or second-order updates. Defaults to self.first_order. allow_unused (bool, optional , default=None) - Whether to allow differentiation of unused parameters. Defaults to self.allow_unused. allow_nograd (bool, optional , default=False) - Whether to allow adaptation with parameters that have requires_grad = False . Defaults to self.allow_nograd.","title":"clone"},{"location":"_build/pydocmd/docs/learn2learn.algorithms/#metasgd","text":"1 MetaSGD ( model , lr = 1.0 , first_order = False , lrs = None ) [Source] Description High-level implementation of Meta-SGD . This class wraps an arbitrary nn.Module and augments it with clone() and adapt methods. It behaves similarly to MAML , but in addition a set of per-parameters learning rates are learned for fast-adaptation. Arguments model (Module) - Module to be wrapped. lr (float) - Initialization value of the per-parameter fast adaptation learning rates. first_order (bool, optional , default=False) - Whether to use the first-order version. lrs (list of Parameters, optional , default=None) - If not None, overrides lr , and uses the list as learning rates for fast-adaptation. References Li et al. 2017. \u201cMeta-SGD: Learning to Learn Quickly for Few-Shot Learning.\u201d arXiv. Example 1 2 3 4 5 6 linear = l2l . algorithms . MetaSGD ( nn . Linear ( 20 , 10 ), lr = 0.01 ) clone = linear . clone () error = loss ( clone ( X ), y ) clone . adapt ( error ) error = loss ( clone ( X ), y ) error . backward ()","title":"MetaSGD"},{"location":"_build/pydocmd/docs/learn2learn.algorithms/#clone_1","text":"1 MetaSGD . clone () Descritpion Akin to MAML.clone() but for MetaSGD: it includes a set of learnable fast-adaptation learning rates.","title":"clone"},{"location":"_build/pydocmd/docs/learn2learn.algorithms/#adapt_1","text":"1 MetaSGD . adapt ( loss , first_order = None ) Descritpion Akin to MAML.adapt() but for MetaSGD: it updates the model with the learnable per-parameter learning rates.","title":"adapt"},{"location":"_build/pydocmd/docs/learn2learn.algorithms/#gbml","text":"1 2 3 4 5 6 7 8 GBML ( module , transform , lr = 1.0 , adapt_transform = False , first_order = False , allow_unused = False , allow_nograd = False , ** kwargs ) [Source] Description General wrapper for gradient-based meta-learning implementations. A variety of algorithms can simply be implemented by changing the kind of transform used during fast-adaptation. For example, if the transform is Scale we recover Meta-SGD [2] with adapt_transform=False and Alpha MAML [4] with adapt_transform=True . If the transform is a Kronecker-factored module (e.g. neural network, or linear), we recover KFO from [5]. Arguments module (Module) - Module to be wrapped. tranform (Module) - Transform used to update the module. lr (float) - Fast adaptation learning rate. adapt_transform (bool, optional , default=False) - Whether to update the transform's parameters during fast-adaptation. first_order (bool, optional , default=False) - Whether to use the first-order approximation. allow_unused (bool, optional , default=None) - Whether to allow differentiation of unused parameters. Defaults to allow_nograd . allow_nograd (bool, optional , default=False) - Whether to allow adaptation with parameters that have requires_grad = False . References Finn et al. 2017. \u201cModel-Agnostic Meta-Learning for Fast Adaptation of Deep Networks.\u201d Li et al. 2017. \u201cMeta-SGD: Learning to Learn Quickly for Few-Shot Learning.\u201d Park & Oliva. 2019. \u201cMeta-Curvature.\u201d Behl et al. 2019. \u201cAlpha MAML: Adaptive Model-Agnostic Meta-Learning.\u201d Arnold et al. 2019. \u201cWhen MAML Can Adapt Fast and How to Assist When It Cannot.\u201d Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 model = SmallCNN () transform = l2l . optim . ModuleTransform ( torch . nn . Linear ) gbml = l2l . algorithms . GBML ( module = model , transform = transform , lr = 0.01 , adapt_transform = True , ) gbml . to ( device ) opt = torch . optim . SGD ( gbml . parameters (), lr = 0.001 ) __Training with 1 adaptation step__ for iteration in range ( 10 ): opt . zero_grad () task_model = gbml . clone () loss = compute_loss ( task_model ) task_model . adapt ( loss ) loss . backward () opt . step ()","title":"GBML"},{"location":"_build/pydocmd/docs/learn2learn.algorithms/#clone_2","text":"1 2 3 4 GBML . clone ( first_order = None , allow_unused = None , allow_nograd = None , adapt_transform = None ) Description Similar to MAML.clone() . Arguments first_order (bool, optional , default=None) - Whether the clone uses first- or second-order updates. Defaults to self.first_order. allow_unused (bool, optional , default=None) - Whether to allow differentiation of unused parameters. Defaults to self.allow_unused. allow_nograd (bool, optional , default=False) - Whether to allow adaptation with parameters that have requires_grad = False . Defaults to self.allow_nograd.","title":"clone"},{"location":"_build/pydocmd/docs/learn2learn.algorithms/#adapt_2","text":"1 GBML . adapt ( loss , first_order = None , allow_nograd = None , allow_unused = None ) Description Takes a gradient step on the loss and updates the cloned parameters in place. The parameters of the transform are only adapted if self.adapt_update is True . Arguments loss (Tensor) - Loss to minimize upon update. first_order (bool, optional , default=None) - Whether to use first- or second-order updates. Defaults to self.first_order. allow_unused (bool, optional , default=None) - Whether to allow differentiation of unused parameters. Defaults to self.allow_unused. allow_nograd (bool, optional , default=None) - Whether to allow adaptation with parameters that have requires_grad = False . Defaults to self.allow_nograd.","title":"adapt"},{"location":"_build/pydocmd/docs/learn2learn.algorithms/#lightningmaml","text":"1 LightningMAML ( model , loss = None , ** kwargs ) [Source] Description A PyTorch Lightning module for MAML. Arguments model (Module) - A PyTorch nn.Module. loss (Function, optional , default=CrossEntropyLoss) - Loss function which maps the cost of the events. ways (int, optional , default=5) - Number of classes in a task. shots (int, optional , default=1) - Number of samples for adaptation. adaptation_steps (int, optional , default=1) - Number of steps for adapting to new task. lr (float, optional , default=0.001) - Learning rate of meta training. adaptation_lr (float, optional , default=0.1) - Learning rate for fast adaptation. scheduler_step (int, optional , default=20) - Decay interval for lr . scheduler_decay (float, optional , default=1.0) - Decay rate for lr . References Finn et al. 2017. \"Model-Agnostic Meta-Learning for Fast Adaptation of Deep Networks.\" Example 1 2 3 4 5 6 tasksets = l2l . vision . benchmarks . get_tasksets ( 'omniglot' ) model = l2l . vision . models . OmniglotFC ( 28 ** 2 , args . ways ) maml = LightningMAML ( classifier , adaptation_lr = 0.1 , ** dict_args ) episodic_data = EpisodicBatcher ( tasksets . train , tasksets . validation , tasksets . test ) trainer = pl . Trainer . from_argparse_args ( args ) trainer . fit ( maml , episodic_data )","title":"LightningMAML"},{"location":"_build/pydocmd/docs/learn2learn.algorithms/#lightninganil","text":"1 LightningANIL ( features , classifier , loss = None , ** kwargs ) [Source] Description A PyTorch Lightning module for ANIL. Arguments features (Module) - A nn.Module to extract features, which will not be adaptated. classifier (Module) - A nn.Module taking features, mapping them to classification. loss (Function, optional , default=CrossEntropyLoss) - Loss function which maps the cost of the events. ways (int, optional , default=5) - Number of classes in a task. shots (int, optional , default=1) - Number of samples for adaptation. adaptation_steps (int, optional , default=1) - Number of steps for adapting to new task. lr (float, optional , default=0.001) - Learning rate of meta training. adaptation_lr (float, optional , default=0.1) - Learning rate for fast adaptation. scheduler_step (int, optional , default=20) - Decay interval for lr . scheduler_decay (float, optional , default=1.0) - Decay rate for lr . References Raghu et al. 2020. \"Rapid Learning or Feature Reuse? Towards Understanding the Effectiveness of MAML\" Example 1 2 3 4 5 6 tasksets = l2l . vision . benchmarks . get_tasksets ( 'omniglot' ) model = l2l . vision . models . OmniglotFC ( 28 ** 2 , args . ways ) anil = LightningANIL ( model . features , model . classifier , adaptation_lr = 0.1 , ** dict_args ) episodic_data = EpisodicBatcher ( tasksets . train , tasksets . validation , tasksets . test ) trainer = pl . Trainer . from_argparse_args ( args ) trainer . fit ( anil , episodic_data )","title":"LightningANIL"},{"location":"_build/pydocmd/docs/learn2learn.algorithms/#lightningprototypicalnetworks","text":"1 LightningPrototypicalNetworks ( features , loss = None , ** kwargs ) [Source] Description A PyTorch Lightning module for Prototypical Networks. Arguments features (Module) - Feature extractor which classifies input tasks. loss (Function, optional , default=CrossEntropyLoss) - Loss function which maps the cost of the events. distance_metric (str, optional , default='euclidean') - Distance metric between samples. ['euclidean', 'cosine'] train_ways (int, optional , default=5) - Number of classes in for train tasks. train_shots (int, optional , default=1) - Number of support samples for train tasks. train_queries (int, optional , default=1) - Number of query samples for train tasks. test_ways (int, optional , default=5) - Number of classes in for test tasks. test_shots (int, optional , default=1) - Number of support samples for test tasks. test_queries (int, optional , default=1) - Number of query samples for test tasks. lr (float, optional , default=0.001) - Learning rate of meta training. scheduler_step (int, optional , default=20) - Decay interval for lr . scheduler_decay (float, optional , default=1.0) - Decay rate for lr . References Snell et al. 2017. \"Prototypical Networks for Few-shot Learning\" Example 1 2 3 4 5 6 tasksets = l2l . vision . benchmarks . get_tasksets ( 'mini-imagenet' ) features = Convnet () # init model protonet = LightningPrototypicalNetworks ( features , ** dict_args ) episodic_data = EpisodicBatcher ( tasksets . train , tasksets . validation , tasksets . test ) trainer = pl . Trainer . from_argparse_args ( args ) trainer . fit ( protonet , episodic_data )","title":"LightningPrototypicalNetworks"},{"location":"_build/pydocmd/docs/learn2learn.algorithms/#lightningmetaoptnet","text":"1 LightningMetaOptNet ( features , loss = None , ** kwargs ) [Source] Description A PyTorch Lightning module for MetaOptNet. Arguments features (Module) - Feature extractor which classifies input tasks. svm_C_reg (float, optional , default=0.1) - Regularization weight for SVM. svm_max_iters (int, optional , default=15) - Maximum number of iterations for SVM convergence. loss (Function, optional , default=CrossEntropyLoss) - Loss function which maps the cost of the events. train_ways (int, optional , default=5) - Number of classes in for train tasks. train_shots (int, optional , default=1) - Number of support samples for train tasks. train_queries (int, optional , default=1) - Number of query samples for train tasks. test_ways (int, optional , default=5) - Number of classes in for test tasks. test_shots (int, optional , default=1) - Number of support samples for test tasks. test_queries (int, optional , default=1) - Number of query samples for test tasks. lr (float, optional , default=0.001) - Learning rate of meta training. scheduler_step (int, optional , default=20) - Decay interval for lr . scheduler_decay (float, optional , default=1.0) - Decay rate for lr . References Lee et al. 2019. \"Meta-Learning with Differentiable Convex Optimization\" Example 1 2 3 4 5 6 tasksets = l2l . vision . benchmarks . get_tasksets ( 'mini-imagenet' ) features = Convnet () # init model metaoptnet = LightningMetaOptNet ( features , ** dict_args ) episodic_data = EpisodicBatcher ( tasksets . train , tasksets . validation , tasksets . test ) trainer = pl . Trainer . from_argparse_args ( args ) trainer . fit ( metaoptnet , episodic_data )","title":"LightningMetaOptNet"},{"location":"_build/pydocmd/docs/learn2learn.data/","text":"learn2learn.data \u00b6 A set of utilities for data & tasks loading, preprocessing, and sampling. MetaDataset \u00b6 1 MetaDataset ( * args , ** kwds ) Description Wraps a classification dataset to enable fast indexing of samples within classes. This class exposes two attributes specific to the wrapped dataset: labels_to_indices : maps a class label to a list of sample indices with that label. indices_to_labels : maps a sample index to its corresponding class label. Those dictionary attributes are often used to quickly create few-shot classification tasks. They can be passed as arguments upon instantiation, or automatically built on-the-fly. If the wrapped dataset has an attribute _bookkeeping_path , then the built attributes will be cached on disk and reloaded upon the next instantiation. This caching strategy is useful for large datasets (e.g. ImageNet-1k) where the first instantiation can take several hours. Note that if only one of labels_to_indices or indices_to_labels is provided, this class builds the other one from it. Arguments dataset (Dataset) - A torch Dataset. labels_to_indices (dict, optional , default=None) - A dictionary mapping labels to the indices of their samples. indices_to_labels (dict, optional , default=None) - A dictionary mapping sample indices to their corresponding label. Example 1 2 mnist = torchvision . datasets . MNIST ( root = \"/tmp/mnist\" , train = True ) mnist = l2l . data . MetaDataset ( mnist ) UnionMetaDataset \u00b6 1 UnionMetaDataset ( * args , ** kwds ) Description Takes multiple MetaDataests and constructs their union. Note: The labels of all datasets are remapped to be in consecutive order. (i.e. the same label in two datasets will be to two different labels in the union) Arguments datasets (list of Dataset) - A list of torch Datasets. Example 1 2 3 4 5 6 7 8 train = torchvision . datasets . CIFARFS ( root = \"/tmp/mnist\" , mode = \"train\" ) train = l2l . data . MetaDataset ( train ) valid = torchvision . datasets . CIFARFS ( root = \"/tmp/mnist\" , mode = \"validation\" ) valid = l2l . data . MetaDataset ( valid ) test = torchvision . datasets . CIFARFS ( root = \"/tmp/mnist\" , mode = \"test\" ) test = l2l . data . MetaDataset ( test ) union = UnionMetaDataset ([ train , valid , test ]) assert len ( union . labels ) == 100 FilteredMetaDataset \u00b6 1 FilteredMetaDataset ( * args , ** kwds ) Description Takes in a MetaDataset and filters it to only include a subset of its labels. Note: The labels of all datasets are not remapped. (i.e. the labels from the original dataset are retained) Arguments datasets (Dataset) - A torch Datasets. labels (list of ints) - A list of labels to keep. Example 1 2 3 4 train = torchvision . datasets . CIFARFS ( root = \"/tmp/mnist\" , mode = \"train\" ) train = l2l . data . MetaDataset ( train ) filtered = FilteredMetaDataset ( train , [ 4 , 8 , 2 , 1 , 9 ]) assert len ( filtered . labels ) == 5 TaskDataset \u00b6 1 TaskDataset ( dataset , task_transforms = None , num_tasks =- 1 , task_collate = None ) [Source] Description Creates a set of tasks from a given Dataset. In addition to the Dataset, TaskDataset accepts a list of task transformations ( task_transforms ) which define the kind of tasks sampled from the dataset. The tasks are lazily sampled upon indexing (or calling the .sample() method), and their descriptions cached for later use. If num_tasks is -1, the TaskDataset will not cache task descriptions and instead continuously resample new ones. In this case, the length of the TaskDataset is set to 1. For more information on tasks and task descriptions, please refer to the documentation of task transforms. Arguments dataset (Dataset) - Dataset of data to compute tasks. task_transforms (list, optional , default=None) - List of task transformations. num_tasks (int, optional , default=-1) - Number of tasks to generate. Example 1 2 3 4 5 6 7 8 9 dataset = l2l . data . MetaDataset ( MyDataset ()) transforms = [ l2l . data . transforms . NWays ( dataset , n = 5 ), l2l . data . transforms . KShots ( dataset , k = 1 ), l2l . data . transforms . LoadData ( dataset ), ] taskset = TaskDataset ( dataset , transforms , num_tasks = 20000 ) for task in taskset : X , y = task learn2learn.data.transforms \u00b6 Description Collection of general task transformations. A task transformation is an object that implements the callable interface. (Either a function or an object that implements the __call__ special method.) Each transformation is called on a task description, which consists of a list of DataDescription with attributes index and transforms , where index corresponds to the index of single data sample inthe dataset, and transforms is a list of transformations that will be applied to the sample. Each transformation must return a new task description. At first, the task description contains all samples from the dataset. A task transform takes this task description list and modifies it such that a particular task is created. For example, the NWays task transform filters data samples from the task description such that remaining ones belong to a random subset of all classes available. (The size of the subset is controlled via the class's n argument.) On the other hand, the LoadData task transform simply appends a call to load the actual data from the dataset to the list of transformations of each sample. To create a task from a task description, the TaskDataset applies each sample's list of transform s in order. Then, all samples are collated via the TaskDataset 's collate function. LoadData \u00b6 1 LoadData ( dataset ) [Source] Description Loads a sample from the dataset given its index. Arguments dataset (Dataset) - The dataset from which to load the sample. NWays \u00b6 1 NWays ( dataset , n = 2 ) [Source] Description Keeps samples from N random labels present in the task description. Arguments dataset (Dataset) - The dataset from which to load the sample. n (int, optional , default=2) - Number of labels to sample from the task description's labels. KShots \u00b6 1 KShots ( dataset , k = 1 , replacement = False ) [Source] Description Keeps K samples for each present labels. Arguments dataset (Dataset) - The dataset from which to load the sample. k (int, optional , default=1) - The number of samples per label. replacement (bool, optional , default=False) - Whether to sample with replacement. FilterLabels \u00b6 1 FilterLabels ( dataset , labels ) [Source] Description Removes samples that do not belong to the given set of labels. Arguments dataset (Dataset) - The dataset from which to load the sample. labels (list) - The list of labels to include. FusedNWaysKShots \u00b6 1 FusedNWaysKShots ( dataset , n = 2 , k = 1 , replacement = False , filter_labels = None ) [Source] Description Efficient implementation of FilterLabels, NWays, and KShots. Arguments dataset (Dataset) - The dataset from which to load the sample. n (int, optional , default=2) - Number of labels to sample from the task description's labels. k (int, optional , default=1) - The number of samples per label. replacement (bool, optional , default=False) - Whether to sample shots with replacement. filter_labels (list, optional , default=None) - The list of labels to include. Defaults to all labels in the dataset. RemapLabels \u00b6 1 RemapLabels ( dataset , shuffle = True ) [Source] Description Given samples from K classes, maps the labels to 0, ..., K. Arguments dataset (Dataset) - The dataset from which to load the sample. ConsecutiveLabels \u00b6 1 ConsecutiveLabels ( dataset ) [Source] Description Re-orders the samples in the task description such that they are sorted in consecutive order. Note: when used before RemapLabels , the labels will be homogeneously clustered, but in no specific order. Arguments dataset (Dataset) - The dataset from which to load the sample. learn2learn.data.utils \u00b6 OnDeviceDataset \u00b6 1 OnDeviceDataset ( * args , ** kwds ) [Source] Description Converts an entire dataset into a TensorDataset, and optionally puts it on the desired device. Useful to accelerate training with relatively small datasets. If the device is cpu and cuda is available, the TensorDataset will live in pinned memory. Arguments dataset (Dataset) - Dataset to put on a device. device (torch.device, optional , default=None) - Device of dataset. Defaults to CPU. transform (transform, optional , default=None) - Transform to apply on the first variate of the dataset's samples X. Example 1 2 3 4 5 6 7 8 transforms = transforms . Compose ([ transforms . ToTensor (), transforms . Normalize (( 0.1307 ,), ( 0.3081 ,)), lambda x : x . view ( 1 , 28 , 28 ), ]) mnist = MNIST ( '~/data' ) mnist_ondevice = OnDeviceDataset ( mnist , device = 'cuda' , transform = transforms ) mnist_meta = MetaDataset ( mnist_ondevice ) InfiniteIterator \u00b6 1 InfiniteIterator ( dataloader ) [Source] Description Infinitely loops over a given iterator. Arguments dataloader (iterator) - Iterator to loop over. Example 1 2 3 4 dataloader = DataLoader ( dataset , shuffle = True , batch_size = 32 ) inf_dataloader = InfiniteIterator ( dataloader ) for iteration in range ( 10000 ): # guaranteed to reach 10,000 regardless of len(dataloader) X , y = next ( inf_dataloader ) partition_task \u00b6 1 partition_task ( data , labels , shots = 1 ) [Source] Description Partitions a classification task into support and query sets. The support set will contain shots samples per class, the query will take the remaining samples. Assumes each class in labels is associated with the same number of samples in data . Arguments data (Tensor) - Data to be partitioned into support and query. labels (Tensor) - Labels of each data sample, used for partitioning. shots (int, optional , default=1) - Number of data samples per class in the support set. Example 1 2 X , y = taskset . sample () ( X_support , y_support ), ( X_query , y_query ) = partition_task ( X , y , shots = 5 )","title":"learn2learn.data"},{"location":"_build/pydocmd/docs/learn2learn.data/#learn2learndata","text":"A set of utilities for data & tasks loading, preprocessing, and sampling.","title":"learn2learn.data"},{"location":"_build/pydocmd/docs/learn2learn.data/#metadataset","text":"1 MetaDataset ( * args , ** kwds ) Description Wraps a classification dataset to enable fast indexing of samples within classes. This class exposes two attributes specific to the wrapped dataset: labels_to_indices : maps a class label to a list of sample indices with that label. indices_to_labels : maps a sample index to its corresponding class label. Those dictionary attributes are often used to quickly create few-shot classification tasks. They can be passed as arguments upon instantiation, or automatically built on-the-fly. If the wrapped dataset has an attribute _bookkeeping_path , then the built attributes will be cached on disk and reloaded upon the next instantiation. This caching strategy is useful for large datasets (e.g. ImageNet-1k) where the first instantiation can take several hours. Note that if only one of labels_to_indices or indices_to_labels is provided, this class builds the other one from it. Arguments dataset (Dataset) - A torch Dataset. labels_to_indices (dict, optional , default=None) - A dictionary mapping labels to the indices of their samples. indices_to_labels (dict, optional , default=None) - A dictionary mapping sample indices to their corresponding label. Example 1 2 mnist = torchvision . datasets . MNIST ( root = \"/tmp/mnist\" , train = True ) mnist = l2l . data . MetaDataset ( mnist )","title":"MetaDataset"},{"location":"_build/pydocmd/docs/learn2learn.data/#unionmetadataset","text":"1 UnionMetaDataset ( * args , ** kwds ) Description Takes multiple MetaDataests and constructs their union. Note: The labels of all datasets are remapped to be in consecutive order. (i.e. the same label in two datasets will be to two different labels in the union) Arguments datasets (list of Dataset) - A list of torch Datasets. Example 1 2 3 4 5 6 7 8 train = torchvision . datasets . CIFARFS ( root = \"/tmp/mnist\" , mode = \"train\" ) train = l2l . data . MetaDataset ( train ) valid = torchvision . datasets . CIFARFS ( root = \"/tmp/mnist\" , mode = \"validation\" ) valid = l2l . data . MetaDataset ( valid ) test = torchvision . datasets . CIFARFS ( root = \"/tmp/mnist\" , mode = \"test\" ) test = l2l . data . MetaDataset ( test ) union = UnionMetaDataset ([ train , valid , test ]) assert len ( union . labels ) == 100","title":"UnionMetaDataset"},{"location":"_build/pydocmd/docs/learn2learn.data/#filteredmetadataset","text":"1 FilteredMetaDataset ( * args , ** kwds ) Description Takes in a MetaDataset and filters it to only include a subset of its labels. Note: The labels of all datasets are not remapped. (i.e. the labels from the original dataset are retained) Arguments datasets (Dataset) - A torch Datasets. labels (list of ints) - A list of labels to keep. Example 1 2 3 4 train = torchvision . datasets . CIFARFS ( root = \"/tmp/mnist\" , mode = \"train\" ) train = l2l . data . MetaDataset ( train ) filtered = FilteredMetaDataset ( train , [ 4 , 8 , 2 , 1 , 9 ]) assert len ( filtered . labels ) == 5","title":"FilteredMetaDataset"},{"location":"_build/pydocmd/docs/learn2learn.data/#taskdataset","text":"1 TaskDataset ( dataset , task_transforms = None , num_tasks =- 1 , task_collate = None ) [Source] Description Creates a set of tasks from a given Dataset. In addition to the Dataset, TaskDataset accepts a list of task transformations ( task_transforms ) which define the kind of tasks sampled from the dataset. The tasks are lazily sampled upon indexing (or calling the .sample() method), and their descriptions cached for later use. If num_tasks is -1, the TaskDataset will not cache task descriptions and instead continuously resample new ones. In this case, the length of the TaskDataset is set to 1. For more information on tasks and task descriptions, please refer to the documentation of task transforms. Arguments dataset (Dataset) - Dataset of data to compute tasks. task_transforms (list, optional , default=None) - List of task transformations. num_tasks (int, optional , default=-1) - Number of tasks to generate. Example 1 2 3 4 5 6 7 8 9 dataset = l2l . data . MetaDataset ( MyDataset ()) transforms = [ l2l . data . transforms . NWays ( dataset , n = 5 ), l2l . data . transforms . KShots ( dataset , k = 1 ), l2l . data . transforms . LoadData ( dataset ), ] taskset = TaskDataset ( dataset , transforms , num_tasks = 20000 ) for task in taskset : X , y = task","title":"TaskDataset"},{"location":"_build/pydocmd/docs/learn2learn.data/#learn2learndatatransforms","text":"Description Collection of general task transformations. A task transformation is an object that implements the callable interface. (Either a function or an object that implements the __call__ special method.) Each transformation is called on a task description, which consists of a list of DataDescription with attributes index and transforms , where index corresponds to the index of single data sample inthe dataset, and transforms is a list of transformations that will be applied to the sample. Each transformation must return a new task description. At first, the task description contains all samples from the dataset. A task transform takes this task description list and modifies it such that a particular task is created. For example, the NWays task transform filters data samples from the task description such that remaining ones belong to a random subset of all classes available. (The size of the subset is controlled via the class's n argument.) On the other hand, the LoadData task transform simply appends a call to load the actual data from the dataset to the list of transformations of each sample. To create a task from a task description, the TaskDataset applies each sample's list of transform s in order. Then, all samples are collated via the TaskDataset 's collate function.","title":"learn2learn.data.transforms"},{"location":"_build/pydocmd/docs/learn2learn.data/#loaddata","text":"1 LoadData ( dataset ) [Source] Description Loads a sample from the dataset given its index. Arguments dataset (Dataset) - The dataset from which to load the sample.","title":"LoadData"},{"location":"_build/pydocmd/docs/learn2learn.data/#nways","text":"1 NWays ( dataset , n = 2 ) [Source] Description Keeps samples from N random labels present in the task description. Arguments dataset (Dataset) - The dataset from which to load the sample. n (int, optional , default=2) - Number of labels to sample from the task description's labels.","title":"NWays"},{"location":"_build/pydocmd/docs/learn2learn.data/#kshots","text":"1 KShots ( dataset , k = 1 , replacement = False ) [Source] Description Keeps K samples for each present labels. Arguments dataset (Dataset) - The dataset from which to load the sample. k (int, optional , default=1) - The number of samples per label. replacement (bool, optional , default=False) - Whether to sample with replacement.","title":"KShots"},{"location":"_build/pydocmd/docs/learn2learn.data/#filterlabels","text":"1 FilterLabels ( dataset , labels ) [Source] Description Removes samples that do not belong to the given set of labels. Arguments dataset (Dataset) - The dataset from which to load the sample. labels (list) - The list of labels to include.","title":"FilterLabels"},{"location":"_build/pydocmd/docs/learn2learn.data/#fusednwayskshots","text":"1 FusedNWaysKShots ( dataset , n = 2 , k = 1 , replacement = False , filter_labels = None ) [Source] Description Efficient implementation of FilterLabels, NWays, and KShots. Arguments dataset (Dataset) - The dataset from which to load the sample. n (int, optional , default=2) - Number of labels to sample from the task description's labels. k (int, optional , default=1) - The number of samples per label. replacement (bool, optional , default=False) - Whether to sample shots with replacement. filter_labels (list, optional , default=None) - The list of labels to include. Defaults to all labels in the dataset.","title":"FusedNWaysKShots"},{"location":"_build/pydocmd/docs/learn2learn.data/#remaplabels","text":"1 RemapLabels ( dataset , shuffle = True ) [Source] Description Given samples from K classes, maps the labels to 0, ..., K. Arguments dataset (Dataset) - The dataset from which to load the sample.","title":"RemapLabels"},{"location":"_build/pydocmd/docs/learn2learn.data/#consecutivelabels","text":"1 ConsecutiveLabels ( dataset ) [Source] Description Re-orders the samples in the task description such that they are sorted in consecutive order. Note: when used before RemapLabels , the labels will be homogeneously clustered, but in no specific order. Arguments dataset (Dataset) - The dataset from which to load the sample.","title":"ConsecutiveLabels"},{"location":"_build/pydocmd/docs/learn2learn.data/#learn2learndatautils","text":"","title":"learn2learn.data.utils"},{"location":"_build/pydocmd/docs/learn2learn.data/#ondevicedataset","text":"1 OnDeviceDataset ( * args , ** kwds ) [Source] Description Converts an entire dataset into a TensorDataset, and optionally puts it on the desired device. Useful to accelerate training with relatively small datasets. If the device is cpu and cuda is available, the TensorDataset will live in pinned memory. Arguments dataset (Dataset) - Dataset to put on a device. device (torch.device, optional , default=None) - Device of dataset. Defaults to CPU. transform (transform, optional , default=None) - Transform to apply on the first variate of the dataset's samples X. Example 1 2 3 4 5 6 7 8 transforms = transforms . Compose ([ transforms . ToTensor (), transforms . Normalize (( 0.1307 ,), ( 0.3081 ,)), lambda x : x . view ( 1 , 28 , 28 ), ]) mnist = MNIST ( '~/data' ) mnist_ondevice = OnDeviceDataset ( mnist , device = 'cuda' , transform = transforms ) mnist_meta = MetaDataset ( mnist_ondevice )","title":"OnDeviceDataset"},{"location":"_build/pydocmd/docs/learn2learn.data/#infiniteiterator","text":"1 InfiniteIterator ( dataloader ) [Source] Description Infinitely loops over a given iterator. Arguments dataloader (iterator) - Iterator to loop over. Example 1 2 3 4 dataloader = DataLoader ( dataset , shuffle = True , batch_size = 32 ) inf_dataloader = InfiniteIterator ( dataloader ) for iteration in range ( 10000 ): # guaranteed to reach 10,000 regardless of len(dataloader) X , y = next ( inf_dataloader )","title":"InfiniteIterator"},{"location":"_build/pydocmd/docs/learn2learn.data/#partition_task","text":"1 partition_task ( data , labels , shots = 1 ) [Source] Description Partitions a classification task into support and query sets. The support set will contain shots samples per class, the query will take the remaining samples. Assumes each class in labels is associated with the same number of samples in data . Arguments data (Tensor) - Data to be partitioned into support and query. labels (Tensor) - Labels of each data sample, used for partitioning. shots (int, optional , default=1) - Number of data samples per class in the support set. Example 1 2 X , y = taskset . sample () ( X_support , y_support ), ( X_query , y_query ) = partition_task ( X , y , shots = 5 )","title":"partition_task"},{"location":"_build/pydocmd/docs/learn2learn.gym/","text":"learn2learn.gym \u00b6 Environment, models, and other utilities related to reinforcement learning and OpenAI Gym. MetaEnv \u00b6 1 MetaEnv ( task = None ) [Source] Description Interface for l2l envs. Environments have a certain number of task specific parameters that uniquely identify the environment. Tasks are then a dictionary with the names of these parameters as keys and the values of these parameters as values. Environments must then implement functions to get, set and sample tasks. The flow is then 1 2 3 4 5 6 env = EnvClass () tasks = env . sample_tasks ( num_tasks ) for task in tasks : env . set_task ( task ) * training code here * ... Credit Adapted from Tristan Deleu and Jonas Rothfuss' implementations. AsyncVectorEnv \u00b6 1 AsyncVectorEnv ( env_fns , env = None ) [Source] Description Asynchronous vectorized environment for working with l2l MetaEnvs. Allows multiple environments to be run as separate processes. Credit Adapted from OpenAI and Tristan Deleu's implementations. learn2learn.gym.envs.mujoco \u00b6 HalfCheetahForwardBackwardEnv \u00b6 1 HalfCheetahForwardBackwardEnv ( task = None ) [Source] Description This environment requires the half-cheetah to learn to run forward or backward. At each time step the half-cheetah receives a signal composed of a control cost and a reward equal to its average velocity in the direction of the plane. The tasks are Bernoulli samples on {-1, 1} with probability 0.5, where -1 indicates the half-cheetah should move backward and +1 indicates the half-cheetah should move forward. The velocity is calculated as the distance (in the target direction) of the half-cheetah's torso position before and after taking the specified action divided by a small value dt. Credit Adapted from Jonas Rothfuss' implementation. References Finn et al. 2017. \"Model-Agnostic Meta-Learning for Fast Adaptation of Deep Networks.\" arXiv [cs.LG]. Rothfuss et al. 2018. \"ProMP: Proximal Meta-Policy Search.\" arXiv [cs.LG]. AntForwardBackwardEnv \u00b6 1 AntForwardBackwardEnv ( task = None ) [Source] Description This environment requires the ant to learn to run forward or backward. At each time step the ant receives a signal composed of a control cost and a reward equal to its average velocity in the direction of the plane. The tasks are Bernoulli samples on {-1, 1} with probability 0.5, where -1 indicates the ant should move backward and +1 indicates the ant should move forward. The velocity is calculated as the distance (in the direction of the plane) of the ant's torso position before and after taking the specified action divided by a small value dt. As noted in [1], a small positive bonus is added to the reward to stop the ant from prematurely ending the episode. Credit Adapted from Jonas Rothfuss' implementation. References Finn et al. 2017. \"Model-Agnostic Meta-Learning for Fast Adaptation of Deep Networks.\" arXiv [cs.LG]. Rothfuss et al. 2018. \"ProMP: Proximal Meta-Policy Search.\" arXiv [cs.LG]. AntDirectionEnv \u00b6 1 AntDirectionEnv ( task = None ) [Source] Description This environment requires the Ant to learn to run in a random direction in the XY plane. At each time step the ant receives a signal composed of a control cost and a reward equal to its average velocity in the direction of the plane. The tasks are 2d-arrays sampled uniformly along the unit circle. The target direction is indicated by the vector from the origin to the sampled point. The velocity is calculated as the distance (in the target direction) of the ant's torso position before and after taking the specified action divided by a small value dt. As noted in [1], a small positive bonus is added to the reward to stop the ant from prematurely ending the episode. Credit Adapted from Jonas Rothfuss' implementation. References Finn et al. 2017. \"Model-Agnostic Meta-Learning for Fast Adaptation of Deep Networks.\" arXiv [cs.LG]. Rothfuss et al. 2018. \"ProMP: Proximal Meta-Policy Search.\" arXiv [cs.LG]. HumanoidForwardBackwardEnv \u00b6 1 HumanoidForwardBackwardEnv ( task = None ) [Source] Description This environment requires the humanoid to learn to run forward or backward. At each time step the humanoid receives a signal composed of a control cost and a reward equal to its average velocity in the target direction. The tasks are Bernoulli samples on {-1, 1} with probability 0.5, where -1 indicates the humanoid should move backward and +1 indicates the humanoid should move forward. The velocity is calculated as the distance (in the target direction) of the humanoid's torso position before and after taking the specified action divided by a small value dt. Credit Adapted from Jonas Rothfuss' implementation. References Finn et al. 2017. \"Model-Agnostic Meta-Learning for Fast Adaptation of Deep Networks.\" arXiv [cs.LG]. Rothfuss et al. 2018. \"ProMP: Proximal Meta-Policy Search.\" arXiv [cs.LG]. HumanoidDirectionEnv \u00b6 1 HumanoidDirectionEnv ( task = None ) [Source] Description This environment requires the humanoid to learn to run in a random direction in the XY plane. At each time step the humanoid receives a signal composed of a control cost and a reward equal to its average velocity in the target direction. The tasks are 2d-arrays sampled uniformly along the unit circle. The target direction is indicated by the vector from the origin to the sampled point. The velocity is calculated as the distance (in the target direction) of the humanoid's torso position before and after taking the specified action divided by a small value dt. A small positive bonus is added to the reward to stop the humanoid from prematurely ending the episode. Credit Adapted from Jonas Rothfuss' implementation. References Finn et al. 2017. \"Model-Agnostic Meta-Learning for Fast Adaptation of Deep Networks.\" arXiv [cs.LG]. Rothfuss et al. 2018. \"ProMP: Proximal Meta-Policy Search.\" arXiv [cs.LG]. learn2learn.gym.envs.particles \u00b6 Particles2DEnv \u00b6 1 Particles2DEnv ( task = None ) [Source] Description Each task is defined by the location of the goal. A point mass receives a directional force and moves accordingly (clipped in [-0.1,0.1]). The reward is equal to the negative distance from the goal. Credit Adapted from Jonas Rothfuss' implementation. learn2learn.gym.envs.metaworld \u00b6 MetaWorldML1 \u00b6 1 MetaWorldML1 ( task_name , env_type = 'train' , n_goals = 50 , sample_all = False ) [Source] Description The ML1 Benchmark of Meta-World is focused on solving just one task on different object / goal configurations.This task can be either one of the following: 'reach', 'push' and 'pick-and-place'. The meta-training is performed on a set of 50 randomly chosen once initial object and goal positions. The meta-testing is performed on a held-out set of 10 new different configurations. The starting state of the robot arm is always fixed. The goal positions are not provided in the observation space, forcing the Sawyer robot arm to explore and adapt to the new goal through trial-and-error. This is considered a relatively easy problem for a meta-learning algorithm to solve and acts as a sanity check to a working implementation. For more information regarding this benchmark, please consult [1]. Credit Original implementation found in https://github.com/rlworkgroup/metaworld. References Yu, Tianhe, et al. \"Meta-world: A benchmark and evaluation for multi-task and meta reinforcement learning.\" arXiv preprint arXiv:1910.10897 (2019). MetaWorldML10 \u00b6 1 MetaWorldML10 ( env_type = 'train' , sample_all = False , task_name = None ) [Source] Description The ML10 Benchmark of Meta-World consists of 10 different tasks for meta-training and 5 new tasks for meta-testing. For each task there is only one goal that is randomly chosen once. The starting state and object position is random. The meta-training tasks have been intentionally selected to have a structural similarity to the test tasks. No task ID is provided in the observation space, meaning the meta-learning algorithm will need to identify each task from experience. This is a much harder problem than ML1 which probably requires more samples to train. For more information regarding this benchmark, please consult [1]. Credit Original implementation found in https://github.com/rlworkgroup/metaworld. References Yu, Tianhe, et al. \"Meta-world: A benchmark and evaluation for multi-task and meta reinforcement learning.\" arXiv preprint arXiv:1910.10897 (2019). MetaWorldML45 \u00b6 1 MetaWorldML45 ( env_type = 'train' , sample_all = False , task_name = None ) [Source] Description Similarly to ML10, this Benchmark has a variety of 45 different tasks for meta-training and 5 new tasks for meta-testing. For each task there is only one goal that is randomly chosen once. The starting state and object position is random. No task ID is provided in the observation space, meaning the meta-learning algorithm will need to identify each task from experience. This benchmark is significantly difficult to solve due to the diversity across tasks. For more information regarding this benchmark, please consult [1]. Credit Original implementation found in https://github.com/rlworkgroup/metaworld. References Yu, Tianhe, et al. \"Meta-world: A benchmark and evaluation for multi-task and meta reinforcement learning.\" arXiv preprint arXiv:1910.10897 (2019).","title":"learn2learn.gym"},{"location":"_build/pydocmd/docs/learn2learn.gym/#learn2learngym","text":"Environment, models, and other utilities related to reinforcement learning and OpenAI Gym.","title":"learn2learn.gym"},{"location":"_build/pydocmd/docs/learn2learn.gym/#metaenv","text":"1 MetaEnv ( task = None ) [Source] Description Interface for l2l envs. Environments have a certain number of task specific parameters that uniquely identify the environment. Tasks are then a dictionary with the names of these parameters as keys and the values of these parameters as values. Environments must then implement functions to get, set and sample tasks. The flow is then 1 2 3 4 5 6 env = EnvClass () tasks = env . sample_tasks ( num_tasks ) for task in tasks : env . set_task ( task ) * training code here * ... Credit Adapted from Tristan Deleu and Jonas Rothfuss' implementations.","title":"MetaEnv"},{"location":"_build/pydocmd/docs/learn2learn.gym/#asyncvectorenv","text":"1 AsyncVectorEnv ( env_fns , env = None ) [Source] Description Asynchronous vectorized environment for working with l2l MetaEnvs. Allows multiple environments to be run as separate processes. Credit Adapted from OpenAI and Tristan Deleu's implementations.","title":"AsyncVectorEnv"},{"location":"_build/pydocmd/docs/learn2learn.gym/#learn2learngymenvsmujoco","text":"","title":"learn2learn.gym.envs.mujoco"},{"location":"_build/pydocmd/docs/learn2learn.gym/#halfcheetahforwardbackwardenv","text":"1 HalfCheetahForwardBackwardEnv ( task = None ) [Source] Description This environment requires the half-cheetah to learn to run forward or backward. At each time step the half-cheetah receives a signal composed of a control cost and a reward equal to its average velocity in the direction of the plane. The tasks are Bernoulli samples on {-1, 1} with probability 0.5, where -1 indicates the half-cheetah should move backward and +1 indicates the half-cheetah should move forward. The velocity is calculated as the distance (in the target direction) of the half-cheetah's torso position before and after taking the specified action divided by a small value dt. Credit Adapted from Jonas Rothfuss' implementation. References Finn et al. 2017. \"Model-Agnostic Meta-Learning for Fast Adaptation of Deep Networks.\" arXiv [cs.LG]. Rothfuss et al. 2018. \"ProMP: Proximal Meta-Policy Search.\" arXiv [cs.LG].","title":"HalfCheetahForwardBackwardEnv"},{"location":"_build/pydocmd/docs/learn2learn.gym/#antforwardbackwardenv","text":"1 AntForwardBackwardEnv ( task = None ) [Source] Description This environment requires the ant to learn to run forward or backward. At each time step the ant receives a signal composed of a control cost and a reward equal to its average velocity in the direction of the plane. The tasks are Bernoulli samples on {-1, 1} with probability 0.5, where -1 indicates the ant should move backward and +1 indicates the ant should move forward. The velocity is calculated as the distance (in the direction of the plane) of the ant's torso position before and after taking the specified action divided by a small value dt. As noted in [1], a small positive bonus is added to the reward to stop the ant from prematurely ending the episode. Credit Adapted from Jonas Rothfuss' implementation. References Finn et al. 2017. \"Model-Agnostic Meta-Learning for Fast Adaptation of Deep Networks.\" arXiv [cs.LG]. Rothfuss et al. 2018. \"ProMP: Proximal Meta-Policy Search.\" arXiv [cs.LG].","title":"AntForwardBackwardEnv"},{"location":"_build/pydocmd/docs/learn2learn.gym/#antdirectionenv","text":"1 AntDirectionEnv ( task = None ) [Source] Description This environment requires the Ant to learn to run in a random direction in the XY plane. At each time step the ant receives a signal composed of a control cost and a reward equal to its average velocity in the direction of the plane. The tasks are 2d-arrays sampled uniformly along the unit circle. The target direction is indicated by the vector from the origin to the sampled point. The velocity is calculated as the distance (in the target direction) of the ant's torso position before and after taking the specified action divided by a small value dt. As noted in [1], a small positive bonus is added to the reward to stop the ant from prematurely ending the episode. Credit Adapted from Jonas Rothfuss' implementation. References Finn et al. 2017. \"Model-Agnostic Meta-Learning for Fast Adaptation of Deep Networks.\" arXiv [cs.LG]. Rothfuss et al. 2018. \"ProMP: Proximal Meta-Policy Search.\" arXiv [cs.LG].","title":"AntDirectionEnv"},{"location":"_build/pydocmd/docs/learn2learn.gym/#humanoidforwardbackwardenv","text":"1 HumanoidForwardBackwardEnv ( task = None ) [Source] Description This environment requires the humanoid to learn to run forward or backward. At each time step the humanoid receives a signal composed of a control cost and a reward equal to its average velocity in the target direction. The tasks are Bernoulli samples on {-1, 1} with probability 0.5, where -1 indicates the humanoid should move backward and +1 indicates the humanoid should move forward. The velocity is calculated as the distance (in the target direction) of the humanoid's torso position before and after taking the specified action divided by a small value dt. Credit Adapted from Jonas Rothfuss' implementation. References Finn et al. 2017. \"Model-Agnostic Meta-Learning for Fast Adaptation of Deep Networks.\" arXiv [cs.LG]. Rothfuss et al. 2018. \"ProMP: Proximal Meta-Policy Search.\" arXiv [cs.LG].","title":"HumanoidForwardBackwardEnv"},{"location":"_build/pydocmd/docs/learn2learn.gym/#humanoiddirectionenv","text":"1 HumanoidDirectionEnv ( task = None ) [Source] Description This environment requires the humanoid to learn to run in a random direction in the XY plane. At each time step the humanoid receives a signal composed of a control cost and a reward equal to its average velocity in the target direction. The tasks are 2d-arrays sampled uniformly along the unit circle. The target direction is indicated by the vector from the origin to the sampled point. The velocity is calculated as the distance (in the target direction) of the humanoid's torso position before and after taking the specified action divided by a small value dt. A small positive bonus is added to the reward to stop the humanoid from prematurely ending the episode. Credit Adapted from Jonas Rothfuss' implementation. References Finn et al. 2017. \"Model-Agnostic Meta-Learning for Fast Adaptation of Deep Networks.\" arXiv [cs.LG]. Rothfuss et al. 2018. \"ProMP: Proximal Meta-Policy Search.\" arXiv [cs.LG].","title":"HumanoidDirectionEnv"},{"location":"_build/pydocmd/docs/learn2learn.gym/#learn2learngymenvsparticles","text":"","title":"learn2learn.gym.envs.particles"},{"location":"_build/pydocmd/docs/learn2learn.gym/#particles2denv","text":"1 Particles2DEnv ( task = None ) [Source] Description Each task is defined by the location of the goal. A point mass receives a directional force and moves accordingly (clipped in [-0.1,0.1]). The reward is equal to the negative distance from the goal. Credit Adapted from Jonas Rothfuss' implementation.","title":"Particles2DEnv"},{"location":"_build/pydocmd/docs/learn2learn.gym/#learn2learngymenvsmetaworld","text":"","title":"learn2learn.gym.envs.metaworld"},{"location":"_build/pydocmd/docs/learn2learn.gym/#metaworldml1","text":"1 MetaWorldML1 ( task_name , env_type = 'train' , n_goals = 50 , sample_all = False ) [Source] Description The ML1 Benchmark of Meta-World is focused on solving just one task on different object / goal configurations.This task can be either one of the following: 'reach', 'push' and 'pick-and-place'. The meta-training is performed on a set of 50 randomly chosen once initial object and goal positions. The meta-testing is performed on a held-out set of 10 new different configurations. The starting state of the robot arm is always fixed. The goal positions are not provided in the observation space, forcing the Sawyer robot arm to explore and adapt to the new goal through trial-and-error. This is considered a relatively easy problem for a meta-learning algorithm to solve and acts as a sanity check to a working implementation. For more information regarding this benchmark, please consult [1]. Credit Original implementation found in https://github.com/rlworkgroup/metaworld. References Yu, Tianhe, et al. \"Meta-world: A benchmark and evaluation for multi-task and meta reinforcement learning.\" arXiv preprint arXiv:1910.10897 (2019).","title":"MetaWorldML1"},{"location":"_build/pydocmd/docs/learn2learn.gym/#metaworldml10","text":"1 MetaWorldML10 ( env_type = 'train' , sample_all = False , task_name = None ) [Source] Description The ML10 Benchmark of Meta-World consists of 10 different tasks for meta-training and 5 new tasks for meta-testing. For each task there is only one goal that is randomly chosen once. The starting state and object position is random. The meta-training tasks have been intentionally selected to have a structural similarity to the test tasks. No task ID is provided in the observation space, meaning the meta-learning algorithm will need to identify each task from experience. This is a much harder problem than ML1 which probably requires more samples to train. For more information regarding this benchmark, please consult [1]. Credit Original implementation found in https://github.com/rlworkgroup/metaworld. References Yu, Tianhe, et al. \"Meta-world: A benchmark and evaluation for multi-task and meta reinforcement learning.\" arXiv preprint arXiv:1910.10897 (2019).","title":"MetaWorldML10"},{"location":"_build/pydocmd/docs/learn2learn.gym/#metaworldml45","text":"1 MetaWorldML45 ( env_type = 'train' , sample_all = False , task_name = None ) [Source] Description Similarly to ML10, this Benchmark has a variety of 45 different tasks for meta-training and 5 new tasks for meta-testing. For each task there is only one goal that is randomly chosen once. The starting state and object position is random. No task ID is provided in the observation space, meaning the meta-learning algorithm will need to identify each task from experience. This benchmark is significantly difficult to solve due to the diversity across tasks. For more information regarding this benchmark, please consult [1]. Credit Original implementation found in https://github.com/rlworkgroup/metaworld. References Yu, Tianhe, et al. \"Meta-world: A benchmark and evaluation for multi-task and meta reinforcement learning.\" arXiv preprint arXiv:1910.10897 (2019).","title":"MetaWorldML45"},{"location":"_build/pydocmd/docs/learn2learn/","text":"learn2learn \u00b6 clone_module \u00b6 1 clone_module ( module , memo = None ) [Source] Description Creates a copy of a module, whose parameters/buffers/submodules are created using PyTorch's torch.clone(). This implies that the computational graph is kept, and you can compute the derivatives of the new modules' parameters w.r.t the original parameters. Arguments module (Module) - Module to be cloned. Return (Module) - The cloned module. Example 1 2 3 4 net = nn . Sequential ( Linear ( 20 , 10 ), nn . ReLU (), nn . Linear ( 10 , 2 )) clone = clone_module ( net ) error = loss ( clone ( X ), y ) error . backward () # Gradients are back-propagate all the way to net. detach_module \u00b6 1 detach_module ( module ) [Source] Description Detaches all parameters/buffers of a previously cloned module from its computational graph. Note: detach works in-place, so it does not return a copy. Arguments module (Module) - Module to be detached. Example 1 2 3 4 5 net = nn . Sequential ( Linear ( 20 , 10 ), nn . ReLU (), nn . Linear ( 10 , 2 )) clone = clone_module ( net ) detach_module ( clone ) error = loss ( clone ( X ), y ) error . backward () # Gradients are back-propagate on clone, not net. update_module \u00b6 1 update_module ( module , updates = None , memo = None ) [Source] Description Updates the parameters of a module in-place, in a way that preserves differentiability. The parameters of the module are swapped with their update values, according to: p \\gets p + u, where p is the parameter, and u is its corresponding update. Arguments module (Module) - The module to update. updates (list, optional , default=None) - A list of gradients for each parameter of the model. If None, will use the tensors in .update attributes. Example 1 2 3 4 5 6 7 8 error = loss ( model ( X ), y ) grads = torch . autograd . grad ( error , model . parameters (), create_graph = True , ) updates = [ - lr * g for g in grads ] l2l . update_module ( model , updates = updates ) magic_box \u00b6 1 magic_box ( x ) [Source] Description The magic box operator, which evaluates to 1 but whose gradient is dx : \\boxdot (x) = \\exp(x - \\bot(x)) where \\bot is the stop-gradient (or detach) operator. This operator is useful when computing higher-order derivatives of stochastic graphs. For more informations, please refer to the DiCE paper. (Reference 1) References Foerster et al. 2018. \"DiCE: The Infinitely Differentiable Monte-Carlo Estimator.\" arXiv. Arguments x (Variable) - Variable to transform. Return (Variable) - Tensor of 1, but it's gradient is the gradient of x. Example 1 2 loss = ( magic_box ( cum_log_probs ) * advantages ) . mean () # loss is the mean advantage loss . backward ()","title":"learn2learn"},{"location":"_build/pydocmd/docs/learn2learn/#learn2learn","text":"","title":"learn2learn"},{"location":"_build/pydocmd/docs/learn2learn/#clone_module","text":"1 clone_module ( module , memo = None ) [Source] Description Creates a copy of a module, whose parameters/buffers/submodules are created using PyTorch's torch.clone(). This implies that the computational graph is kept, and you can compute the derivatives of the new modules' parameters w.r.t the original parameters. Arguments module (Module) - Module to be cloned. Return (Module) - The cloned module. Example 1 2 3 4 net = nn . Sequential ( Linear ( 20 , 10 ), nn . ReLU (), nn . Linear ( 10 , 2 )) clone = clone_module ( net ) error = loss ( clone ( X ), y ) error . backward () # Gradients are back-propagate all the way to net.","title":"clone_module"},{"location":"_build/pydocmd/docs/learn2learn/#detach_module","text":"1 detach_module ( module ) [Source] Description Detaches all parameters/buffers of a previously cloned module from its computational graph. Note: detach works in-place, so it does not return a copy. Arguments module (Module) - Module to be detached. Example 1 2 3 4 5 net = nn . Sequential ( Linear ( 20 , 10 ), nn . ReLU (), nn . Linear ( 10 , 2 )) clone = clone_module ( net ) detach_module ( clone ) error = loss ( clone ( X ), y ) error . backward () # Gradients are back-propagate on clone, not net.","title":"detach_module"},{"location":"_build/pydocmd/docs/learn2learn/#update_module","text":"1 update_module ( module , updates = None , memo = None ) [Source] Description Updates the parameters of a module in-place, in a way that preserves differentiability. The parameters of the module are swapped with their update values, according to: p \\gets p + u, where p is the parameter, and u is its corresponding update. Arguments module (Module) - The module to update. updates (list, optional , default=None) - A list of gradients for each parameter of the model. If None, will use the tensors in .update attributes. Example 1 2 3 4 5 6 7 8 error = loss ( model ( X ), y ) grads = torch . autograd . grad ( error , model . parameters (), create_graph = True , ) updates = [ - lr * g for g in grads ] l2l . update_module ( model , updates = updates )","title":"update_module"},{"location":"_build/pydocmd/docs/learn2learn/#magic_box","text":"1 magic_box ( x ) [Source] Description The magic box operator, which evaluates to 1 but whose gradient is dx : \\boxdot (x) = \\exp(x - \\bot(x)) where \\bot is the stop-gradient (or detach) operator. This operator is useful when computing higher-order derivatives of stochastic graphs. For more informations, please refer to the DiCE paper. (Reference 1) References Foerster et al. 2018. \"DiCE: The Infinitely Differentiable Monte-Carlo Estimator.\" arXiv. Arguments x (Variable) - Variable to transform. Return (Variable) - Tensor of 1, but it's gradient is the gradient of x. Example 1 2 loss = ( magic_box ( cum_log_probs ) * advantages ) . mean () # loss is the mean advantage loss . backward ()","title":"magic_box"},{"location":"_build/pydocmd/docs/learn2learn.nn/","text":"learn2learn.nn \u00b6 Additional torch.nn.Module s frequently used for meta-learning. Lambda \u00b6 1 Lambda ( lmb ) [Source] Description Utility class to create a wrapper based on a lambda function. Arguments lmb (callable) - The function to call in the forward pass. Example 1 2 3 4 mean23 = Lambda ( lambda x : x . mean ( dim = [ 2 , 3 ])) # mean23 is a Module x = features ( img ) x = mean23 ( x ) x = x . flatten () Flatten \u00b6 1 Flatten () [Source] Description Utility Module to flatten inputs to (batch_size, -1) shape. Example 1 2 3 4 flatten = Flatten () x = torch . randn ( 5 , 3 , 32 , 32 ) x = flatten ( x ) print ( x . shape ) # (5, 3072) Scale \u00b6 1 Scale ( shape , alpha = 1.0 ) [Source] Description A per-parameter scaling factor with learnable parameter. Arguments shape (int or tuple) - The shape of the scaling matrix. alpha (float, optional , default=1.0) - Initial value for the scaling factor. Example 1 2 3 x = torch . ones ( 3 ) scale = Scale ( x . shape , alpha = 0.5 ) print ( scale ( x )) # [.5, .5, .5] PrototypicalClassifier \u00b6 1 2 3 4 PrototypicalClassifier ( support = None , labels = None , distance = 'euclidean' , normalize = False ) [Source] Description A module for the differentiable nearest neighbour classifier of Prototypical Networks. Arguments support (Tensor, optional , default=None) - Tensor of support features. labels (Tensor, optional , default=None) - Labels corresponding to the support features. distance (str, optional , default='euclidean') - Distance metric between samples. ['euclidean', 'cosine'] normalize (bool, optional , default=False) - Whether to normalize the inputs. Defaults to True when distance='cosine'. References Snell et al. 2017. \"Prototypical Networks for Few-shot Learning\" Example 1 2 3 4 5 classifier = PrototypicalClassifier () support = features ( support_data ) classifier . fit_ ( support , labels ) query = features ( query_data ) preds = classifier ( query ) SVClassifier \u00b6 1 2 3 4 5 6 SVClassifier ( support = None , labels = None , ways = None , normalize = False , C_reg = 0.1 , max_iters = 15 ) [Source] Description A module for the differentiable SVM classifier of MetaOptNet. Arguments support (Tensor, optional , default=None) - Tensor of support features. labels (Tensor, optional , default=None) - Labels corresponding to the support features. ways (str, optional , default=None) - Number of classes in the task. normalize (bool, optional , default=False) - Whether to normalize the inputs. C_reg (float, optional , default=0.1) - Regularization weight for SVM. max_iters (int, optional , default=15) - Maximum number of iterations for SVM convergence. References Lee et al. 2019. \"Prototypical Networks for Few-shot Learning\" Example 1 2 3 4 5 classifier = SVMClassifier () support = features ( support_data ) classifier . fit_ ( support , labels ) query = features ( query_data ) preds = classifier ( query ) KroneckerLinear \u00b6 1 KroneckerLinear ( n , m , bias = True , psd = False , device = None ) [Source] Description A linear transformation whose parameters are expressed as a Kronecker product. This Module maps an input vector x \\in \\mathbb{R}^{nm} to y = Ax + b such that: A = R^\\top \\otimes L, where L \\in \\mathbb{R}^{n \\times n} and R \\in \\mathbb{R}^{m \\times m} are the learnable Kronecker factors. This implementation can reduce the memory requirement for large linear mapping from \\mathcal{O}(n^2 \\cdot m^2) to \\mathcal{O}(n^2 + m^2) , but forces y \\in \\mathbb{R}^{nm} . The matrix A is initialized as the identity, and the bias as a zero vector. Arguments n (int) - Dimensionality of the left Kronecker factor. m (int) - Dimensionality of the right Kronecker factor. bias (bool, optional , default=True) - Whether to include the bias term. psd (bool, optional , default=False) - Forces the matrix A to be positive semi-definite if True. device (device, optional , default=None) - The device on which to instantiate the Module. References Jose et al. 2018. \"Kronecker recurrent units\". Arnold et al. 2019. \"When MAML can adapt fast and how to assist when it cannot\". Example 1 2 3 4 5 m , n = 2 , 3 x = torch . randn ( 6 ) kronecker = KroneckerLinear ( n , m ) y = kronecker ( x ) y . shape # (6, ) KroneckerRNN \u00b6 1 KroneckerRNN ( n , m , bias = True , sigma = None ) [Source] Description Implements a recurrent neural network whose matrices are parameterized via their Kronecker factors. (See KroneckerLinear for details.) Arguments n (int) - Dimensionality of the left Kronecker factor. m (int) - Dimensionality of the right Kronecker factor. bias (bool, optional , default=True) - Whether to include the bias term. sigma (callable, optional , default=None) - The activation function. References Jose et al. 2018. \"Kronecker recurrent units\". Example 1 2 3 4 5 6 m , n = 2 , 3 x = torch . randn ( 6 ) h = torch . randn ( 6 ) kronecker = KroneckerRNN ( n , m ) y , new_h = kronecker ( x , h ) y . shape # (6, ) KroneckerLSTM \u00b6 1 KroneckerLSTM ( n , m , bias = True , sigma = None ) [Source] Description Implements an LSTM using a factorization similar to the one of KroneckerLinear . Arguments n (int) - Dimensionality of the left Kronecker factor. m (int) - Dimensionality of the right Kronecker factor. bias (bool, optional , default=True) - Whether to include the bias term. sigma (callable, optional , default=None) - The activation function. References Jose et al. 2018. \"Kronecker recurrent units\". Example 1 2 3 4 5 6 m , n = 2 , 3 x = torch . randn ( 6 ) h = torch . randn ( 6 ) kronecker = KroneckerLSTM ( n , m ) y , new_h = kronecker ( x , h ) y . shape # (6, )","title":"learn2learn.nn"},{"location":"_build/pydocmd/docs/learn2learn.nn/#learn2learnnn","text":"Additional torch.nn.Module s frequently used for meta-learning.","title":"learn2learn.nn"},{"location":"_build/pydocmd/docs/learn2learn.nn/#lambda","text":"1 Lambda ( lmb ) [Source] Description Utility class to create a wrapper based on a lambda function. Arguments lmb (callable) - The function to call in the forward pass. Example 1 2 3 4 mean23 = Lambda ( lambda x : x . mean ( dim = [ 2 , 3 ])) # mean23 is a Module x = features ( img ) x = mean23 ( x ) x = x . flatten ()","title":"Lambda"},{"location":"_build/pydocmd/docs/learn2learn.nn/#flatten","text":"1 Flatten () [Source] Description Utility Module to flatten inputs to (batch_size, -1) shape. Example 1 2 3 4 flatten = Flatten () x = torch . randn ( 5 , 3 , 32 , 32 ) x = flatten ( x ) print ( x . shape ) # (5, 3072)","title":"Flatten"},{"location":"_build/pydocmd/docs/learn2learn.nn/#scale","text":"1 Scale ( shape , alpha = 1.0 ) [Source] Description A per-parameter scaling factor with learnable parameter. Arguments shape (int or tuple) - The shape of the scaling matrix. alpha (float, optional , default=1.0) - Initial value for the scaling factor. Example 1 2 3 x = torch . ones ( 3 ) scale = Scale ( x . shape , alpha = 0.5 ) print ( scale ( x )) # [.5, .5, .5]","title":"Scale"},{"location":"_build/pydocmd/docs/learn2learn.nn/#prototypicalclassifier","text":"1 2 3 4 PrototypicalClassifier ( support = None , labels = None , distance = 'euclidean' , normalize = False ) [Source] Description A module for the differentiable nearest neighbour classifier of Prototypical Networks. Arguments support (Tensor, optional , default=None) - Tensor of support features. labels (Tensor, optional , default=None) - Labels corresponding to the support features. distance (str, optional , default='euclidean') - Distance metric between samples. ['euclidean', 'cosine'] normalize (bool, optional , default=False) - Whether to normalize the inputs. Defaults to True when distance='cosine'. References Snell et al. 2017. \"Prototypical Networks for Few-shot Learning\" Example 1 2 3 4 5 classifier = PrototypicalClassifier () support = features ( support_data ) classifier . fit_ ( support , labels ) query = features ( query_data ) preds = classifier ( query )","title":"PrototypicalClassifier"},{"location":"_build/pydocmd/docs/learn2learn.nn/#svclassifier","text":"1 2 3 4 5 6 SVClassifier ( support = None , labels = None , ways = None , normalize = False , C_reg = 0.1 , max_iters = 15 ) [Source] Description A module for the differentiable SVM classifier of MetaOptNet. Arguments support (Tensor, optional , default=None) - Tensor of support features. labels (Tensor, optional , default=None) - Labels corresponding to the support features. ways (str, optional , default=None) - Number of classes in the task. normalize (bool, optional , default=False) - Whether to normalize the inputs. C_reg (float, optional , default=0.1) - Regularization weight for SVM. max_iters (int, optional , default=15) - Maximum number of iterations for SVM convergence. References Lee et al. 2019. \"Prototypical Networks for Few-shot Learning\" Example 1 2 3 4 5 classifier = SVMClassifier () support = features ( support_data ) classifier . fit_ ( support , labels ) query = features ( query_data ) preds = classifier ( query )","title":"SVClassifier"},{"location":"_build/pydocmd/docs/learn2learn.nn/#kroneckerlinear","text":"1 KroneckerLinear ( n , m , bias = True , psd = False , device = None ) [Source] Description A linear transformation whose parameters are expressed as a Kronecker product. This Module maps an input vector x \\in \\mathbb{R}^{nm} to y = Ax + b such that: A = R^\\top \\otimes L, where L \\in \\mathbb{R}^{n \\times n} and R \\in \\mathbb{R}^{m \\times m} are the learnable Kronecker factors. This implementation can reduce the memory requirement for large linear mapping from \\mathcal{O}(n^2 \\cdot m^2) to \\mathcal{O}(n^2 + m^2) , but forces y \\in \\mathbb{R}^{nm} . The matrix A is initialized as the identity, and the bias as a zero vector. Arguments n (int) - Dimensionality of the left Kronecker factor. m (int) - Dimensionality of the right Kronecker factor. bias (bool, optional , default=True) - Whether to include the bias term. psd (bool, optional , default=False) - Forces the matrix A to be positive semi-definite if True. device (device, optional , default=None) - The device on which to instantiate the Module. References Jose et al. 2018. \"Kronecker recurrent units\". Arnold et al. 2019. \"When MAML can adapt fast and how to assist when it cannot\". Example 1 2 3 4 5 m , n = 2 , 3 x = torch . randn ( 6 ) kronecker = KroneckerLinear ( n , m ) y = kronecker ( x ) y . shape # (6, )","title":"KroneckerLinear"},{"location":"_build/pydocmd/docs/learn2learn.nn/#kroneckerrnn","text":"1 KroneckerRNN ( n , m , bias = True , sigma = None ) [Source] Description Implements a recurrent neural network whose matrices are parameterized via their Kronecker factors. (See KroneckerLinear for details.) Arguments n (int) - Dimensionality of the left Kronecker factor. m (int) - Dimensionality of the right Kronecker factor. bias (bool, optional , default=True) - Whether to include the bias term. sigma (callable, optional , default=None) - The activation function. References Jose et al. 2018. \"Kronecker recurrent units\". Example 1 2 3 4 5 6 m , n = 2 , 3 x = torch . randn ( 6 ) h = torch . randn ( 6 ) kronecker = KroneckerRNN ( n , m ) y , new_h = kronecker ( x , h ) y . shape # (6, )","title":"KroneckerRNN"},{"location":"_build/pydocmd/docs/learn2learn.nn/#kroneckerlstm","text":"1 KroneckerLSTM ( n , m , bias = True , sigma = None ) [Source] Description Implements an LSTM using a factorization similar to the one of KroneckerLinear . Arguments n (int) - Dimensionality of the left Kronecker factor. m (int) - Dimensionality of the right Kronecker factor. bias (bool, optional , default=True) - Whether to include the bias term. sigma (callable, optional , default=None) - The activation function. References Jose et al. 2018. \"Kronecker recurrent units\". Example 1 2 3 4 5 6 m , n = 2 , 3 x = torch . randn ( 6 ) h = torch . randn ( 6 ) kronecker = KroneckerLSTM ( n , m ) y , new_h = kronecker ( x , h ) y . shape # (6, )","title":"KroneckerLSTM"},{"location":"_build/pydocmd/docs/learn2learn.optim/","text":"learn2learn.optim \u00b6 A set of utilities to write differentiable optimization algorithms. LearnableOptimizer \u00b6 1 LearnableOptimizer ( model , transform , lr = 1.0 ) [Source] Description A PyTorch Optimizer with learnable transform, enabling the implementation of meta-descent / hyper-gradient algorithms. This optimizer takes a Module and a gradient transform. At each step, the gradient of the module is passed through the transforms, and the module differentiably update -- i.e. when the next backward is called, gradients of both the module and the transform are computed. In turn, the transform can be updated via your favorite optmizer. Arguments model (Module) - Module to be updated. transform (Module) - Transform used to compute updates of the model. lr (float) - Learning rate. References Sutton. 1992. \u201cGain Adaptation Beats Least Squares.\u201d Schraudolph. 1999. \u201cLocal Gain Adaptation in Stochastic Gradient Descent.\u201d Baydin et al. 2017. \u201cOnline Learning Rate Adaptation with Hypergradient Descent.\u201d Majumder et al. 2019. \u201cLearning the Learning Rate for Gradient Descent by Gradient Descent.\u201d Jacobsen et al. 2019. \u201cMeta-Descent for Online, Continual Prediction.\u201d Example 1 2 3 4 5 6 7 8 9 10 11 linear = nn . Linear ( 784 , 10 ) transform = l2l . optim . ModuleTransform ( torch . nn . Linear ) metaopt = l2l . optim . LearnableOptimizer ( linear , transform , lr = 0.01 ) opt = torch . optim . SGD ( metaopt . parameters (), lr = 0.001 ) metaopt . zero_grad () opt . zero_grad () error = loss ( linear ( X ), y ) error . backward () opt . step () # update metaopt metaopt . step () # update linear zero_grad \u00b6 1 LearnableOptimizer . zero_grad () Only reset target parameters. ParameterUpdate \u00b6 1 ParameterUpdate ( parameters , transform ) [Source] Description Convenience class to implement custom update functions. Objects instantiated from this class behave similarly to torch.autograd.grad , but return parameter updates as opposed to gradients. Concretely, the gradients are first computed, then fed to their respective transform whose output is finally returned to the user. Additionally, this class supports parameters that might not require updates by setting the allow_nograd flag to True. In this case, the returned update is None . Arguments parameters (list) - Parameters of the model to update. transform (callable) - A callable that returns an instantiated transform given a parameter. Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 model = torch . nn . Linear () transform = l2l . optim . KroneckerTransform ( l2l . nn . KroneckerLinear ) get_update = ParameterUpdate ( model , transform ) opt = torch . optim . SGD ( model . parameters () + get_update . parameters ()) for iteration in range ( 10 ): opt . zero_grad () error = loss ( model ( X ), y ) updates = get_update ( error , model . parameters (), create_graph = True , ) l2l . update_module ( model , updates ) opt . step () forward \u00b6 1 2 3 4 5 6 ParameterUpdate . forward ( loss , parameters , create_graph = False , retain_graph = False , allow_unused = False , allow_nograd = False ) Description Similar to torch.autograd.grad, but passes the gradients through the provided transform. Arguments loss (Tensor) - The loss to differentiate. parameters (iterable) - Parameters w.r.t. which we want to compute the update. create_graph (bool, optional , default=False) - Same as torch.autograd.grad . retain_graph (bool, optional , default=False) - Same as torch.autograd.grad . allow_unused (bool, optional , default=False) - Same as torch.autograd.grad . allow_nograd (bool, optional , default=False) - Properly handles parameters that do not require gradients. (Their update will be None .) DifferentiableSGD \u00b6 1 DifferentiableSGD ( lr ) [Source] Description A callable object that applies a list of updates to the parameters of a torch.nn.Module in a differentiable manner. For each parameter p and corresponding gradient g , calling an instance of this class results in updating parameters: p \\gets p - \\alpha g, where \\alpha is the learning rate. Note: The module is updated in-place. Arguments lr (float) - The learning rate used to update the model. Example 1 2 3 4 5 6 sgd = DifferentiableSGD ( 0.1 ) gradients = torch . autograd . grad ( loss , model . parameters (), create_gaph = True ) sgd ( model , gradients ) # model is updated in-place forward \u00b6 1 DifferentiableSGD . forward ( module , gradients = None ) Arguments module (Module) - The module to update. gradients (list, optional , default=None) - A list of gradients for each parameter of the module. If None, will use the gradients in .grad attributes. learn2learn.optim.transforms \u00b6 Optimization transforms are special modules that take gradients as inputs and output model updates. Transforms are usually parameterized, and those parameters can be learned by gradient descent, allow you to learn optimization functions from data. ModuleTransform \u00b6 1 ModuleTransform ( module_cls ) [Source] Description The ModuleTransform creates a an optimization transform based on any nn.Module. ModuleTransform automatically instanciates a module from its class, based on a given parameter. The input and output shapes are of the module are set to (1, param.numel()) . When optimizing large layers, this type of transform can quickly run out of memory. See KroneckerTransform for a scalable alternative. Arguments module_cls (callable) - A callable that instantiates the module used to transform gradients. Example 1 2 3 4 5 6 classifier = torch . nn . Linear ( 784 , 10 , bias = False ) linear_transform = ModuleTransform ( torch . nn . Linear ) linear_update = linear_transform ( classifier . weight ) # maps gradients to updates, both of shape (1, 7840) loss ( classifier ( X ), y ) . backward () update = linear_update ( classifier . weight . grad ) classifier . weight . data . add_ ( - lr , update ) # Not a differentiable update. See l2l.optim.DifferentiableSGD. KroneckerTransform \u00b6 1 KroneckerTransform ( kronecker_cls , bias = False , psd = True ) [Source] Description The KroneckerTransform creates a an optimization transform based on nn.Module's that admit a Kronecker factorization. (see l2l.nn.Kronecker* ) Akin to the ModuleTransform, this class of transform instanciates a module from its class, based on a given parameter. But, instead of reshaping the gradients to shape (1, param.numel()) , this class assumes a Kronecker factorization of the weights for memory and computational efficiency. The specific dimension of the Kronecker factorization depends on the the parameter's shape. For a weight of shape (n, m), a KroneckerLinear transform consists of two weights with shapes (n, n) and (m, m) rather than a single weight of shape (nm, nm). Refer to Arnold et al., 2019 for more details. Arguments kronecker_cls (callable) - A callable that instantiates the Kronecker module used to transform gradients. References Arnold et al. 2019. \"When MAML can adapt fast and how to assist when it cannot\". Example 1 2 3 4 5 6 classifier = torch . nn . Linear ( 784 , 10 , bias = False ) kronecker_transform = KroneckerTransform ( l2l . nn . KroneckerLinear ) kronecker_update = kronecker_transform ( classifier . weight ) loss ( classifier ( X ), y ) . backward () update = kronecker_update ( classifier . weight . grad ) classifier . weight . data . add_ ( - lr , update ) # Not a differentiable update. See l2l.optim.DifferentiableSGD. MetaCurvatureTransform \u00b6 1 MetaCurvatureTransform ( param , lr = 1.0 ) [Source] Description Implements the Meta-Curvature transform of Park and Oliva, 2019. Unlike ModuleTranform and KroneckerTransform , this class does not wrap other Modules but is directly called on a weight to instantiate the transform. Arguments param (Tensor) - The weight whose gradients will be transformed. lr (float, optional , default=1.0) - Scaling factor of the udpate. (non-learnable) References Park & Oliva. 2019. Meta-curvature. Example 1 2 3 4 5 classifier = torch . nn . Linear ( 784 , 10 , bias = False ) metacurvature_update = MetaCurvatureTransform ( classifier . weight ) loss ( classifier ( X ), y ) . backward () update = metacurvature_update ( classifier . weight . grad ) classifier . weight . data . add_ ( - lr , update ) # Not a differentiable update. See l2l.optim.DifferentiableSGD.","title":"learn2learn.optim"},{"location":"_build/pydocmd/docs/learn2learn.optim/#learn2learnoptim","text":"A set of utilities to write differentiable optimization algorithms.","title":"learn2learn.optim"},{"location":"_build/pydocmd/docs/learn2learn.optim/#learnableoptimizer","text":"1 LearnableOptimizer ( model , transform , lr = 1.0 ) [Source] Description A PyTorch Optimizer with learnable transform, enabling the implementation of meta-descent / hyper-gradient algorithms. This optimizer takes a Module and a gradient transform. At each step, the gradient of the module is passed through the transforms, and the module differentiably update -- i.e. when the next backward is called, gradients of both the module and the transform are computed. In turn, the transform can be updated via your favorite optmizer. Arguments model (Module) - Module to be updated. transform (Module) - Transform used to compute updates of the model. lr (float) - Learning rate. References Sutton. 1992. \u201cGain Adaptation Beats Least Squares.\u201d Schraudolph. 1999. \u201cLocal Gain Adaptation in Stochastic Gradient Descent.\u201d Baydin et al. 2017. \u201cOnline Learning Rate Adaptation with Hypergradient Descent.\u201d Majumder et al. 2019. \u201cLearning the Learning Rate for Gradient Descent by Gradient Descent.\u201d Jacobsen et al. 2019. \u201cMeta-Descent for Online, Continual Prediction.\u201d Example 1 2 3 4 5 6 7 8 9 10 11 linear = nn . Linear ( 784 , 10 ) transform = l2l . optim . ModuleTransform ( torch . nn . Linear ) metaopt = l2l . optim . LearnableOptimizer ( linear , transform , lr = 0.01 ) opt = torch . optim . SGD ( metaopt . parameters (), lr = 0.001 ) metaopt . zero_grad () opt . zero_grad () error = loss ( linear ( X ), y ) error . backward () opt . step () # update metaopt metaopt . step () # update linear","title":"LearnableOptimizer"},{"location":"_build/pydocmd/docs/learn2learn.optim/#zero_grad","text":"1 LearnableOptimizer . zero_grad () Only reset target parameters.","title":"zero_grad"},{"location":"_build/pydocmd/docs/learn2learn.optim/#parameterupdate","text":"1 ParameterUpdate ( parameters , transform ) [Source] Description Convenience class to implement custom update functions. Objects instantiated from this class behave similarly to torch.autograd.grad , but return parameter updates as opposed to gradients. Concretely, the gradients are first computed, then fed to their respective transform whose output is finally returned to the user. Additionally, this class supports parameters that might not require updates by setting the allow_nograd flag to True. In this case, the returned update is None . Arguments parameters (list) - Parameters of the model to update. transform (callable) - A callable that returns an instantiated transform given a parameter. Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 model = torch . nn . Linear () transform = l2l . optim . KroneckerTransform ( l2l . nn . KroneckerLinear ) get_update = ParameterUpdate ( model , transform ) opt = torch . optim . SGD ( model . parameters () + get_update . parameters ()) for iteration in range ( 10 ): opt . zero_grad () error = loss ( model ( X ), y ) updates = get_update ( error , model . parameters (), create_graph = True , ) l2l . update_module ( model , updates ) opt . step ()","title":"ParameterUpdate"},{"location":"_build/pydocmd/docs/learn2learn.optim/#forward","text":"1 2 3 4 5 6 ParameterUpdate . forward ( loss , parameters , create_graph = False , retain_graph = False , allow_unused = False , allow_nograd = False ) Description Similar to torch.autograd.grad, but passes the gradients through the provided transform. Arguments loss (Tensor) - The loss to differentiate. parameters (iterable) - Parameters w.r.t. which we want to compute the update. create_graph (bool, optional , default=False) - Same as torch.autograd.grad . retain_graph (bool, optional , default=False) - Same as torch.autograd.grad . allow_unused (bool, optional , default=False) - Same as torch.autograd.grad . allow_nograd (bool, optional , default=False) - Properly handles parameters that do not require gradients. (Their update will be None .)","title":"forward"},{"location":"_build/pydocmd/docs/learn2learn.optim/#differentiablesgd","text":"1 DifferentiableSGD ( lr ) [Source] Description A callable object that applies a list of updates to the parameters of a torch.nn.Module in a differentiable manner. For each parameter p and corresponding gradient g , calling an instance of this class results in updating parameters: p \\gets p - \\alpha g, where \\alpha is the learning rate. Note: The module is updated in-place. Arguments lr (float) - The learning rate used to update the model. Example 1 2 3 4 5 6 sgd = DifferentiableSGD ( 0.1 ) gradients = torch . autograd . grad ( loss , model . parameters (), create_gaph = True ) sgd ( model , gradients ) # model is updated in-place","title":"DifferentiableSGD"},{"location":"_build/pydocmd/docs/learn2learn.optim/#forward_1","text":"1 DifferentiableSGD . forward ( module , gradients = None ) Arguments module (Module) - The module to update. gradients (list, optional , default=None) - A list of gradients for each parameter of the module. If None, will use the gradients in .grad attributes.","title":"forward"},{"location":"_build/pydocmd/docs/learn2learn.optim/#learn2learnoptimtransforms","text":"Optimization transforms are special modules that take gradients as inputs and output model updates. Transforms are usually parameterized, and those parameters can be learned by gradient descent, allow you to learn optimization functions from data.","title":"learn2learn.optim.transforms"},{"location":"_build/pydocmd/docs/learn2learn.optim/#moduletransform","text":"1 ModuleTransform ( module_cls ) [Source] Description The ModuleTransform creates a an optimization transform based on any nn.Module. ModuleTransform automatically instanciates a module from its class, based on a given parameter. The input and output shapes are of the module are set to (1, param.numel()) . When optimizing large layers, this type of transform can quickly run out of memory. See KroneckerTransform for a scalable alternative. Arguments module_cls (callable) - A callable that instantiates the module used to transform gradients. Example 1 2 3 4 5 6 classifier = torch . nn . Linear ( 784 , 10 , bias = False ) linear_transform = ModuleTransform ( torch . nn . Linear ) linear_update = linear_transform ( classifier . weight ) # maps gradients to updates, both of shape (1, 7840) loss ( classifier ( X ), y ) . backward () update = linear_update ( classifier . weight . grad ) classifier . weight . data . add_ ( - lr , update ) # Not a differentiable update. See l2l.optim.DifferentiableSGD.","title":"ModuleTransform"},{"location":"_build/pydocmd/docs/learn2learn.optim/#kroneckertransform","text":"1 KroneckerTransform ( kronecker_cls , bias = False , psd = True ) [Source] Description The KroneckerTransform creates a an optimization transform based on nn.Module's that admit a Kronecker factorization. (see l2l.nn.Kronecker* ) Akin to the ModuleTransform, this class of transform instanciates a module from its class, based on a given parameter. But, instead of reshaping the gradients to shape (1, param.numel()) , this class assumes a Kronecker factorization of the weights for memory and computational efficiency. The specific dimension of the Kronecker factorization depends on the the parameter's shape. For a weight of shape (n, m), a KroneckerLinear transform consists of two weights with shapes (n, n) and (m, m) rather than a single weight of shape (nm, nm). Refer to Arnold et al., 2019 for more details. Arguments kronecker_cls (callable) - A callable that instantiates the Kronecker module used to transform gradients. References Arnold et al. 2019. \"When MAML can adapt fast and how to assist when it cannot\". Example 1 2 3 4 5 6 classifier = torch . nn . Linear ( 784 , 10 , bias = False ) kronecker_transform = KroneckerTransform ( l2l . nn . KroneckerLinear ) kronecker_update = kronecker_transform ( classifier . weight ) loss ( classifier ( X ), y ) . backward () update = kronecker_update ( classifier . weight . grad ) classifier . weight . data . add_ ( - lr , update ) # Not a differentiable update. See l2l.optim.DifferentiableSGD.","title":"KroneckerTransform"},{"location":"_build/pydocmd/docs/learn2learn.optim/#metacurvaturetransform","text":"1 MetaCurvatureTransform ( param , lr = 1.0 ) [Source] Description Implements the Meta-Curvature transform of Park and Oliva, 2019. Unlike ModuleTranform and KroneckerTransform , this class does not wrap other Modules but is directly called on a weight to instantiate the transform. Arguments param (Tensor) - The weight whose gradients will be transformed. lr (float, optional , default=1.0) - Scaling factor of the udpate. (non-learnable) References Park & Oliva. 2019. Meta-curvature. Example 1 2 3 4 5 classifier = torch . nn . Linear ( 784 , 10 , bias = False ) metacurvature_update = MetaCurvatureTransform ( classifier . weight ) loss ( classifier ( X ), y ) . backward () update = metacurvature_update ( classifier . weight . grad ) classifier . weight . data . add_ ( - lr , update ) # Not a differentiable update. See l2l.optim.DifferentiableSGD.","title":"MetaCurvatureTransform"},{"location":"_build/pydocmd/docs/learn2learn.text/","text":"NewsClassification \u00b6 1 NewsClassification ( * args , ** kwds ) [Source] Description References TODO: Cite ... Arguments Example","title":"NewsClassification"},{"location":"_build/pydocmd/docs/learn2learn.text/#newsclassification","text":"1 NewsClassification ( * args , ** kwds ) [Source] Description References TODO: Cite ... Arguments Example","title":"NewsClassification"},{"location":"_build/pydocmd/docs/learn2learn.vision/","text":"learn2learn.vision \u00b6 Datasets, models, and other utilities related to computer vision. learn2learn.vision.models \u00b6 Description A set of commonly used models for meta-learning vision tasks. For simplicity, all models' forward conform to the following API: 1 2 3 4 def forward ( self , x ): x = self . features ( x ) x = self . classifier ( x ) return x OmniglotFC \u00b6 1 OmniglotFC ( input_size , output_size , sizes = None ) [Source] Description The fully-connected network used for Omniglot experiments, as described in Santoro et al, 2016. References Santoro et al. 2016. \u201cMeta-Learning with Memory-Augmented Neural Networks.\u201d ICML. Arguments input_size (int) - The dimensionality of the input. output_size (int) - The dimensionality of the output. sizes (list, optional , default=None) - A list of hidden layer sizes. Example 1 2 3 net = OmniglotFC ( input_size = 28 ** 2 , output_size = 10 , sizes = [ 64 , 64 , 64 ]) OmniglotCNN \u00b6 1 OmniglotCNN ( output_size = 5 , hidden_size = 64 , layers = 4 ) Source Description The convolutional network commonly used for Omniglot, as described by Finn et al, 2017. This network assumes inputs of shapes (1, 28, 28). References Finn et al. 2017. \u201cModel-Agnostic Meta-Learning for Fast Adaptation of Deep Networks.\u201d ICML. Arguments output_size (int) - The dimensionality of the network's output. hidden_size (int, optional , default=64) - The dimensionality of the hidden representation. layers (int, optional , default=4) - The number of convolutional layers. Example 1 model = OmniglotCNN ( output_size = 20 , hidden_size = 128 , layers = 3 ) CNN4 \u00b6 1 2 3 4 5 6 CNN4 ( output_size , hidden_size = 64 , layers = 4 , channels = 3 , max_pool = True , embedding_size = None ) [Source] Description The convolutional network commonly used for MiniImagenet, as described by Ravi et Larochelle, 2017. This network assumes inputs of shapes (3, 84, 84). Instantiate CNN4Backbone if you only need the feature extractor. References Ravi and Larochelle. 2017. \u201cOptimization as a Model for Few-Shot Learning.\u201d ICLR. Arguments output_size (int) - The dimensionality of the network's output. hidden_size (int, optional , default=32) - The dimensionality of the hidden representation. layers (int, optional , default=4) - The number of convolutional layers. Example 1 model = CNN4 ( output_size = 20 , hidden_size = 128 , layers = 3 ) ResNet12 \u00b6 1 2 3 4 5 6 7 8 ResNet12 ( output_size , hidden_size = 640 , avg_pool = True , wider = True , embedding_dropout = 0.0 , dropblock_dropout = 0.1 , dropblock_size = 5 , channels = 3 ) [Source] Description The 12-layer residual network from Mishra et al, 2017. The code is adapted from Lee et al, 2019 who share it under the Apache 2 license. Instantiate ResNet12Backbone if you only need the feature extractor. List of changes: Rename ResNet to ResNet12. Small API modifications. Fix code style to be compatible with PEP8. Support multiple devices in DropBlock References Mishra et al. 2017. \u201cA Simple Neural Attentive Meta-Learner.\u201d ICLR 18. Lee et al. 2019. \u201cMeta-Learning with Differentiable Convex Optimization.\u201d CVPR 19. Lee et al's code: https://github.com/kjunelee/MetaOptNet/ Oreshkin et al. 2018. \u201cTADAM: Task Dependent Adaptive Metric for Improved Few-Shot Learning.\u201d NeurIPS 18. Arguments output_size (int) - The dimensionality of the output (eg, number of classes). hidden_size (list, optional , default=640) - Size of the embedding once features are extracted. (640 is for mini-ImageNet; used for the classifier layer) avg_pool (bool, optional , default=True) - Set to False for the 16k-dim embeddings of Lee et al, 2019. wider (bool, optional , default=True) - True uses (64, 160, 320, 640) filters akin to Lee et al, 2019. False uses (64, 128, 256, 512) filters, akin to Oreshkin et al, 2018. embedding_dropout (float, optional , default=0.0) - Dropout rate on the flattened embedding layer. dropblock_dropout (float, optional , default=0.1) - Dropout rate for the residual layers. dropblock_size (int, optional , default=5) - Size of drop blocks. Example 1 model = ResNet12 ( output_size = ways , hidden_size = 1600 , avg_pool = False ) WRN28 \u00b6 1 WRN28 ( output_size , hidden_size = 640 , dropout = 0.0 ) [Source] Description The 28-layer 10-depth wide residual network from Dhillon et al, 2020. The code is adapted from Ye et al, 2020 who share it under the MIT license. Instantiate WRN28Backbone if you only need the feature extractor. References Dhillon et al. 2020. \u201cA Baseline for Few-Shot Image Classification.\u201d ICLR 20. Ye et al. 2020. \u201cFew-Shot Learning via Embedding Adaptation with Set-to-Set Functions.\u201d CVPR 20. Ye et al's code: https://github.com/Sha-Lab/FEAT Arguments output_size (int) - The dimensionality of the output. hidden_size (list, optional , default=640) - Size of the embedding once features are extracted. (640 is for mini-ImageNet; used for the classifier layer) dropout (float, optional , default=0.0) - Dropout rate. Example 1 model = WRN28 ( output_size = ways , hidden_size = 1600 , avg_pool = False ) get_pretrained_backbone \u00b6 1 2 3 4 5 get_pretrained_backbone ( model , dataset , spec = 'default' , root = '~/data' , download = False ) [Source] Description Returns pretrained backbone for a benchmark dataset. The returned object is a torch.nn.Module instance. Arguments model (str) - The name of the model ( cnn4 , resnet12 , or wrn28 ) dataset (str) - The name of the benchmark dataset ( mini-imagenet or tiered-imagenet ). spec (str, optional , default='default') - Which weight specification to load ( default ). root (str, optional , default='~/data') - Location of the pretrained weights. download (bool, optional , default=False) - Download the pretrained weights if not available? Example 1 2 3 4 5 6 backbone = l2l . vision . models . get_pretrained_backbone ( model = 'resnet12' , dataset = 'mini-imagenet' , root = '~/.data' , download = True , ) learn2learn.vision.datasets \u00b6 Description Some datasets commonly used in meta-learning vision tasks. FullOmniglot \u00b6 1 FullOmniglot ( * args , ** kwds ) [Source] Description This class provides an interface to the Omniglot dataset. The Omniglot dataset was introduced by Lake et al., 2015. Omniglot consists of 1623 character classes from 50 different alphabets, each containing 20 samples. While the original dataset is separated in background and evaluation sets, this class concatenates both sets and leaves to the user the choice of classes splitting as was done in Ravi and Larochelle, 2017. The background and evaluation splits are available in the torchvision package. References Lake et al. 2015. \u201cHuman-Level Concept Learning through Probabilistic Program Induction.\u201d Science. Ravi and Larochelle. 2017. \u201cOptimization as a Model for Few-Shot Learning.\u201d ICLR. Arguments root (str) - Path to download the data. transform (Transform, optional , default=None) - Input pre-processing. target_transform (Transform, optional , default=None) - Target pre-processing. download (bool, optional , default=False) - Whether to download the dataset. Example 1 2 3 4 5 6 7 8 omniglot = l2l . vision . datasets . FullOmniglot ( root = './data' , transform = transforms . Compose ([ transforms . Resize ( 28 , interpolation = LANCZOS ), transforms . ToTensor (), lambda x : 1.0 - x , ]), download = True ) omniglot = l2l . data . MetaDataset ( omniglot ) MiniImagenet \u00b6 1 MiniImagenet ( * args , ** kwds ) [Source] Description The mini -ImageNet dataset was originally introduced by Vinyals et al., 2016. It consists of 60'000 colour images of sizes 84x84 pixels. The dataset is divided in 3 splits of 64 training, 16 validation, and 20 testing classes each containing 600 examples. The classes are sampled from the ImageNet dataset, and we use the splits from Ravi & Larochelle, 2017. References Vinyals et al. 2016. \u201cMatching Networks for One Shot Learning.\u201d NeurIPS. Ravi and Larochelle. 2017. \u201cOptimization as a Model for Few-Shot Learning.\u201d ICLR. Arguments root (str) - Path to download the data. mode (str, optional , default='train') - Which split to use. Must be 'train', 'validation', or 'test'. transform (Transform, optional , default=None) - Input pre-processing. target_transform (Transform, optional , default=None) - Target pre-processing. Example 1 2 3 train_dataset = l2l . vision . datasets . MiniImagenet ( root = './data' , mode = 'train' ) train_dataset = l2l . data . MetaDataset ( train_dataset ) train_generator = l2l . data . TaskGenerator ( dataset = train_dataset , ways = ways ) TieredImagenet \u00b6 1 TieredImagenet ( * args , ** kwds ) [Source] Description The tiered -ImageNet dataset was originally introduced by Ren et al, 2018 and we download the data directly from the link provided in their repository. Like mini -ImageNet, tiered -ImageNet builds on top of ILSVRC-12, but consists of 608 classes (779,165 images) instead of 100. The train-validation-test split is made such that classes from similar categories are in the same splits. There are 34 categories each containing between 10 and 30 classes. Of these categories, 20 (351 classes; 448,695 images) are used for training, 6 (97 classes; 124,261 images) for validation, and 8 (160 class; 206,209 images) for testing. References Ren et al, 2018. \"Meta-Learning for Semi-Supervised Few-Shot Classification.\" ICLR '18. Ren Mengye. 2018. \"few-shot-ssl-public\". https://github.com/renmengye/few-shot-ssl-public Arguments root (str) - Path to download the data. mode (str, optional , default='train') - Which split to use. Must be 'train', 'validation', or 'test'. transform (Transform, optional , default=None) - Input pre-processing. target_transform (Transform, optional , default=None) - Target pre-processing. download (bool, optional , default=False) - Whether to download the dataset. Example 1 2 3 train_dataset = l2l . vision . datasets . TieredImagenet ( root = './data' , mode = 'train' , download = True ) train_dataset = l2l . data . MetaDataset ( train_dataset ) train_generator = l2l . data . TaskDataset ( dataset = train_dataset , num_tasks = 1000 ) FC100 \u00b6 1 FC100 ( * args , ** kwds ) [Source] Description The FC100 dataset was originally introduced by Oreshkin et al., 2018. It is based on CIFAR100, but unlike CIFAR-FS training, validation, and testing classes are split so as to minimize the information overlap between splits. The 100 classes are grouped into 20 superclasses of which 12 (60 classes) are used for training, 4 (20 classes) for validation, and 4 (20 classes) for testing. Each class contains 600 images. The specific splits are provided in the Supplementary Material of the paper. Our data is downloaded from the link provided by [2]. References Oreshkin et al. 2018. \"TADAM: Task Dependent Adaptive Metric for Improved Few-Shot Learning.\" NeurIPS. Kwoonjoon Lee. 2019. \"MetaOptNet.\" https://github.com/kjunelee/MetaOptNet Arguments root (str) - Path to download the data. mode (str, optional , default='train') - Which split to use. Must be 'train', 'validation', or 'test'. transform (Transform, optional , default=None) - Input pre-processing. target_transform (Transform, optional , default=None) - Target pre-processing. Example 1 2 3 train_dataset = l2l . vision . datasets . FC100 ( root = './data' , mode = 'train' ) train_dataset = l2l . data . MetaDataset ( train_dataset ) train_generator = l2l . data . TaskDataset ( dataset = train_dataset , num_tasks = 1000 ) CIFARFS \u00b6 1 CIFARFS ( * args , ** kwds ) [Source] Description The CIFAR Few-Shot dataset as originally introduced by Bertinetto et al., 2019. It consists of 60'000 colour images of sizes 32x32 pixels. The dataset is divided in 3 splits of 64 training, 16 validation, and 20 testing classes each containing 600 examples. The classes are sampled from the CIFAR-100 dataset, and we use the splits from Bertinetto et al., 2019. References Bertinetto et al. 2019. \"Meta-learning with differentiable closed-form solvers\". ICLR. Arguments root (str) - Path to download the data. mode (str, optional , default='train') - Which split to use. Must be 'train', 'validation', or 'test'. transform (Transform, optional , default=None) - Input pre-processing. target_transform (Transform, optional , default=None) - Target pre-processing. Example 1 2 3 train_dataset = l2l . vision . datasets . CIFARFS ( root = './data' , mode = 'train' ) train_dataset = l2l . data . MetaDataset ( train_dataset ) train_generator = l2l . data . TaskGenerator ( dataset = train_dataset , ways = ways ) VGGFlower102 \u00b6 1 VGGFlower102 ( * args , ** kwds ) [Source] Description The VGG Flowers dataset was originally introduced by Nilsback and Zisserman, 2006 and then re-purposed for few-shot learning in Triantafillou et al., 2020. The dataset consists of 102 classes of flowers, with each class consisting of 40 to 258 images. We provide the raw (unprocessed) images, and follow the train-validation-test splits of Triantafillou et al. References Nilsback, M. and A. Zisserman. 2006. \"A Visual Vocabulary for Flower Classification.\" CVPR '06. Triantafillou et al. 2020. \"Meta-Dataset: A Dataset of Datasets for Learning to Learn from Few Examples.\" ICLR '20. https://www.robots.ox.ac.uk/~vgg/data/flowers/ Arguments root (str) - Path to download the data. mode (str, optional , default='train') - Which split to use. Must be 'train', 'validation', or 'test'. transform (Transform, optional , default=None) - Input pre-processing. target_transform (Transform, optional , default=None) - Target pre-processing. download (bool, optional , default=False) - Whether to download the dataset. Example 1 2 3 train_dataset = l2l . vision . datasets . VGGFlower102 ( root = './data' , mode = 'train' ) train_dataset = l2l . data . MetaDataset ( train_dataset ) train_generator = l2l . data . TaskDataset ( dataset = train_dataset , num_tasks = 1000 ) FGVCAircraft \u00b6 1 FGVCAircraft ( * args , ** kwds ) [Source] Description The FGVC Aircraft dataset was originally introduced by Maji et al., 2013 and then re-purposed for few-shot learning in Triantafillou et al., 2020. The dataset consists of 10,200 images of aircraft (102 classes, each 100 images). We provided the raw (un-processed) images and follow the train-validation-test splits of Triantafillou et al. TODO: Triantafillou et al. recommend cropping the images using the bounding box information, to remove copyright information and ensure that only one plane is visible in the image. References Maji et al. 2013. \"Fine-Grained Visual Classification of Aircraft.\" arXiv [cs.CV]. Triantafillou et al. 2020. \"Meta-Dataset: A Dataset of Datasets for Learning to Learn from Few Examples.\" ICLR '20. http://www.robots.ox.ac.uk/~vgg/data/fgvc-aircraft/ Arguments root (str) - Path to download the data. mode (str, optional , default='train') - Which split to use. Must be 'train', 'validation', or 'test'. transform (Transform, optional , default=None) - Input pre-processing. target_transform (Transform, optional , default=None) - Target pre-processing. download (bool, optional , default=False) - Whether to download the dataset. Example 1 2 3 train_dataset = l2l . vision . datasets . FGVCAircraft ( root = './data' , mode = 'train' , download = True ) train_dataset = l2l . data . MetaDataset ( train_dataset ) train_generator = l2l . data . TaskDataset ( dataset = train_dataset , num_tasks = 1000 ) FGVCFungi \u00b6 1 FGVCFungi ( * args , ** kwds ) [Source] Description The FGVC Fungi dataset was originally introduced in the 5th Workshop on Fine-Grained Visual Categorization (FGVC) and then re-purposed for few-shot learning in Triantafillou et al., 2020. The dataset consists of 1,394 classes and 89,760 images of fungi. We provide the raw (unprocessed) images, and follow the train-validation-test splits of Triantafillou et al. Important You must agree to the original Terms of Use to use this dataset. More information here: https://github.com/visipedia/fgvcx_fungi_comp References https://sites.google.com/view/fgvc5/home Triantafillou et al. 2020. \"Meta-Dataset: A Dataset of Datasets for Learning to Learn from Few Examples.\" ICLR '20. https://github.com/visipedia/fgvcx_fungi_comp Arguments root (str) - Path to download the data. mode (str, optional , default='train') - Which split to use. Must be 'train', 'validation', or 'test'. transform (Transform, optional , default=None) - Input pre-processing. target_transform (Transform, optional , default=None) - Target pre-processing. download (bool, optional , default=False) - Whether to download the dataset. Example 1 2 3 train_dataset = l2l . vision . datasets . FGVCFungi ( root = './data' , mode = 'train' ) train_dataset = l2l . data . MetaDataset ( train_dataset ) train_generator = l2l . data . TaskDataset ( dataset = train_dataset , num_tasks = 1000 ) DescribableTextures \u00b6 1 DescribableTextures ( * args , ** kwds ) [Source] Description The VGG Describable Textures dataset was originally introduced by Cimpoi et al., 2014 and then re-purposed for few-shot learning in Triantafillou et al., 2020. The dataset consists of 5640 images organized according to 47 texture classes. Each class consists of 120 images between 300x300 and 640x640 pixels. Each image contains at least 90% of the texture. We follow the train-validation-test splits of Triantafillou et al., 2020. (33 classes for train, 7 for validation and test.) References Cimpoi et al. 2014. \"Describing Textures in the Wild.\" CVPR'14. Triantafillou et al. 2020. \"Meta-Dataset: A Dataset of Datasets for Learning to Learn from Few Examples.\" ICLR '20. https://www.robots.ox.ac.uk/~vgg/data/dtd/ Arguments root (str) - Path to download the data. mode (str, optional , default='train') - Which split to use. Must be 'train', 'validation', or 'test'. transform (Transform, optional , default=None) - Input pre-processing. target_transform (Transform, optional , default=None) - Target pre-processing. download (bool, optional , default=False) - Whether to download the dataset. Example 1 2 3 train_dataset = l2l . vision . datasets . DescribableTextures ( root = './data' , mode = 'train' ) train_dataset = l2l . data . MetaDataset ( train_dataset ) train_generator = l2l . data . TaskDataset ( dataset = train_dataset , num_tasks = 1000 ) CUBirds200 \u00b6 1 CUBirds200 ( * args , ** kwds ) [Source] Description The Caltech-UCSD Birds dataset was originally introduced by Wellinder et al., 2010 and then re-purposed for few-shot learning in Triantafillou et al., 2020. The dataset consists of 6,033 bird images classified into 200 bird species. The train set consists of 140 classes, while the validation and test sets each contain 30. We provide the raw (unprocessed) images, and follow the train-validation-test splits of Triantafillou et al. This dataset includes 43 images that overlap with the ILSVRC-2012 (ImageNet) dataset. They are omitted by default, but can be included by setting the include_imagenet_duplicates flag to True . References Welinder et al. 2010. \"Caltech-UCSD Birds 200.\" Caltech Technical Report. Triantafillou et al. 2020. \"Meta-Dataset: A Dataset of Datasets for Learning to Learn from Few Examples.\" ICLR '20. http://www.vision.caltech.edu/visipedia/CUB-200.html Arguments root (str) - Path to download the data. mode (str, optional , default='train') - Which split to use. Must be 'train', 'validation', or 'test'. transform (Transform, optional , default=None) - Input pre-processing. target_transform (Transform, optional , default=None) - Target pre-processing. download (bool, optional , default=False) - Whether to download the dataset. include_imagenet_duplicates (bool, optional , default=False) - Whether to include images that are also present in the ImageNet 2012 dataset. Example 1 2 3 train_dataset = l2l . vision . datasets . CUBirds200 ( root = './data' , mode = 'train' ) train_dataset = l2l . data . MetaDataset ( train_dataset ) train_generator = l2l . data . TaskDataset ( dataset = train_dataset , num_tasks = 1000 ) Quickdraw \u00b6 1 Quickdraw ( * args , ** kwds ) [Source] Description The Quickdraw dataset was originally introduced by Google Creative Lab in 2017 and then re-purposed for few-shot learning in Triantafillou et al., 2020. See Ha and Heck, 2017 for more information. The dataset consists of roughly 50M drawing images of 345 objects. Each image was hand-drawn by human annotators and is represented as black-and-white 28x28 pixel array. We follow the train-validation-test splits of Triantafillou et al., 2020. (241 classes for train, 52 for validation, and 52 for test.) References https://github.com/googlecreativelab/quickdraw-dataset Ha, David, and Douglas Eck. 2017. \"A Neural Representation of Sketch Drawings.\" ArXiv '17. Triantafillou et al. 2020. \"Meta-Dataset: A Dataset of Datasets for Learning to Learn from Few Examples.\" ICLR '20. Arguments root (str) - Path to download the data. mode (str, optional , default='train') - Which split to use. Must be 'train', 'validation', or 'test'. transform (Transform, optional , default=None) - Input pre-processing. target_transform (Transform, optional , default=None) - Target pre-processing. download (bool, optional , default=False) - Whether to download the dataset. Example 1 2 3 train_dataset = l2l . vision . datasets . Quickdraw ( root = './data' , mode = 'train' ) train_dataset = l2l . data . MetaDataset ( train_dataset ) train_generator = l2l . data . TaskDataset ( dataset = train_dataset , num_tasks = 1000 ) learn2learn.vision.transforms \u00b6 Description A set of transformations commonly used in meta-learning vision tasks. RandomClassRotation \u00b6 1 RandomClassRotation ( dataset , degrees ) [Source] Description Samples rotations from a given list uniformly at random, and applies it to all images from a given class. Arguments degrees (list) - The rotations to be sampled. Example 1 transform = RandomClassRotation ([ 0 , 90 , 180 , 270 ]) learn2learn.vision.benchmarks \u00b6 The benchmark modules provides a convenient interface to standardized benchmarks in the literature. It provides train/validation/test TaskDatasets and TaskTransforms for pre-defined datasets. This utility is useful for researchers to compare new algorithms against existing benchmarks. For a more fine-grained control over tasks and data, we recommend directly using l2l.data.TaskDataset and l2l.data.TaskTransforms . list_tasksets \u00b6 1 list_tasksets () [Source] Description Returns a list of all available benchmarks. Example 1 2 3 for name in l2l . vision . benchmarks . list_tasksets (): print ( name ) tasksets = l2l . vision . benchmarks . get_tasksets ( name ) get_tasksets \u00b6 1 2 3 4 5 6 7 8 9 get_tasksets ( name , train_ways = 5 , train_samples = 10 , test_ways = 5 , test_samples = 10 , num_tasks =- 1 , root = '~/data' , device = None , ** kwargs ) [Source] Description Returns the tasksets for a particular benchmark, using literature standard data and task transformations. The returned object is a namedtuple with attributes train , validation , test which correspond to their respective TaskDatasets. See examples/vision/maml_miniimagenet.py for an example. Arguments name (str) - The name of the benchmark. Full list in list_tasksets() . train_ways (int, optional , default=5) - The number of classes per train tasks. train_samples (int, optional , default=10) - The number of samples per train tasks. test_ways (int, optional , default=5) - The number of classes per test tasks. Also used for validation tasks. test_samples (int, optional , default=10) - The number of samples per test tasks. Also used for validation tasks. num_tasks (int, optional , default=-1) - The number of tasks in each TaskDataset. device (torch.Device, optional , default=None) - If not None, tasksets are loaded as Tensors on device . root (str, optional , default='~/data') - Where the data is stored. Example 1 2 3 4 5 6 7 train_tasks , validation_tasks , test_tasks = l2l . vision . benchmarks . get_tasksets ( 'omniglot' ) batch = train_tasks . sample () or : tasksets = l2l . vision . benchmarks . get_tasksets ( 'omniglot' ) batch = tasksets . train . sample ()","title":"learn2learn.vision"},{"location":"_build/pydocmd/docs/learn2learn.vision/#learn2learnvision","text":"Datasets, models, and other utilities related to computer vision.","title":"learn2learn.vision"},{"location":"_build/pydocmd/docs/learn2learn.vision/#learn2learnvisionmodels","text":"Description A set of commonly used models for meta-learning vision tasks. For simplicity, all models' forward conform to the following API: 1 2 3 4 def forward ( self , x ): x = self . features ( x ) x = self . classifier ( x ) return x","title":"learn2learn.vision.models"},{"location":"_build/pydocmd/docs/learn2learn.vision/#omniglotfc","text":"1 OmniglotFC ( input_size , output_size , sizes = None ) [Source] Description The fully-connected network used for Omniglot experiments, as described in Santoro et al, 2016. References Santoro et al. 2016. \u201cMeta-Learning with Memory-Augmented Neural Networks.\u201d ICML. Arguments input_size (int) - The dimensionality of the input. output_size (int) - The dimensionality of the output. sizes (list, optional , default=None) - A list of hidden layer sizes. Example 1 2 3 net = OmniglotFC ( input_size = 28 ** 2 , output_size = 10 , sizes = [ 64 , 64 , 64 ])","title":"OmniglotFC"},{"location":"_build/pydocmd/docs/learn2learn.vision/#omniglotcnn","text":"1 OmniglotCNN ( output_size = 5 , hidden_size = 64 , layers = 4 ) Source Description The convolutional network commonly used for Omniglot, as described by Finn et al, 2017. This network assumes inputs of shapes (1, 28, 28). References Finn et al. 2017. \u201cModel-Agnostic Meta-Learning for Fast Adaptation of Deep Networks.\u201d ICML. Arguments output_size (int) - The dimensionality of the network's output. hidden_size (int, optional , default=64) - The dimensionality of the hidden representation. layers (int, optional , default=4) - The number of convolutional layers. Example 1 model = OmniglotCNN ( output_size = 20 , hidden_size = 128 , layers = 3 )","title":"OmniglotCNN"},{"location":"_build/pydocmd/docs/learn2learn.vision/#cnn4","text":"1 2 3 4 5 6 CNN4 ( output_size , hidden_size = 64 , layers = 4 , channels = 3 , max_pool = True , embedding_size = None ) [Source] Description The convolutional network commonly used for MiniImagenet, as described by Ravi et Larochelle, 2017. This network assumes inputs of shapes (3, 84, 84). Instantiate CNN4Backbone if you only need the feature extractor. References Ravi and Larochelle. 2017. \u201cOptimization as a Model for Few-Shot Learning.\u201d ICLR. Arguments output_size (int) - The dimensionality of the network's output. hidden_size (int, optional , default=32) - The dimensionality of the hidden representation. layers (int, optional , default=4) - The number of convolutional layers. Example 1 model = CNN4 ( output_size = 20 , hidden_size = 128 , layers = 3 )","title":"CNN4"},{"location":"_build/pydocmd/docs/learn2learn.vision/#resnet12","text":"1 2 3 4 5 6 7 8 ResNet12 ( output_size , hidden_size = 640 , avg_pool = True , wider = True , embedding_dropout = 0.0 , dropblock_dropout = 0.1 , dropblock_size = 5 , channels = 3 ) [Source] Description The 12-layer residual network from Mishra et al, 2017. The code is adapted from Lee et al, 2019 who share it under the Apache 2 license. Instantiate ResNet12Backbone if you only need the feature extractor. List of changes: Rename ResNet to ResNet12. Small API modifications. Fix code style to be compatible with PEP8. Support multiple devices in DropBlock References Mishra et al. 2017. \u201cA Simple Neural Attentive Meta-Learner.\u201d ICLR 18. Lee et al. 2019. \u201cMeta-Learning with Differentiable Convex Optimization.\u201d CVPR 19. Lee et al's code: https://github.com/kjunelee/MetaOptNet/ Oreshkin et al. 2018. \u201cTADAM: Task Dependent Adaptive Metric for Improved Few-Shot Learning.\u201d NeurIPS 18. Arguments output_size (int) - The dimensionality of the output (eg, number of classes). hidden_size (list, optional , default=640) - Size of the embedding once features are extracted. (640 is for mini-ImageNet; used for the classifier layer) avg_pool (bool, optional , default=True) - Set to False for the 16k-dim embeddings of Lee et al, 2019. wider (bool, optional , default=True) - True uses (64, 160, 320, 640) filters akin to Lee et al, 2019. False uses (64, 128, 256, 512) filters, akin to Oreshkin et al, 2018. embedding_dropout (float, optional , default=0.0) - Dropout rate on the flattened embedding layer. dropblock_dropout (float, optional , default=0.1) - Dropout rate for the residual layers. dropblock_size (int, optional , default=5) - Size of drop blocks. Example 1 model = ResNet12 ( output_size = ways , hidden_size = 1600 , avg_pool = False )","title":"ResNet12"},{"location":"_build/pydocmd/docs/learn2learn.vision/#wrn28","text":"1 WRN28 ( output_size , hidden_size = 640 , dropout = 0.0 ) [Source] Description The 28-layer 10-depth wide residual network from Dhillon et al, 2020. The code is adapted from Ye et al, 2020 who share it under the MIT license. Instantiate WRN28Backbone if you only need the feature extractor. References Dhillon et al. 2020. \u201cA Baseline for Few-Shot Image Classification.\u201d ICLR 20. Ye et al. 2020. \u201cFew-Shot Learning via Embedding Adaptation with Set-to-Set Functions.\u201d CVPR 20. Ye et al's code: https://github.com/Sha-Lab/FEAT Arguments output_size (int) - The dimensionality of the output. hidden_size (list, optional , default=640) - Size of the embedding once features are extracted. (640 is for mini-ImageNet; used for the classifier layer) dropout (float, optional , default=0.0) - Dropout rate. Example 1 model = WRN28 ( output_size = ways , hidden_size = 1600 , avg_pool = False )","title":"WRN28"},{"location":"_build/pydocmd/docs/learn2learn.vision/#get_pretrained_backbone","text":"1 2 3 4 5 get_pretrained_backbone ( model , dataset , spec = 'default' , root = '~/data' , download = False ) [Source] Description Returns pretrained backbone for a benchmark dataset. The returned object is a torch.nn.Module instance. Arguments model (str) - The name of the model ( cnn4 , resnet12 , or wrn28 ) dataset (str) - The name of the benchmark dataset ( mini-imagenet or tiered-imagenet ). spec (str, optional , default='default') - Which weight specification to load ( default ). root (str, optional , default='~/data') - Location of the pretrained weights. download (bool, optional , default=False) - Download the pretrained weights if not available? Example 1 2 3 4 5 6 backbone = l2l . vision . models . get_pretrained_backbone ( model = 'resnet12' , dataset = 'mini-imagenet' , root = '~/.data' , download = True , )","title":"get_pretrained_backbone"},{"location":"_build/pydocmd/docs/learn2learn.vision/#learn2learnvisiondatasets","text":"Description Some datasets commonly used in meta-learning vision tasks.","title":"learn2learn.vision.datasets"},{"location":"_build/pydocmd/docs/learn2learn.vision/#fullomniglot","text":"1 FullOmniglot ( * args , ** kwds ) [Source] Description This class provides an interface to the Omniglot dataset. The Omniglot dataset was introduced by Lake et al., 2015. Omniglot consists of 1623 character classes from 50 different alphabets, each containing 20 samples. While the original dataset is separated in background and evaluation sets, this class concatenates both sets and leaves to the user the choice of classes splitting as was done in Ravi and Larochelle, 2017. The background and evaluation splits are available in the torchvision package. References Lake et al. 2015. \u201cHuman-Level Concept Learning through Probabilistic Program Induction.\u201d Science. Ravi and Larochelle. 2017. \u201cOptimization as a Model for Few-Shot Learning.\u201d ICLR. Arguments root (str) - Path to download the data. transform (Transform, optional , default=None) - Input pre-processing. target_transform (Transform, optional , default=None) - Target pre-processing. download (bool, optional , default=False) - Whether to download the dataset. Example 1 2 3 4 5 6 7 8 omniglot = l2l . vision . datasets . FullOmniglot ( root = './data' , transform = transforms . Compose ([ transforms . Resize ( 28 , interpolation = LANCZOS ), transforms . ToTensor (), lambda x : 1.0 - x , ]), download = True ) omniglot = l2l . data . MetaDataset ( omniglot )","title":"FullOmniglot"},{"location":"_build/pydocmd/docs/learn2learn.vision/#miniimagenet","text":"1 MiniImagenet ( * args , ** kwds ) [Source] Description The mini -ImageNet dataset was originally introduced by Vinyals et al., 2016. It consists of 60'000 colour images of sizes 84x84 pixels. The dataset is divided in 3 splits of 64 training, 16 validation, and 20 testing classes each containing 600 examples. The classes are sampled from the ImageNet dataset, and we use the splits from Ravi & Larochelle, 2017. References Vinyals et al. 2016. \u201cMatching Networks for One Shot Learning.\u201d NeurIPS. Ravi and Larochelle. 2017. \u201cOptimization as a Model for Few-Shot Learning.\u201d ICLR. Arguments root (str) - Path to download the data. mode (str, optional , default='train') - Which split to use. Must be 'train', 'validation', or 'test'. transform (Transform, optional , default=None) - Input pre-processing. target_transform (Transform, optional , default=None) - Target pre-processing. Example 1 2 3 train_dataset = l2l . vision . datasets . MiniImagenet ( root = './data' , mode = 'train' ) train_dataset = l2l . data . MetaDataset ( train_dataset ) train_generator = l2l . data . TaskGenerator ( dataset = train_dataset , ways = ways )","title":"MiniImagenet"},{"location":"_build/pydocmd/docs/learn2learn.vision/#tieredimagenet","text":"1 TieredImagenet ( * args , ** kwds ) [Source] Description The tiered -ImageNet dataset was originally introduced by Ren et al, 2018 and we download the data directly from the link provided in their repository. Like mini -ImageNet, tiered -ImageNet builds on top of ILSVRC-12, but consists of 608 classes (779,165 images) instead of 100. The train-validation-test split is made such that classes from similar categories are in the same splits. There are 34 categories each containing between 10 and 30 classes. Of these categories, 20 (351 classes; 448,695 images) are used for training, 6 (97 classes; 124,261 images) for validation, and 8 (160 class; 206,209 images) for testing. References Ren et al, 2018. \"Meta-Learning for Semi-Supervised Few-Shot Classification.\" ICLR '18. Ren Mengye. 2018. \"few-shot-ssl-public\". https://github.com/renmengye/few-shot-ssl-public Arguments root (str) - Path to download the data. mode (str, optional , default='train') - Which split to use. Must be 'train', 'validation', or 'test'. transform (Transform, optional , default=None) - Input pre-processing. target_transform (Transform, optional , default=None) - Target pre-processing. download (bool, optional , default=False) - Whether to download the dataset. Example 1 2 3 train_dataset = l2l . vision . datasets . TieredImagenet ( root = './data' , mode = 'train' , download = True ) train_dataset = l2l . data . MetaDataset ( train_dataset ) train_generator = l2l . data . TaskDataset ( dataset = train_dataset , num_tasks = 1000 )","title":"TieredImagenet"},{"location":"_build/pydocmd/docs/learn2learn.vision/#fc100","text":"1 FC100 ( * args , ** kwds ) [Source] Description The FC100 dataset was originally introduced by Oreshkin et al., 2018. It is based on CIFAR100, but unlike CIFAR-FS training, validation, and testing classes are split so as to minimize the information overlap between splits. The 100 classes are grouped into 20 superclasses of which 12 (60 classes) are used for training, 4 (20 classes) for validation, and 4 (20 classes) for testing. Each class contains 600 images. The specific splits are provided in the Supplementary Material of the paper. Our data is downloaded from the link provided by [2]. References Oreshkin et al. 2018. \"TADAM: Task Dependent Adaptive Metric for Improved Few-Shot Learning.\" NeurIPS. Kwoonjoon Lee. 2019. \"MetaOptNet.\" https://github.com/kjunelee/MetaOptNet Arguments root (str) - Path to download the data. mode (str, optional , default='train') - Which split to use. Must be 'train', 'validation', or 'test'. transform (Transform, optional , default=None) - Input pre-processing. target_transform (Transform, optional , default=None) - Target pre-processing. Example 1 2 3 train_dataset = l2l . vision . datasets . FC100 ( root = './data' , mode = 'train' ) train_dataset = l2l . data . MetaDataset ( train_dataset ) train_generator = l2l . data . TaskDataset ( dataset = train_dataset , num_tasks = 1000 )","title":"FC100"},{"location":"_build/pydocmd/docs/learn2learn.vision/#cifarfs","text":"1 CIFARFS ( * args , ** kwds ) [Source] Description The CIFAR Few-Shot dataset as originally introduced by Bertinetto et al., 2019. It consists of 60'000 colour images of sizes 32x32 pixels. The dataset is divided in 3 splits of 64 training, 16 validation, and 20 testing classes each containing 600 examples. The classes are sampled from the CIFAR-100 dataset, and we use the splits from Bertinetto et al., 2019. References Bertinetto et al. 2019. \"Meta-learning with differentiable closed-form solvers\". ICLR. Arguments root (str) - Path to download the data. mode (str, optional , default='train') - Which split to use. Must be 'train', 'validation', or 'test'. transform (Transform, optional , default=None) - Input pre-processing. target_transform (Transform, optional , default=None) - Target pre-processing. Example 1 2 3 train_dataset = l2l . vision . datasets . CIFARFS ( root = './data' , mode = 'train' ) train_dataset = l2l . data . MetaDataset ( train_dataset ) train_generator = l2l . data . TaskGenerator ( dataset = train_dataset , ways = ways )","title":"CIFARFS"},{"location":"_build/pydocmd/docs/learn2learn.vision/#vggflower102","text":"1 VGGFlower102 ( * args , ** kwds ) [Source] Description The VGG Flowers dataset was originally introduced by Nilsback and Zisserman, 2006 and then re-purposed for few-shot learning in Triantafillou et al., 2020. The dataset consists of 102 classes of flowers, with each class consisting of 40 to 258 images. We provide the raw (unprocessed) images, and follow the train-validation-test splits of Triantafillou et al. References Nilsback, M. and A. Zisserman. 2006. \"A Visual Vocabulary for Flower Classification.\" CVPR '06. Triantafillou et al. 2020. \"Meta-Dataset: A Dataset of Datasets for Learning to Learn from Few Examples.\" ICLR '20. https://www.robots.ox.ac.uk/~vgg/data/flowers/ Arguments root (str) - Path to download the data. mode (str, optional , default='train') - Which split to use. Must be 'train', 'validation', or 'test'. transform (Transform, optional , default=None) - Input pre-processing. target_transform (Transform, optional , default=None) - Target pre-processing. download (bool, optional , default=False) - Whether to download the dataset. Example 1 2 3 train_dataset = l2l . vision . datasets . VGGFlower102 ( root = './data' , mode = 'train' ) train_dataset = l2l . data . MetaDataset ( train_dataset ) train_generator = l2l . data . TaskDataset ( dataset = train_dataset , num_tasks = 1000 )","title":"VGGFlower102"},{"location":"_build/pydocmd/docs/learn2learn.vision/#fgvcaircraft","text":"1 FGVCAircraft ( * args , ** kwds ) [Source] Description The FGVC Aircraft dataset was originally introduced by Maji et al., 2013 and then re-purposed for few-shot learning in Triantafillou et al., 2020. The dataset consists of 10,200 images of aircraft (102 classes, each 100 images). We provided the raw (un-processed) images and follow the train-validation-test splits of Triantafillou et al. TODO: Triantafillou et al. recommend cropping the images using the bounding box information, to remove copyright information and ensure that only one plane is visible in the image. References Maji et al. 2013. \"Fine-Grained Visual Classification of Aircraft.\" arXiv [cs.CV]. Triantafillou et al. 2020. \"Meta-Dataset: A Dataset of Datasets for Learning to Learn from Few Examples.\" ICLR '20. http://www.robots.ox.ac.uk/~vgg/data/fgvc-aircraft/ Arguments root (str) - Path to download the data. mode (str, optional , default='train') - Which split to use. Must be 'train', 'validation', or 'test'. transform (Transform, optional , default=None) - Input pre-processing. target_transform (Transform, optional , default=None) - Target pre-processing. download (bool, optional , default=False) - Whether to download the dataset. Example 1 2 3 train_dataset = l2l . vision . datasets . FGVCAircraft ( root = './data' , mode = 'train' , download = True ) train_dataset = l2l . data . MetaDataset ( train_dataset ) train_generator = l2l . data . TaskDataset ( dataset = train_dataset , num_tasks = 1000 )","title":"FGVCAircraft"},{"location":"_build/pydocmd/docs/learn2learn.vision/#fgvcfungi","text":"1 FGVCFungi ( * args , ** kwds ) [Source] Description The FGVC Fungi dataset was originally introduced in the 5th Workshop on Fine-Grained Visual Categorization (FGVC) and then re-purposed for few-shot learning in Triantafillou et al., 2020. The dataset consists of 1,394 classes and 89,760 images of fungi. We provide the raw (unprocessed) images, and follow the train-validation-test splits of Triantafillou et al. Important You must agree to the original Terms of Use to use this dataset. More information here: https://github.com/visipedia/fgvcx_fungi_comp References https://sites.google.com/view/fgvc5/home Triantafillou et al. 2020. \"Meta-Dataset: A Dataset of Datasets for Learning to Learn from Few Examples.\" ICLR '20. https://github.com/visipedia/fgvcx_fungi_comp Arguments root (str) - Path to download the data. mode (str, optional , default='train') - Which split to use. Must be 'train', 'validation', or 'test'. transform (Transform, optional , default=None) - Input pre-processing. target_transform (Transform, optional , default=None) - Target pre-processing. download (bool, optional , default=False) - Whether to download the dataset. Example 1 2 3 train_dataset = l2l . vision . datasets . FGVCFungi ( root = './data' , mode = 'train' ) train_dataset = l2l . data . MetaDataset ( train_dataset ) train_generator = l2l . data . TaskDataset ( dataset = train_dataset , num_tasks = 1000 )","title":"FGVCFungi"},{"location":"_build/pydocmd/docs/learn2learn.vision/#describabletextures","text":"1 DescribableTextures ( * args , ** kwds ) [Source] Description The VGG Describable Textures dataset was originally introduced by Cimpoi et al., 2014 and then re-purposed for few-shot learning in Triantafillou et al., 2020. The dataset consists of 5640 images organized according to 47 texture classes. Each class consists of 120 images between 300x300 and 640x640 pixels. Each image contains at least 90% of the texture. We follow the train-validation-test splits of Triantafillou et al., 2020. (33 classes for train, 7 for validation and test.) References Cimpoi et al. 2014. \"Describing Textures in the Wild.\" CVPR'14. Triantafillou et al. 2020. \"Meta-Dataset: A Dataset of Datasets for Learning to Learn from Few Examples.\" ICLR '20. https://www.robots.ox.ac.uk/~vgg/data/dtd/ Arguments root (str) - Path to download the data. mode (str, optional , default='train') - Which split to use. Must be 'train', 'validation', or 'test'. transform (Transform, optional , default=None) - Input pre-processing. target_transform (Transform, optional , default=None) - Target pre-processing. download (bool, optional , default=False) - Whether to download the dataset. Example 1 2 3 train_dataset = l2l . vision . datasets . DescribableTextures ( root = './data' , mode = 'train' ) train_dataset = l2l . data . MetaDataset ( train_dataset ) train_generator = l2l . data . TaskDataset ( dataset = train_dataset , num_tasks = 1000 )","title":"DescribableTextures"},{"location":"_build/pydocmd/docs/learn2learn.vision/#cubirds200","text":"1 CUBirds200 ( * args , ** kwds ) [Source] Description The Caltech-UCSD Birds dataset was originally introduced by Wellinder et al., 2010 and then re-purposed for few-shot learning in Triantafillou et al., 2020. The dataset consists of 6,033 bird images classified into 200 bird species. The train set consists of 140 classes, while the validation and test sets each contain 30. We provide the raw (unprocessed) images, and follow the train-validation-test splits of Triantafillou et al. This dataset includes 43 images that overlap with the ILSVRC-2012 (ImageNet) dataset. They are omitted by default, but can be included by setting the include_imagenet_duplicates flag to True . References Welinder et al. 2010. \"Caltech-UCSD Birds 200.\" Caltech Technical Report. Triantafillou et al. 2020. \"Meta-Dataset: A Dataset of Datasets for Learning to Learn from Few Examples.\" ICLR '20. http://www.vision.caltech.edu/visipedia/CUB-200.html Arguments root (str) - Path to download the data. mode (str, optional , default='train') - Which split to use. Must be 'train', 'validation', or 'test'. transform (Transform, optional , default=None) - Input pre-processing. target_transform (Transform, optional , default=None) - Target pre-processing. download (bool, optional , default=False) - Whether to download the dataset. include_imagenet_duplicates (bool, optional , default=False) - Whether to include images that are also present in the ImageNet 2012 dataset. Example 1 2 3 train_dataset = l2l . vision . datasets . CUBirds200 ( root = './data' , mode = 'train' ) train_dataset = l2l . data . MetaDataset ( train_dataset ) train_generator = l2l . data . TaskDataset ( dataset = train_dataset , num_tasks = 1000 )","title":"CUBirds200"},{"location":"_build/pydocmd/docs/learn2learn.vision/#quickdraw","text":"1 Quickdraw ( * args , ** kwds ) [Source] Description The Quickdraw dataset was originally introduced by Google Creative Lab in 2017 and then re-purposed for few-shot learning in Triantafillou et al., 2020. See Ha and Heck, 2017 for more information. The dataset consists of roughly 50M drawing images of 345 objects. Each image was hand-drawn by human annotators and is represented as black-and-white 28x28 pixel array. We follow the train-validation-test splits of Triantafillou et al., 2020. (241 classes for train, 52 for validation, and 52 for test.) References https://github.com/googlecreativelab/quickdraw-dataset Ha, David, and Douglas Eck. 2017. \"A Neural Representation of Sketch Drawings.\" ArXiv '17. Triantafillou et al. 2020. \"Meta-Dataset: A Dataset of Datasets for Learning to Learn from Few Examples.\" ICLR '20. Arguments root (str) - Path to download the data. mode (str, optional , default='train') - Which split to use. Must be 'train', 'validation', or 'test'. transform (Transform, optional , default=None) - Input pre-processing. target_transform (Transform, optional , default=None) - Target pre-processing. download (bool, optional , default=False) - Whether to download the dataset. Example 1 2 3 train_dataset = l2l . vision . datasets . Quickdraw ( root = './data' , mode = 'train' ) train_dataset = l2l . data . MetaDataset ( train_dataset ) train_generator = l2l . data . TaskDataset ( dataset = train_dataset , num_tasks = 1000 )","title":"Quickdraw"},{"location":"_build/pydocmd/docs/learn2learn.vision/#learn2learnvisiontransforms","text":"Description A set of transformations commonly used in meta-learning vision tasks.","title":"learn2learn.vision.transforms"},{"location":"_build/pydocmd/docs/learn2learn.vision/#randomclassrotation","text":"1 RandomClassRotation ( dataset , degrees ) [Source] Description Samples rotations from a given list uniformly at random, and applies it to all images from a given class. Arguments degrees (list) - The rotations to be sampled. Example 1 transform = RandomClassRotation ([ 0 , 90 , 180 , 270 ])","title":"RandomClassRotation"},{"location":"_build/pydocmd/docs/learn2learn.vision/#learn2learnvisionbenchmarks","text":"The benchmark modules provides a convenient interface to standardized benchmarks in the literature. It provides train/validation/test TaskDatasets and TaskTransforms for pre-defined datasets. This utility is useful for researchers to compare new algorithms against existing benchmarks. For a more fine-grained control over tasks and data, we recommend directly using l2l.data.TaskDataset and l2l.data.TaskTransforms .","title":"learn2learn.vision.benchmarks"},{"location":"_build/pydocmd/docs/learn2learn.vision/#list_tasksets","text":"1 list_tasksets () [Source] Description Returns a list of all available benchmarks. Example 1 2 3 for name in l2l . vision . benchmarks . list_tasksets (): print ( name ) tasksets = l2l . vision . benchmarks . get_tasksets ( name )","title":"list_tasksets"},{"location":"_build/pydocmd/docs/learn2learn.vision/#get_tasksets","text":"1 2 3 4 5 6 7 8 9 get_tasksets ( name , train_ways = 5 , train_samples = 10 , test_ways = 5 , test_samples = 10 , num_tasks =- 1 , root = '~/data' , device = None , ** kwargs ) [Source] Description Returns the tasksets for a particular benchmark, using literature standard data and task transformations. The returned object is a namedtuple with attributes train , validation , test which correspond to their respective TaskDatasets. See examples/vision/maml_miniimagenet.py for an example. Arguments name (str) - The name of the benchmark. Full list in list_tasksets() . train_ways (int, optional , default=5) - The number of classes per train tasks. train_samples (int, optional , default=10) - The number of samples per train tasks. test_ways (int, optional , default=5) - The number of classes per test tasks. Also used for validation tasks. test_samples (int, optional , default=10) - The number of samples per test tasks. Also used for validation tasks. num_tasks (int, optional , default=-1) - The number of tasks in each TaskDataset. device (torch.Device, optional , default=None) - If not None, tasksets are loaded as Tensors on device . root (str, optional , default='~/data') - Where the data is stored. Example 1 2 3 4 5 6 7 train_tasks , validation_tasks , test_tasks = l2l . vision . benchmarks . get_tasksets ( 'omniglot' ) batch = train_tasks . sample () or : tasksets = l2l . vision . benchmarks . get_tasksets ( 'omniglot' ) batch = tasksets . train . sample ()","title":"get_tasksets"},{"location":"_build/pydocmd/tutorials/getting_started/","text":"Getting Started \u00b6 learn2learn is a meta-learning library providing three levels of functionality for users. At a high level, there are many examples using meta-learning algorithms to train on a myriad of datasets/environments. At a mid level, it provides a functional interface for several popular meta-learning algorithms as well as a data loader to make it easier to import other data sets. At a low level, it provides extended functionality for modules. Installing \u00b6 A pip package is available, updated periodically. Use the command: pip install -U learn2learn For the most update-to-date version clone the repository and use: pip install -e . When installing from sources, make sure that Cython is installed: pip install cython . Info While learn2learn is actively used in current research projects, it is still in development. Breaking changes might occur. Development \u00b6 To simplify the development process, the following commands can be executed from the cloned sources: make build - Builds learn2learn in place. make clean - Cleans previous installation. make lint - Runs linting on the codebase. make lint-examples - Runs linting on the examples. make tests - Runs a light testing suite. (i.e. the Travis one) make alltests - Runs an extensive testing suite. (much longer) make docs - Builds the documentation and serves the website locally. Tip If you encounter a problem, feel free to an open an issue and we'll look into it.","title":"Getting Started"},{"location":"_build/pydocmd/tutorials/getting_started/#getting-started","text":"learn2learn is a meta-learning library providing three levels of functionality for users. At a high level, there are many examples using meta-learning algorithms to train on a myriad of datasets/environments. At a mid level, it provides a functional interface for several popular meta-learning algorithms as well as a data loader to make it easier to import other data sets. At a low level, it provides extended functionality for modules.","title":"Getting Started"},{"location":"_build/pydocmd/tutorials/getting_started/#installing","text":"A pip package is available, updated periodically. Use the command: pip install -U learn2learn For the most update-to-date version clone the repository and use: pip install -e . When installing from sources, make sure that Cython is installed: pip install cython . Info While learn2learn is actively used in current research projects, it is still in development. Breaking changes might occur.","title":"Installing"},{"location":"_build/pydocmd/tutorials/getting_started/#development","text":"To simplify the development process, the following commands can be executed from the cloned sources: make build - Builds learn2learn in place. make clean - Cleans previous installation. make lint - Runs linting on the codebase. make lint-examples - Runs linting on the examples. make tests - Runs a light testing suite. (i.e. the Travis one) make alltests - Runs an extensive testing suite. (much longer) make docs - Builds the documentation and serves the website locally. Tip If you encounter a problem, feel free to an open an issue and we'll look into it.","title":"Development"},{"location":"_build/pydocmd/tutorials/anil_tutorial/ANIL_tutorial/","text":"Feature Reuse with ANIL \u00b6 Written by Ewina Pun on 3/30/2020. In this article, we will dive into a meta-learning algorithm called ANIL (Almost No Inner Loop) presented by Raghu et al., 2019 , and explain how to implement it with learn2learn. Note This tutorial is written for experienced PyTorch users who are getting started with meta-learning. Overview \u00b6 We look into how ANIL takes advantage of feature reuse for few-shot learning. ANIL simplifies MAML by removing the inner loop for all but the task-specific head of the underlying neural network. ANIL performs as well as MAML on benchmark few-shot classification and reinforcement learning tasks, and is computationally more efficient than MAML. We implement ANIL with learn2learn and provide additional results of how ANIL performs on other datasets. Lastly, we explain the implementation code step-be-step, making it easy for users to try ANIL on other datasets. ANIL algorithm \u00b6 Among various meta-learning algorithms for few-shot learning, MAML (model-agnostic meta-learning) (Finn et al. 2017) has been highly popular due to its substantial performance on several benchmarks. Its idea is to establish a meta-learner that seeks an initialization useful for fast learning of different tasks, then adapt to specific tasks quickly (within a few steps) and efficiently (with only a few examples). There are two types of parameter updates: the outer loop and the inner loop. The outer loop updates the meta-initialization of the neural network parameters to a setting that enables fast adaptation to new tasks. The inner loop takes the outer loop initialization and performs task-specific adaptation over a few labeled samples. To read more about meta-learning and MAML, you can read the summary article written by Finn on learning to learn and Lilian Weng's review on meta-learning . In 2019, Raghu et al. conjectured that we can obtain the same rapid learning performance of MAML solely through feature reuse. To test this hypothesis, they introduced ANIL (almost no inner loop), a simplified algorithm of MAML that is equally effective but computationally faster. Rapid learning vs. feature reuse Visualizations of rapid learning and feature reuse. Diagram from Raghu et al., 2019. Before we describe ANIL, we have to understand the difference between rapid learning and feature reuse. In rapid learning , the meta-initialization in the outer loop results in a parameter setting that is favorable for fast learning, thus significant adaptation to new tasks can rapidly take place in the inner loop. In feature reuse , the meta-initialization already contains useful features that can be reused, so little adaptation on the parameters is required in the inner loop. To prove feature reuse is a competitive alternative to rapid learning in MAML, the authors proposed a simplified algorithm, ANIL, where the inner loop is removed for all but the task-specific head of the underlying neural network during training and testing. ANIL vs. MAML Now, let us illustrate the difference mathematically. Let \\theta be the set of meta-initialization parameters for the feature extractable layers of the network and w be the meta-initialization parameters for the head. We obtain the label prediction \\hat{y} = w^T\\phi_\\theta(x) , where x is the input data and \\phi is a feature extractor parametrized by \\theta . Given \\theta_i and w_i at iteration step i , the outer loop updates both parameters via gradient descent: \\theta_{i+1} = \\theta_i - \\alpha\\nabla_{\\theta_i}\\mathcal{L}_{\\tau}(w^{\\prime \\top}_i\\phi_{\\theta^\\prime_i}(x), y) w_{i+1} = w_i - \\alpha\\nabla_{w_i}\\mathcal{L}_{\\tau}(w^{\\prime \\top}_i\\phi_{\\theta^\\prime_i}(x), y) where \\mathcal{L}_\\tau is the loss computed for task \\tau , and \\alpha is the meta learning rate in the outer loop. Notice how the gradient is taken with respect to the initialization parameters w_i and \\theta_i , but the loss is computed on the adapted parameters \\theta_i^\\prime and w_i^\\prime . For one adaptation step in the inner loop, ANIL computes those adapted parameters as: \\theta_{i}^\\prime = \\theta_i w_{i}^\\prime = w_i - \\beta\\nabla_{w_i}\\mathcal{L}_{\\tau}(w_i^T\\phi_{\\theta_i}(x), y) where \\beta is the learning rate of the inner loop. Concretely, ANIL keeps the feature extractor constant and only adapts the head with gradient descent. In contrast, MAML updates both the head and the feature extractor: \\theta_{i}^\\prime = \\theta_i - \\beta\\nabla_{\\theta_i}\\mathcal{L}_{\\tau}(w_i^T\\phi_{\\theta_i}(x), y) w_{i}^\\prime = w_i - \\beta\\nabla_{w_i}\\mathcal{L}_{\\tau}(w_i^T\\phi_{\\theta_i}(x), y). Unsurprisingly, ANIL is much more computationally efficient since it requires fewer updates in the inner loop. What might be surprising, is that this efficiency comes at almost no cost in terms of performance. Results ANIL provides fast adaptation in the absence of almost all inner loop parameter updates, while still matching the performance of MAML on few-shot image classification with Mini-ImageNet and Omniglot and standard reinforcement learning tasks. Method Omniglot-20way-1shot Omniglot-20way-5shot Mini-ImageNet-5way-1shot Mini-ImageNet-5way-5shot MAML 93.7 \u00b1 0.7 96.4 \u00b1 0.1 46.9 \u00b1 0.2 63.1 \u00b1 0.4 ANIL 96.2 \u00b1 0.5 98.0 \u00b1 0.3 46.7 \u00b1 0.4 61.5 \u00b1 0.5 Using ANIL with learn2learn \u00b6 With our understanding of how ANIL works, we are ready to implement the algorithm. An example implementation on the FC100 dataset is available at: anil_fc100.py . Using this implementation, we are able to obtain the following results on datasets such as Mini-ImageNet, CIFAR-FS and FC100 as well. Dataset Architecture Ways Shots Original learn2learn Mini-ImageNet CNN 5 5 61.5% 63.2% CIFAR-FS CNN 5 5 n/a 68.3% FC100 CNN 5 5 n/a 47.6% ANIL Implementation \u00b6 This section breaks down step-by-step the ANIL implementation with our example code. Creating dataset 1 2 3 4 train_dataset = l2l . vision . datasets . FC100 ( root = '~/data' , transform = tv . transforms . ToTensor (), mode = 'train' ) train_dataset = l2l . data . MetaDataset ( train_dataset ) First, data are obtained and separated into train, validation and test dataset with l2l.vision.datasets.FC100 . tv.transforms.ToTensor() converts Python Imaging Library (PIL) images to PyTorch tensors. l2l.data.MetaDataset is a thin wrapper around torch datasets that automatically generates bookkeeping information to create new tasks. 1 2 3 4 5 6 7 8 9 train_transforms = [ FusedNWaysKShots ( train_dataset , n = ways , k = 2 * shots ), LoadData ( train_dataset ), RemapLabels ( train_dataset ), ConsecutiveLabels ( train_dataset ), ] train_tasks = l2l . data . TaskDataset ( train_dataset , task_transforms = train_transforms , num_tasks = 20000 ) l2l.data.TaskDataset creates a set of tasks from the MetaDataset using a list of task transformations: FusedNWaysKShots(dataset, n=ways, k=2*shots) : efficient implementation to keep k data samples from n randomly sampled labels. LoadData(dataset) : loads a sample from the dataset given its index. RemapLabels(dataset) : given samples from n classes, maps the labels to 0, \\dots, n . ConsecutiveLabels(dataset) : re-orders the samples in the task description such that they are sorted in consecutive order. Question Why k = 2*shots ? The number of samples k is twice the number of shots because one half of the samples are for adaption and the other half are for evaluation in the inner loop. Info For more details, please refer to the documentation of learn2learn.data . Creating model 1 2 3 4 5 6 features = l2l . vision . models . ConvBase ( output_size = 64 , channels = 3 , max_pool = True ) features = torch . nn . Sequential ( features , Lambda ( lambda x : x . view ( - 1 , 256 ))) features . to ( device ) head = torch . nn . Linear ( 256 , ways ) head = l2l . algorithms . MAML ( head , lr = fast_lr ) head . to ( device ) We then instantiate two modules, one for features and one for the head. ConvBase instantiates a four-layer CNN, and the head is a fully connected layer. Because we are not updating the feature extractor parameters, we only need to wrap the head with the l2l.algorithms.MAML() wrapper, which takes in the fast adaptation learning rate fast_lr used for the inner loop later. Info For more details on the MAML wrapper, please refer to the documentation of l2l.algorithms . Optimization setup 1 2 3 all_parameters = list ( features . parameters ()) + list ( head . parameters ()) optimizer = torch . optim . Adam ( all_parameters , lr = meta_lr ) loss = nn . CrossEntropyLoss ( reduction = 'mean' ) Next, we set up the optimizer with mini-batch SGD using torch.optim.Adam , which takes in both feature and head parameters, and learning rate meta_lr used for the outer loop. Outer loop 1 2 3 4 5 6 for iteration in range ( iters ): ... for task in range ( meta_bsz ): learner = head . clone () batch = train_tasks . sample () ... For training, validation and testing, we first sample a task, then copy the head with head.clone() , which is a method exposed by the MAML wrapper for PyTorch modules, akin to tensor.clone() for PyTorch tensors. Calling clone() allows us to update the parameters of the clone while maintaining ability to back-propagate to the parameters in head . There's no need for feature.clone() as we are only adapting the head. Inner loop 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def fast_adapt ( batch , learner , features , loss , adaptation_steps , shots , ways , device = None ): data , labels = batch data , labels = data . to ( device ), labels . to ( device ) data = features ( data ) # Separate data into adaptation/evaluation sets adaptation_indices = np . zeros ( data . size ( 0 ), dtype = bool ) adaptation_indices [ np . arange ( shots * ways ) * 2 ] = True evaluation_indices = torch . from_numpy ( ~ adaptation_indices ) adaptation_indices = torch . from_numpy ( adaptation_indices ) adaptation_data , adaptation_labels = data [ adaptation_indices ], labels [ adaptation_indices ] evaluation_data , evaluation_labels = data [ evaluation_indices ], labels [ evaluation_indices ] for step in range ( adaptation_steps ): train_error = loss ( learner ( adaptation_data ), adaptation_labels ) learner . adapt ( train_error ) predictions = learner ( evaluation_data ) valid_error = loss ( predictions , evaluation_labels ) valid_accuracy = accuracy ( predictions , evaluation_labels ) return valid_error , valid_accuracy In fast_adapt() , we separate data into adaptation and evaluation sets with k shot samples each. In each adaptation step, learner.adapt() takes a gradient step on the loss and updates the cloned parameter, learner , such that we can back-propagate through the adaptation step. Under the hood, this is achieved by calling torch.autograd.grad() and setting create_graph=True . fast_adapt() then returns the evaluation loss and accuracy based on the predicted and true labels. Question Why is the number of adaptation steps so small? To demonstrate fast adaptation, we want the algorithm to adapt to each specific task quickly within a few steps. Since the number of samples is so small in few-shot learning, increasing number of adaptation steps would not help raising the performance. Closing the outer loop 1 2 3 4 5 6 7 8 evaluation_error . backward () meta_train_error += evaluation_error . item () meta_train_accuracy += evaluation_accuracy . item () ... # Average the accumulated gradients and optimize for p in all_parameters : p . grad . data . mul_ ( 1.0 / meta_bsz ) optimizer . step () We compute the gradients with evaluation_error.backward() right after the inner loop updates to free activation and adaptation buffers from memory as early as possible. Lastly, after collecting the gradients, we average the accumulated gradients and updates the parameter at the end of each iteration with optimizer.step() . Conclusion \u00b6 Having explained the inner-workings of ANIL and its code implementation with learn2learn, I hope this tutorial will be helpful to those who are interested in using ANIL for their own research and applications. References \u00b6 Raghu, A., Raghu, M., Bengio, S., & Vinyals, O. (2019). Rapid Learning or Feature Reuse? Towards Understanding the Effectiveness of MAML. In arXiv [cs.LG]. arXiv. http://arxiv.org/abs/1909.09157 Finn, C., Abbeel, P., & Levine, S. (2017). Model-Agnostic Meta-Learning for Fast Adaptation of Deep Networks. In arXiv [cs.LG]. arXiv. http://arxiv.org/abs/1703.03400","title":"Feature Reuse with ANIL"},{"location":"_build/pydocmd/tutorials/anil_tutorial/ANIL_tutorial/#feature-reuse-with-anil","text":"Written by Ewina Pun on 3/30/2020. In this article, we will dive into a meta-learning algorithm called ANIL (Almost No Inner Loop) presented by Raghu et al., 2019 , and explain how to implement it with learn2learn. Note This tutorial is written for experienced PyTorch users who are getting started with meta-learning.","title":"Feature Reuse with ANIL"},{"location":"_build/pydocmd/tutorials/anil_tutorial/ANIL_tutorial/#overview","text":"We look into how ANIL takes advantage of feature reuse for few-shot learning. ANIL simplifies MAML by removing the inner loop for all but the task-specific head of the underlying neural network. ANIL performs as well as MAML on benchmark few-shot classification and reinforcement learning tasks, and is computationally more efficient than MAML. We implement ANIL with learn2learn and provide additional results of how ANIL performs on other datasets. Lastly, we explain the implementation code step-be-step, making it easy for users to try ANIL on other datasets.","title":"Overview"},{"location":"_build/pydocmd/tutorials/anil_tutorial/ANIL_tutorial/#anil-algorithm","text":"Among various meta-learning algorithms for few-shot learning, MAML (model-agnostic meta-learning) (Finn et al. 2017) has been highly popular due to its substantial performance on several benchmarks. Its idea is to establish a meta-learner that seeks an initialization useful for fast learning of different tasks, then adapt to specific tasks quickly (within a few steps) and efficiently (with only a few examples). There are two types of parameter updates: the outer loop and the inner loop. The outer loop updates the meta-initialization of the neural network parameters to a setting that enables fast adaptation to new tasks. The inner loop takes the outer loop initialization and performs task-specific adaptation over a few labeled samples. To read more about meta-learning and MAML, you can read the summary article written by Finn on learning to learn and Lilian Weng's review on meta-learning . In 2019, Raghu et al. conjectured that we can obtain the same rapid learning performance of MAML solely through feature reuse. To test this hypothesis, they introduced ANIL (almost no inner loop), a simplified algorithm of MAML that is equally effective but computationally faster. Rapid learning vs. feature reuse Visualizations of rapid learning and feature reuse. Diagram from Raghu et al., 2019. Before we describe ANIL, we have to understand the difference between rapid learning and feature reuse. In rapid learning , the meta-initialization in the outer loop results in a parameter setting that is favorable for fast learning, thus significant adaptation to new tasks can rapidly take place in the inner loop. In feature reuse , the meta-initialization already contains useful features that can be reused, so little adaptation on the parameters is required in the inner loop. To prove feature reuse is a competitive alternative to rapid learning in MAML, the authors proposed a simplified algorithm, ANIL, where the inner loop is removed for all but the task-specific head of the underlying neural network during training and testing. ANIL vs. MAML Now, let us illustrate the difference mathematically. Let \\theta be the set of meta-initialization parameters for the feature extractable layers of the network and w be the meta-initialization parameters for the head. We obtain the label prediction \\hat{y} = w^T\\phi_\\theta(x) , where x is the input data and \\phi is a feature extractor parametrized by \\theta . Given \\theta_i and w_i at iteration step i , the outer loop updates both parameters via gradient descent: \\theta_{i+1} = \\theta_i - \\alpha\\nabla_{\\theta_i}\\mathcal{L}_{\\tau}(w^{\\prime \\top}_i\\phi_{\\theta^\\prime_i}(x), y) w_{i+1} = w_i - \\alpha\\nabla_{w_i}\\mathcal{L}_{\\tau}(w^{\\prime \\top}_i\\phi_{\\theta^\\prime_i}(x), y) where \\mathcal{L}_\\tau is the loss computed for task \\tau , and \\alpha is the meta learning rate in the outer loop. Notice how the gradient is taken with respect to the initialization parameters w_i and \\theta_i , but the loss is computed on the adapted parameters \\theta_i^\\prime and w_i^\\prime . For one adaptation step in the inner loop, ANIL computes those adapted parameters as: \\theta_{i}^\\prime = \\theta_i w_{i}^\\prime = w_i - \\beta\\nabla_{w_i}\\mathcal{L}_{\\tau}(w_i^T\\phi_{\\theta_i}(x), y) where \\beta is the learning rate of the inner loop. Concretely, ANIL keeps the feature extractor constant and only adapts the head with gradient descent. In contrast, MAML updates both the head and the feature extractor: \\theta_{i}^\\prime = \\theta_i - \\beta\\nabla_{\\theta_i}\\mathcal{L}_{\\tau}(w_i^T\\phi_{\\theta_i}(x), y) w_{i}^\\prime = w_i - \\beta\\nabla_{w_i}\\mathcal{L}_{\\tau}(w_i^T\\phi_{\\theta_i}(x), y). Unsurprisingly, ANIL is much more computationally efficient since it requires fewer updates in the inner loop. What might be surprising, is that this efficiency comes at almost no cost in terms of performance. Results ANIL provides fast adaptation in the absence of almost all inner loop parameter updates, while still matching the performance of MAML on few-shot image classification with Mini-ImageNet and Omniglot and standard reinforcement learning tasks. Method Omniglot-20way-1shot Omniglot-20way-5shot Mini-ImageNet-5way-1shot Mini-ImageNet-5way-5shot MAML 93.7 \u00b1 0.7 96.4 \u00b1 0.1 46.9 \u00b1 0.2 63.1 \u00b1 0.4 ANIL 96.2 \u00b1 0.5 98.0 \u00b1 0.3 46.7 \u00b1 0.4 61.5 \u00b1 0.5","title":"ANIL algorithm"},{"location":"_build/pydocmd/tutorials/anil_tutorial/ANIL_tutorial/#using-anil-with-learn2learn","text":"With our understanding of how ANIL works, we are ready to implement the algorithm. An example implementation on the FC100 dataset is available at: anil_fc100.py . Using this implementation, we are able to obtain the following results on datasets such as Mini-ImageNet, CIFAR-FS and FC100 as well. Dataset Architecture Ways Shots Original learn2learn Mini-ImageNet CNN 5 5 61.5% 63.2% CIFAR-FS CNN 5 5 n/a 68.3% FC100 CNN 5 5 n/a 47.6%","title":"Using ANIL with learn2learn"},{"location":"_build/pydocmd/tutorials/anil_tutorial/ANIL_tutorial/#anil-implementation","text":"This section breaks down step-by-step the ANIL implementation with our example code. Creating dataset 1 2 3 4 train_dataset = l2l . vision . datasets . FC100 ( root = '~/data' , transform = tv . transforms . ToTensor (), mode = 'train' ) train_dataset = l2l . data . MetaDataset ( train_dataset ) First, data are obtained and separated into train, validation and test dataset with l2l.vision.datasets.FC100 . tv.transforms.ToTensor() converts Python Imaging Library (PIL) images to PyTorch tensors. l2l.data.MetaDataset is a thin wrapper around torch datasets that automatically generates bookkeeping information to create new tasks. 1 2 3 4 5 6 7 8 9 train_transforms = [ FusedNWaysKShots ( train_dataset , n = ways , k = 2 * shots ), LoadData ( train_dataset ), RemapLabels ( train_dataset ), ConsecutiveLabels ( train_dataset ), ] train_tasks = l2l . data . TaskDataset ( train_dataset , task_transforms = train_transforms , num_tasks = 20000 ) l2l.data.TaskDataset creates a set of tasks from the MetaDataset using a list of task transformations: FusedNWaysKShots(dataset, n=ways, k=2*shots) : efficient implementation to keep k data samples from n randomly sampled labels. LoadData(dataset) : loads a sample from the dataset given its index. RemapLabels(dataset) : given samples from n classes, maps the labels to 0, \\dots, n . ConsecutiveLabels(dataset) : re-orders the samples in the task description such that they are sorted in consecutive order. Question Why k = 2*shots ? The number of samples k is twice the number of shots because one half of the samples are for adaption and the other half are for evaluation in the inner loop. Info For more details, please refer to the documentation of learn2learn.data . Creating model 1 2 3 4 5 6 features = l2l . vision . models . ConvBase ( output_size = 64 , channels = 3 , max_pool = True ) features = torch . nn . Sequential ( features , Lambda ( lambda x : x . view ( - 1 , 256 ))) features . to ( device ) head = torch . nn . Linear ( 256 , ways ) head = l2l . algorithms . MAML ( head , lr = fast_lr ) head . to ( device ) We then instantiate two modules, one for features and one for the head. ConvBase instantiates a four-layer CNN, and the head is a fully connected layer. Because we are not updating the feature extractor parameters, we only need to wrap the head with the l2l.algorithms.MAML() wrapper, which takes in the fast adaptation learning rate fast_lr used for the inner loop later. Info For more details on the MAML wrapper, please refer to the documentation of l2l.algorithms . Optimization setup 1 2 3 all_parameters = list ( features . parameters ()) + list ( head . parameters ()) optimizer = torch . optim . Adam ( all_parameters , lr = meta_lr ) loss = nn . CrossEntropyLoss ( reduction = 'mean' ) Next, we set up the optimizer with mini-batch SGD using torch.optim.Adam , which takes in both feature and head parameters, and learning rate meta_lr used for the outer loop. Outer loop 1 2 3 4 5 6 for iteration in range ( iters ): ... for task in range ( meta_bsz ): learner = head . clone () batch = train_tasks . sample () ... For training, validation and testing, we first sample a task, then copy the head with head.clone() , which is a method exposed by the MAML wrapper for PyTorch modules, akin to tensor.clone() for PyTorch tensors. Calling clone() allows us to update the parameters of the clone while maintaining ability to back-propagate to the parameters in head . There's no need for feature.clone() as we are only adapting the head. Inner loop 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def fast_adapt ( batch , learner , features , loss , adaptation_steps , shots , ways , device = None ): data , labels = batch data , labels = data . to ( device ), labels . to ( device ) data = features ( data ) # Separate data into adaptation/evaluation sets adaptation_indices = np . zeros ( data . size ( 0 ), dtype = bool ) adaptation_indices [ np . arange ( shots * ways ) * 2 ] = True evaluation_indices = torch . from_numpy ( ~ adaptation_indices ) adaptation_indices = torch . from_numpy ( adaptation_indices ) adaptation_data , adaptation_labels = data [ adaptation_indices ], labels [ adaptation_indices ] evaluation_data , evaluation_labels = data [ evaluation_indices ], labels [ evaluation_indices ] for step in range ( adaptation_steps ): train_error = loss ( learner ( adaptation_data ), adaptation_labels ) learner . adapt ( train_error ) predictions = learner ( evaluation_data ) valid_error = loss ( predictions , evaluation_labels ) valid_accuracy = accuracy ( predictions , evaluation_labels ) return valid_error , valid_accuracy In fast_adapt() , we separate data into adaptation and evaluation sets with k shot samples each. In each adaptation step, learner.adapt() takes a gradient step on the loss and updates the cloned parameter, learner , such that we can back-propagate through the adaptation step. Under the hood, this is achieved by calling torch.autograd.grad() and setting create_graph=True . fast_adapt() then returns the evaluation loss and accuracy based on the predicted and true labels. Question Why is the number of adaptation steps so small? To demonstrate fast adaptation, we want the algorithm to adapt to each specific task quickly within a few steps. Since the number of samples is so small in few-shot learning, increasing number of adaptation steps would not help raising the performance. Closing the outer loop 1 2 3 4 5 6 7 8 evaluation_error . backward () meta_train_error += evaluation_error . item () meta_train_accuracy += evaluation_accuracy . item () ... # Average the accumulated gradients and optimize for p in all_parameters : p . grad . data . mul_ ( 1.0 / meta_bsz ) optimizer . step () We compute the gradients with evaluation_error.backward() right after the inner loop updates to free activation and adaptation buffers from memory as early as possible. Lastly, after collecting the gradients, we average the accumulated gradients and updates the parameter at the end of each iteration with optimizer.step() .","title":"ANIL Implementation"},{"location":"_build/pydocmd/tutorials/anil_tutorial/ANIL_tutorial/#conclusion","text":"Having explained the inner-workings of ANIL and its code implementation with learn2learn, I hope this tutorial will be helpful to those who are interested in using ANIL for their own research and applications.","title":"Conclusion"},{"location":"_build/pydocmd/tutorials/anil_tutorial/ANIL_tutorial/#references","text":"Raghu, A., Raghu, M., Bengio, S., & Vinyals, O. (2019). Rapid Learning or Feature Reuse? Towards Understanding the Effectiveness of MAML. In arXiv [cs.LG]. arXiv. http://arxiv.org/abs/1909.09157 Finn, C., Abbeel, P., & Levine, S. (2017). Model-Agnostic Meta-Learning for Fast Adaptation of Deep Networks. In arXiv [cs.LG]. arXiv. http://arxiv.org/abs/1703.03400","title":"References"},{"location":"docs/learn2learn.algorithms/","text":"learn2learn.algorithms \u00b6 High-Level Interfaces \u00b6 MAML ( BaseLearner ) \u00b6 [Source] Description High-level implementation of Model-Agnostic Meta-Learning . This class wraps an arbitrary nn.Module and augments it with clone() and adapt() methods. For the first-order version of MAML (i.e. FOMAML), set the first_order flag to True upon initialization. Arguments model (Module) - Module to be wrapped. lr (float) - Fast adaptation learning rate. first_order (bool, optional , default=False) - Whether to use the first-order approximation of MAML. (FOMAML) allow_unused (bool, optional , default=None) - Whether to allow differentiation of unused parameters. Defaults to allow_nograd . allow_nograd (bool, optional , default=False) - Whether to allow adaptation with parameters that have requires_grad = False . References Finn et al. 2017. \"Model-Agnostic Meta-Learning for Fast Adaptation of Deep Networks.\" Example 1 2 3 4 5 6 linear = l2l . algorithms . MAML ( nn . Linear ( 20 , 10 ), lr = 0.01 ) clone = linear . clone () error = loss ( clone ( X ), y ) clone . adapt ( error ) error = loss ( clone ( X ), y ) error . backward () adapt ( self , loss , first_order = None , allow_unused = None , allow_nograd = None ) \u00b6 Description Takes a gradient step on the loss and updates the cloned parameters in place. Arguments loss (Tensor) - Loss to minimize upon update. first_order (bool, optional , default=None) - Whether to use first- or second-order updates. Defaults to self.first_order. allow_unused (bool, optional , default=None) - Whether to allow differentiation of unused parameters. Defaults to self.allow_unused. allow_nograd (bool, optional , default=None) - Whether to allow adaptation with parameters that have requires_grad = False . Defaults to self.allow_nograd. clone ( self , first_order = None , allow_unused = None , allow_nograd = None ) \u00b6 Description Returns a MAML -wrapped copy of the module whose parameters and buffers are torch.clone d from the original module. This implies that back-propagating losses on the cloned module will populate the buffers of the original module. For more information, refer to learn2learn.clone_module(). Arguments first_order (bool, optional , default=None) - Whether the clone uses first- or second-order updates. Defaults to self.first_order. allow_unused (bool, optional , default=None) - Whether to allow differentiation of unused parameters. Defaults to self.allow_unused. allow_nograd (bool, optional , default=False) - Whether to allow adaptation with parameters that have requires_grad = False . Defaults to self.allow_nograd. MetaSGD ( BaseLearner ) \u00b6 [Source] Description High-level implementation of Meta-SGD . This class wraps an arbitrary nn.Module and augments it with clone() and adapt methods. It behaves similarly to MAML , but in addition a set of per-parameters learning rates are learned for fast-adaptation. Arguments model (Module) - Module to be wrapped. lr (float) - Initialization value of the per-parameter fast adaptation learning rates. first_order (bool, optional , default=False) - Whether to use the first-order version. lrs (list of Parameters, optional , default=None) - If not None, overrides lr , and uses the list as learning rates for fast-adaptation. References Li et al. 2017. \u201cMeta-SGD: Learning to Learn Quickly for Few-Shot Learning.\u201d arXiv. Example 1 2 3 4 5 6 linear = l2l . algorithms . MetaSGD ( nn . Linear ( 20 , 10 ), lr = 0.01 ) clone = linear . clone () error = loss ( clone ( X ), y ) clone . adapt ( error ) error = loss ( clone ( X ), y ) error . backward () adapt ( self , loss , first_order = None ) \u00b6 Descritpion Akin to MAML.adapt() but for MetaSGD: it updates the model with the learnable per-parameter learning rates. clone ( self ) \u00b6 Descritpion Akin to MAML.clone() but for MetaSGD: it includes a set of learnable fast-adaptation learning rates. GBML ( Module ) \u00b6 [Source] Description General wrapper for gradient-based meta-learning implementations. A variety of algorithms can simply be implemented by changing the kind of transform used during fast-adaptation. For example, if the transform is Scale we recover Meta-SGD [2] with adapt_transform=False and Alpha MAML [4] with adapt_transform=True . If the transform is a Kronecker-factored module (e.g. neural network, or linear), we recover KFO from [5]. Arguments module (Module) - Module to be wrapped. tranform (Module) - Transform used to update the module. lr (float) - Fast adaptation learning rate. adapt_transform (bool, optional , default=False) - Whether to update the transform's parameters during fast-adaptation. first_order (bool, optional , default=False) - Whether to use the first-order approximation. allow_unused (bool, optional , default=None) - Whether to allow differentiation of unused parameters. Defaults to allow_nograd . allow_nograd (bool, optional , default=False) - Whether to allow adaptation with parameters that have requires_grad = False . References Finn et al. 2017. \u201cModel-Agnostic Meta-Learning for Fast Adaptation of Deep Networks.\u201d Li et al. 2017. \u201cMeta-SGD: Learning to Learn Quickly for Few-Shot Learning.\u201d Park & Oliva. 2019. \u201cMeta-Curvature.\u201d Behl et al. 2019. \u201cAlpha MAML: Adaptive Model-Agnostic Meta-Learning.\u201d Arnold et al. 2019. \u201cWhen MAML Can Adapt Fast and How to Assist When It Cannot.\u201d Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 model = SmallCNN () transform = l2l . optim . ModuleTransform ( torch . nn . Linear ) gbml = l2l . algorithms . GBML ( module = model , transform = transform , lr = 0.01 , adapt_transform = True , ) gbml . to ( device ) opt = torch . optim . SGD ( gbml . parameters (), lr = 0.001 ) # Training with 1 adaptation step for iteration in range ( 10 ): opt . zero_grad () task_model = gbml . clone () loss = compute_loss ( task_model ) task_model . adapt ( loss ) loss . backward () opt . step () adapt ( self , loss , first_order = None , allow_nograd = None , allow_unused = None ) \u00b6 Description Takes a gradient step on the loss and updates the cloned parameters in place. The parameters of the transform are only adapted if self.adapt_update is True . Arguments loss (Tensor) - Loss to minimize upon update. first_order (bool, optional , default=None) - Whether to use first- or second-order updates. Defaults to self.first_order. allow_unused (bool, optional , default=None) - Whether to allow differentiation of unused parameters. Defaults to self.allow_unused. allow_nograd (bool, optional , default=None) - Whether to allow adaptation with parameters that have requires_grad = False . Defaults to self.allow_nograd. clone ( self , first_order = None , allow_unused = None , allow_nograd = None , adapt_transform = None ) \u00b6 Description Similar to MAML.clone() . Arguments first_order (bool, optional , default=None) - Whether the clone uses first- or second-order updates. Defaults to self.first_order. allow_unused (bool, optional , default=None) - Whether to allow differentiation of unused parameters. Defaults to self.allow_unused. allow_nograd (bool, optional , default=False) - Whether to allow adaptation with parameters that have requires_grad = False . Defaults to self.allow_nograd. PyTorch Lightning \u00b6 LightningMAML ( LightningEpisodicModule ) \u00b6 [Source] Description A PyTorch Lightning module for MAML. Arguments model (Module) - A PyTorch nn.Module. loss (Function, optional , default=CrossEntropyLoss) - Loss function which maps the cost of the events. ways (int, optional , default=5) - Number of classes in a task. shots (int, optional , default=1) - Number of samples for adaptation. adaptation_steps (int, optional , default=1) - Number of steps for adapting to new task. lr (float, optional , default=0.001) - Learning rate of meta training. adaptation_lr (float, optional , default=0.1) - Learning rate for fast adaptation. scheduler_step (int, optional , default=20) - Decay interval for lr . scheduler_decay (float, optional , default=1.0) - Decay rate for lr . References Finn et al. 2017. \"Model-Agnostic Meta-Learning for Fast Adaptation of Deep Networks.\" Example 1 2 3 4 5 6 tasksets = l2l . vision . benchmarks . get_tasksets ( 'omniglot' ) model = l2l . vision . models . OmniglotFC ( 28 ** 2 , args . ways ) maml = LightningMAML ( classifier , adaptation_lr = 0.1 , ** dict_args ) episodic_data = EpisodicBatcher ( tasksets . train , tasksets . validation , tasksets . test ) trainer = pl . Trainer . from_argparse_args ( args ) trainer . fit ( maml , episodic_data ) LightningANIL ( LightningEpisodicModule ) \u00b6 [Source] Description A PyTorch Lightning module for ANIL. Arguments features (Module) - A nn.Module to extract features, which will not be adaptated. classifier (Module) - A nn.Module taking features, mapping them to classification. loss (Function, optional , default=CrossEntropyLoss) - Loss function which maps the cost of the events. ways (int, optional , default=5) - Number of classes in a task. shots (int, optional , default=1) - Number of samples for adaptation. adaptation_steps (int, optional , default=1) - Number of steps for adapting to new task. lr (float, optional , default=0.001) - Learning rate of meta training. adaptation_lr (float, optional , default=0.1) - Learning rate for fast adaptation. scheduler_step (int, optional , default=20) - Decay interval for lr . scheduler_decay (float, optional , default=1.0) - Decay rate for lr . References Raghu et al. 2020. \"Rapid Learning or Feature Reuse? Towards Understanding the Effectiveness of MAML\" Example 1 2 3 4 5 6 tasksets = l2l . vision . benchmarks . get_tasksets ( 'omniglot' ) model = l2l . vision . models . OmniglotFC ( 28 ** 2 , args . ways ) anil = LightningANIL ( model . features , model . classifier , adaptation_lr = 0.1 , ** dict_args ) episodic_data = EpisodicBatcher ( tasksets . train , tasksets . validation , tasksets . test ) trainer = pl . Trainer . from_argparse_args ( args ) trainer . fit ( anil , episodic_data ) LightningPrototypicalNetworks ( LightningEpisodicModule ) \u00b6 [Source] Description A PyTorch Lightning module for Prototypical Networks. Arguments features (Module) - Feature extractor which classifies input tasks. loss (Function, optional , default=CrossEntropyLoss) - Loss function which maps the cost of the events. distance_metric (str, optional , default='euclidean') - Distance metric between samples. ['euclidean', 'cosine'] train_ways (int, optional , default=5) - Number of classes in for train tasks. train_shots (int, optional , default=1) - Number of support samples for train tasks. train_queries (int, optional , default=1) - Number of query samples for train tasks. test_ways (int, optional , default=5) - Number of classes in for test tasks. test_shots (int, optional , default=1) - Number of support samples for test tasks. test_queries (int, optional , default=1) - Number of query samples for test tasks. lr (float, optional , default=0.001) - Learning rate of meta training. scheduler_step (int, optional , default=20) - Decay interval for lr . scheduler_decay (float, optional , default=1.0) - Decay rate for lr . References Snell et al. 2017. \"Prototypical Networks for Few-shot Learning\" Example 1 2 3 4 5 6 tasksets = l2l . vision . benchmarks . get_tasksets ( 'mini-imagenet' ) features = Convnet () # init model protonet = LightningPrototypicalNetworks ( features , ** dict_args ) episodic_data = EpisodicBatcher ( tasksets . train , tasksets . validation , tasksets . test ) trainer = pl . Trainer . from_argparse_args ( args ) trainer . fit ( protonet , episodic_data ) LightningMetaOptNet ( LightningPrototypicalNetworks ) \u00b6 [Source] Description A PyTorch Lightning module for MetaOptNet. Arguments features (Module) - Feature extractor which classifies input tasks. svm_C_reg (float, optional , default=0.1) - Regularization weight for SVM. svm_max_iters (int, optional , default=15) - Maximum number of iterations for SVM convergence. loss (Function, optional , default=CrossEntropyLoss) - Loss function which maps the cost of the events. train_ways (int, optional , default=5) - Number of classes in for train tasks. train_shots (int, optional , default=1) - Number of support samples for train tasks. train_queries (int, optional , default=1) - Number of query samples for train tasks. test_ways (int, optional , default=5) - Number of classes in for test tasks. test_shots (int, optional , default=1) - Number of support samples for test tasks. test_queries (int, optional , default=1) - Number of query samples for test tasks. lr (float, optional , default=0.001) - Learning rate of meta training. scheduler_step (int, optional , default=20) - Decay interval for lr . scheduler_decay (float, optional , default=1.0) - Decay rate for lr . References Lee et al. 2019. \"Meta-Learning with Differentiable Convex Optimization\" Example 1 2 3 4 5 6 tasksets = l2l . vision . benchmarks . get_tasksets ( 'mini-imagenet' ) features = Convnet () # init model metaoptnet = LightningMetaOptNet ( features , ** dict_args ) episodic_data = EpisodicBatcher ( tasksets . train , tasksets . validation , tasksets . test ) trainer = pl . Trainer . from_argparse_args ( args ) trainer . fit ( metaoptnet , episodic_data )","title":"learn2learn.algorithms"},{"location":"docs/learn2learn.algorithms/#learn2learnalgorithms","text":"","title":"learn2learn.algorithms"},{"location":"docs/learn2learn.algorithms/#high-level-interfaces","text":"","title":"High-Level Interfaces"},{"location":"docs/learn2learn.algorithms/#learn2learn.algorithms.maml.MAML","text":"[Source] Description High-level implementation of Model-Agnostic Meta-Learning . This class wraps an arbitrary nn.Module and augments it with clone() and adapt() methods. For the first-order version of MAML (i.e. FOMAML), set the first_order flag to True upon initialization. Arguments model (Module) - Module to be wrapped. lr (float) - Fast adaptation learning rate. first_order (bool, optional , default=False) - Whether to use the first-order approximation of MAML. (FOMAML) allow_unused (bool, optional , default=None) - Whether to allow differentiation of unused parameters. Defaults to allow_nograd . allow_nograd (bool, optional , default=False) - Whether to allow adaptation with parameters that have requires_grad = False . References Finn et al. 2017. \"Model-Agnostic Meta-Learning for Fast Adaptation of Deep Networks.\" Example 1 2 3 4 5 6 linear = l2l . algorithms . MAML ( nn . Linear ( 20 , 10 ), lr = 0.01 ) clone = linear . clone () error = loss ( clone ( X ), y ) clone . adapt ( error ) error = loss ( clone ( X ), y ) error . backward ()","title":"MAML"},{"location":"docs/learn2learn.algorithms/#learn2learn.algorithms.maml.MAML.adapt","text":"Description Takes a gradient step on the loss and updates the cloned parameters in place. Arguments loss (Tensor) - Loss to minimize upon update. first_order (bool, optional , default=None) - Whether to use first- or second-order updates. Defaults to self.first_order. allow_unused (bool, optional , default=None) - Whether to allow differentiation of unused parameters. Defaults to self.allow_unused. allow_nograd (bool, optional , default=None) - Whether to allow adaptation with parameters that have requires_grad = False . Defaults to self.allow_nograd.","title":"adapt()"},{"location":"docs/learn2learn.algorithms/#learn2learn.algorithms.maml.MAML.clone","text":"Description Returns a MAML -wrapped copy of the module whose parameters and buffers are torch.clone d from the original module. This implies that back-propagating losses on the cloned module will populate the buffers of the original module. For more information, refer to learn2learn.clone_module(). Arguments first_order (bool, optional , default=None) - Whether the clone uses first- or second-order updates. Defaults to self.first_order. allow_unused (bool, optional , default=None) - Whether to allow differentiation of unused parameters. Defaults to self.allow_unused. allow_nograd (bool, optional , default=False) - Whether to allow adaptation with parameters that have requires_grad = False . Defaults to self.allow_nograd.","title":"clone()"},{"location":"docs/learn2learn.algorithms/#learn2learn.algorithms.meta_sgd.MetaSGD","text":"[Source] Description High-level implementation of Meta-SGD . This class wraps an arbitrary nn.Module and augments it with clone() and adapt methods. It behaves similarly to MAML , but in addition a set of per-parameters learning rates are learned for fast-adaptation. Arguments model (Module) - Module to be wrapped. lr (float) - Initialization value of the per-parameter fast adaptation learning rates. first_order (bool, optional , default=False) - Whether to use the first-order version. lrs (list of Parameters, optional , default=None) - If not None, overrides lr , and uses the list as learning rates for fast-adaptation. References Li et al. 2017. \u201cMeta-SGD: Learning to Learn Quickly for Few-Shot Learning.\u201d arXiv. Example 1 2 3 4 5 6 linear = l2l . algorithms . MetaSGD ( nn . Linear ( 20 , 10 ), lr = 0.01 ) clone = linear . clone () error = loss ( clone ( X ), y ) clone . adapt ( error ) error = loss ( clone ( X ), y ) error . backward ()","title":"MetaSGD"},{"location":"docs/learn2learn.algorithms/#learn2learn.algorithms.meta_sgd.MetaSGD.adapt","text":"Descritpion Akin to MAML.adapt() but for MetaSGD: it updates the model with the learnable per-parameter learning rates.","title":"adapt()"},{"location":"docs/learn2learn.algorithms/#learn2learn.algorithms.meta_sgd.MetaSGD.clone","text":"Descritpion Akin to MAML.clone() but for MetaSGD: it includes a set of learnable fast-adaptation learning rates.","title":"clone()"},{"location":"docs/learn2learn.algorithms/#learn2learn.algorithms.gbml.GBML","text":"[Source] Description General wrapper for gradient-based meta-learning implementations. A variety of algorithms can simply be implemented by changing the kind of transform used during fast-adaptation. For example, if the transform is Scale we recover Meta-SGD [2] with adapt_transform=False and Alpha MAML [4] with adapt_transform=True . If the transform is a Kronecker-factored module (e.g. neural network, or linear), we recover KFO from [5]. Arguments module (Module) - Module to be wrapped. tranform (Module) - Transform used to update the module. lr (float) - Fast adaptation learning rate. adapt_transform (bool, optional , default=False) - Whether to update the transform's parameters during fast-adaptation. first_order (bool, optional , default=False) - Whether to use the first-order approximation. allow_unused (bool, optional , default=None) - Whether to allow differentiation of unused parameters. Defaults to allow_nograd . allow_nograd (bool, optional , default=False) - Whether to allow adaptation with parameters that have requires_grad = False . References Finn et al. 2017. \u201cModel-Agnostic Meta-Learning for Fast Adaptation of Deep Networks.\u201d Li et al. 2017. \u201cMeta-SGD: Learning to Learn Quickly for Few-Shot Learning.\u201d Park & Oliva. 2019. \u201cMeta-Curvature.\u201d Behl et al. 2019. \u201cAlpha MAML: Adaptive Model-Agnostic Meta-Learning.\u201d Arnold et al. 2019. \u201cWhen MAML Can Adapt Fast and How to Assist When It Cannot.\u201d Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 model = SmallCNN () transform = l2l . optim . ModuleTransform ( torch . nn . Linear ) gbml = l2l . algorithms . GBML ( module = model , transform = transform , lr = 0.01 , adapt_transform = True , ) gbml . to ( device ) opt = torch . optim . SGD ( gbml . parameters (), lr = 0.001 ) # Training with 1 adaptation step for iteration in range ( 10 ): opt . zero_grad () task_model = gbml . clone () loss = compute_loss ( task_model ) task_model . adapt ( loss ) loss . backward () opt . step ()","title":"GBML"},{"location":"docs/learn2learn.algorithms/#learn2learn.algorithms.gbml.GBML.adapt","text":"Description Takes a gradient step on the loss and updates the cloned parameters in place. The parameters of the transform are only adapted if self.adapt_update is True . Arguments loss (Tensor) - Loss to minimize upon update. first_order (bool, optional , default=None) - Whether to use first- or second-order updates. Defaults to self.first_order. allow_unused (bool, optional , default=None) - Whether to allow differentiation of unused parameters. Defaults to self.allow_unused. allow_nograd (bool, optional , default=None) - Whether to allow adaptation with parameters that have requires_grad = False . Defaults to self.allow_nograd.","title":"adapt()"},{"location":"docs/learn2learn.algorithms/#learn2learn.algorithms.gbml.GBML.clone","text":"Description Similar to MAML.clone() . Arguments first_order (bool, optional , default=None) - Whether the clone uses first- or second-order updates. Defaults to self.first_order. allow_unused (bool, optional , default=None) - Whether to allow differentiation of unused parameters. Defaults to self.allow_unused. allow_nograd (bool, optional , default=False) - Whether to allow adaptation with parameters that have requires_grad = False . Defaults to self.allow_nograd.","title":"clone()"},{"location":"docs/learn2learn.algorithms/#pytorch-lightning","text":"","title":"PyTorch Lightning"},{"location":"docs/learn2learn.algorithms/#learn2learn.algorithms.lightning.lightning_maml.LightningMAML","text":"[Source] Description A PyTorch Lightning module for MAML. Arguments model (Module) - A PyTorch nn.Module. loss (Function, optional , default=CrossEntropyLoss) - Loss function which maps the cost of the events. ways (int, optional , default=5) - Number of classes in a task. shots (int, optional , default=1) - Number of samples for adaptation. adaptation_steps (int, optional , default=1) - Number of steps for adapting to new task. lr (float, optional , default=0.001) - Learning rate of meta training. adaptation_lr (float, optional , default=0.1) - Learning rate for fast adaptation. scheduler_step (int, optional , default=20) - Decay interval for lr . scheduler_decay (float, optional , default=1.0) - Decay rate for lr . References Finn et al. 2017. \"Model-Agnostic Meta-Learning for Fast Adaptation of Deep Networks.\" Example 1 2 3 4 5 6 tasksets = l2l . vision . benchmarks . get_tasksets ( 'omniglot' ) model = l2l . vision . models . OmniglotFC ( 28 ** 2 , args . ways ) maml = LightningMAML ( classifier , adaptation_lr = 0.1 , ** dict_args ) episodic_data = EpisodicBatcher ( tasksets . train , tasksets . validation , tasksets . test ) trainer = pl . Trainer . from_argparse_args ( args ) trainer . fit ( maml , episodic_data )","title":"LightningMAML"},{"location":"docs/learn2learn.algorithms/#learn2learn.algorithms.lightning.lightning_anil.LightningANIL","text":"[Source] Description A PyTorch Lightning module for ANIL. Arguments features (Module) - A nn.Module to extract features, which will not be adaptated. classifier (Module) - A nn.Module taking features, mapping them to classification. loss (Function, optional , default=CrossEntropyLoss) - Loss function which maps the cost of the events. ways (int, optional , default=5) - Number of classes in a task. shots (int, optional , default=1) - Number of samples for adaptation. adaptation_steps (int, optional , default=1) - Number of steps for adapting to new task. lr (float, optional , default=0.001) - Learning rate of meta training. adaptation_lr (float, optional , default=0.1) - Learning rate for fast adaptation. scheduler_step (int, optional , default=20) - Decay interval for lr . scheduler_decay (float, optional , default=1.0) - Decay rate for lr . References Raghu et al. 2020. \"Rapid Learning or Feature Reuse? Towards Understanding the Effectiveness of MAML\" Example 1 2 3 4 5 6 tasksets = l2l . vision . benchmarks . get_tasksets ( 'omniglot' ) model = l2l . vision . models . OmniglotFC ( 28 ** 2 , args . ways ) anil = LightningANIL ( model . features , model . classifier , adaptation_lr = 0.1 , ** dict_args ) episodic_data = EpisodicBatcher ( tasksets . train , tasksets . validation , tasksets . test ) trainer = pl . Trainer . from_argparse_args ( args ) trainer . fit ( anil , episodic_data )","title":"LightningANIL"},{"location":"docs/learn2learn.algorithms/#learn2learn.algorithms.lightning.lightning_protonet.LightningPrototypicalNetworks","text":"[Source] Description A PyTorch Lightning module for Prototypical Networks. Arguments features (Module) - Feature extractor which classifies input tasks. loss (Function, optional , default=CrossEntropyLoss) - Loss function which maps the cost of the events. distance_metric (str, optional , default='euclidean') - Distance metric between samples. ['euclidean', 'cosine'] train_ways (int, optional , default=5) - Number of classes in for train tasks. train_shots (int, optional , default=1) - Number of support samples for train tasks. train_queries (int, optional , default=1) - Number of query samples for train tasks. test_ways (int, optional , default=5) - Number of classes in for test tasks. test_shots (int, optional , default=1) - Number of support samples for test tasks. test_queries (int, optional , default=1) - Number of query samples for test tasks. lr (float, optional , default=0.001) - Learning rate of meta training. scheduler_step (int, optional , default=20) - Decay interval for lr . scheduler_decay (float, optional , default=1.0) - Decay rate for lr . References Snell et al. 2017. \"Prototypical Networks for Few-shot Learning\" Example 1 2 3 4 5 6 tasksets = l2l . vision . benchmarks . get_tasksets ( 'mini-imagenet' ) features = Convnet () # init model protonet = LightningPrototypicalNetworks ( features , ** dict_args ) episodic_data = EpisodicBatcher ( tasksets . train , tasksets . validation , tasksets . test ) trainer = pl . Trainer . from_argparse_args ( args ) trainer . fit ( protonet , episodic_data )","title":"LightningPrototypicalNetworks"},{"location":"docs/learn2learn.algorithms/#learn2learn.algorithms.lightning.lightning_metaoptnet.LightningMetaOptNet","text":"[Source] Description A PyTorch Lightning module for MetaOptNet. Arguments features (Module) - Feature extractor which classifies input tasks. svm_C_reg (float, optional , default=0.1) - Regularization weight for SVM. svm_max_iters (int, optional , default=15) - Maximum number of iterations for SVM convergence. loss (Function, optional , default=CrossEntropyLoss) - Loss function which maps the cost of the events. train_ways (int, optional , default=5) - Number of classes in for train tasks. train_shots (int, optional , default=1) - Number of support samples for train tasks. train_queries (int, optional , default=1) - Number of query samples for train tasks. test_ways (int, optional , default=5) - Number of classes in for test tasks. test_shots (int, optional , default=1) - Number of support samples for test tasks. test_queries (int, optional , default=1) - Number of query samples for test tasks. lr (float, optional , default=0.001) - Learning rate of meta training. scheduler_step (int, optional , default=20) - Decay interval for lr . scheduler_decay (float, optional , default=1.0) - Decay rate for lr . References Lee et al. 2019. \"Meta-Learning with Differentiable Convex Optimization\" Example 1 2 3 4 5 6 tasksets = l2l . vision . benchmarks . get_tasksets ( 'mini-imagenet' ) features = Convnet () # init model metaoptnet = LightningMetaOptNet ( features , ** dict_args ) episodic_data = EpisodicBatcher ( tasksets . train , tasksets . validation , tasksets . test ) trainer = pl . Trainer . from_argparse_args ( args ) trainer . fit ( metaoptnet , episodic_data )","title":"LightningMetaOptNet"},{"location":"docs/learn2learn.data/","text":"learn2learn.data \u00b6 Meta-Datasets \u00b6 MetaDataset ( Dataset ) \u00b6 Description Wraps a classification dataset to enable fast indexing of samples within classes. This class exposes two attributes specific to the wrapped dataset: labels_to_indices : maps a class label to a list of sample indices with that label. indices_to_labels : maps a sample index to its corresponding class label. Those dictionary attributes are often used to quickly create few-shot classification tasks. They can be passed as arguments upon instantiation, or automatically built on-the-fly. If the wrapped dataset has an attribute _bookkeeping_path , then the built attributes will be cached on disk and reloaded upon the next instantiation. This caching strategy is useful for large datasets (e.g. ImageNet-1k) where the first instantiation can take several hours. Note that if only one of labels_to_indices or indices_to_labels is provided, this class builds the other one from it. Arguments dataset (Dataset) - A torch Dataset. labels_to_indices (dict, optional , default=None) - A dictionary mapping labels to the indices of their samples. indices_to_labels (dict, optional , default=None) - A dictionary mapping sample indices to their corresponding label. Example 1 2 mnist = torchvision . datasets . MNIST ( root = \"/tmp/mnist\" , train = True ) mnist = l2l . data . MetaDataset ( mnist ) UnionMetaDataset ( MetaDataset ) \u00b6 Description Takes multiple MetaDataests and constructs their union. Note: The labels of all datasets are remapped to be in consecutive order. (i.e. the same label in two datasets will be to two different labels in the union) Arguments datasets (list of Dataset) - A list of torch Datasets. Example 1 2 3 4 5 6 7 8 train = torchvision . datasets . CIFARFS ( root = \"/tmp/mnist\" , mode = \"train\" ) train = l2l . data . MetaDataset ( train ) valid = torchvision . datasets . CIFARFS ( root = \"/tmp/mnist\" , mode = \"validation\" ) valid = l2l . data . MetaDataset ( valid ) test = torchvision . datasets . CIFARFS ( root = \"/tmp/mnist\" , mode = \"test\" ) test = l2l . data . MetaDataset ( test ) union = UnionMetaDataset ([ train , valid , test ]) assert len ( union . labels ) == 100 FilteredMetaDataset ( MetaDataset ) \u00b6 Description Takes in a MetaDataset and filters it to only include a subset of its labels. Note: The labels of all datasets are not remapped. (i.e. the labels from the original dataset are retained) Arguments datasets (Dataset) - A torch Datasets. labels (list of ints) - A list of labels to keep. Example 1 2 3 4 train = torchvision . datasets . CIFARFS ( root = \"/tmp/mnist\" , mode = \"train\" ) train = l2l . data . MetaDataset ( train ) filtered = FilteredMetaDataset ( train , [ 4 , 8 , 2 , 1 , 9 ]) assert len ( filtered . labels ) == 5 TaskDataset ( CythonTaskDataset ) \u00b6 [Source] Description Creates a set of tasks from a given Dataset. In addition to the Dataset, TaskDataset accepts a list of task transformations ( task_transforms ) which define the kind of tasks sampled from the dataset. The tasks are lazily sampled upon indexing (or calling the .sample() method), and their descriptions cached for later use. If num_tasks is -1, the TaskDataset will not cache task descriptions and instead continuously resample new ones. In this case, the length of the TaskDataset is set to 1. For more information on tasks and task descriptions, please refer to the documentation of task transforms. Arguments dataset (Dataset) - Dataset of data to compute tasks. task_transforms (list, optional , default=None) - List of task transformations. num_tasks (int, optional , default=-1) - Number of tasks to generate. Example 1 2 3 4 5 6 7 8 9 dataset = l2l . data . MetaDataset ( MyDataset ()) transforms = [ l2l . data . transforms . NWays ( dataset , n = 5 ), l2l . data . transforms . KShots ( dataset , k = 1 ), l2l . data . transforms . LoadData ( dataset ), ] taskset = TaskDataset ( dataset , transforms , num_tasks = 20000 ) for task in taskset : X , y = task learn2learn.data.transforms \u00b6 Transforms to help automatically generate tasks. LoadData ( TaskTransform ) \u00b6 [Source] Description Loads a sample from the dataset given its index. Arguments dataset (Dataset) - The dataset from which to load the sample. NWays ( CythonNWays ) \u00b6 [Source] Description Keeps samples from N random labels present in the task description. Arguments dataset (Dataset) - The dataset from which to load the sample. n (int, optional , default=2) - Number of labels to sample from the task description's labels. KShots ( CythonKShots ) \u00b6 [Source] Description Keeps K samples for each present labels. Arguments dataset (Dataset) - The dataset from which to load the sample. k (int, optional , default=1) - The number of samples per label. replacement (bool, optional , default=False) - Whether to sample with replacement. FilterLabels ( CythonFilterLabels ) \u00b6 [Source] Description Removes samples that do not belong to the given set of labels. Arguments dataset (Dataset) - The dataset from which to load the sample. labels (list) - The list of labels to include. FusedNWaysKShots ( CythonFusedNWaysKShots ) \u00b6 [Source] Description Efficient implementation of FilterLabels, NWays, and KShots. Arguments dataset (Dataset) - The dataset from which to load the sample. n (int, optional , default=2) - Number of labels to sample from the task description's labels. k (int, optional , default=1) - The number of samples per label. replacement (bool, optional , default=False) - Whether to sample shots with replacement. filter_labels (list, optional , default=None) - The list of labels to include. Defaults to all labels in the dataset. RemapLabels ( TaskTransform ) \u00b6 [Source] Description Given samples from K classes, maps the labels to 0, ..., K. Arguments dataset (Dataset) - The dataset from which to load the sample. ConsecutiveLabels ( TaskTransform ) \u00b6 [Source] Description Re-orders the samples in the task description such that they are sorted in consecutive order. Note: when used before RemapLabels , the labels will be homogeneously clustered, but in no specific order. Arguments dataset (Dataset) - The dataset from which to load the sample. learn2learn.data.utils \u00b6 Help functions to work with data and tasks. OnDeviceDataset ( TensorDataset ) \u00b6 [Source] Description Converts an entire dataset into a TensorDataset, and optionally puts it on the desired device. Useful to accelerate training with relatively small datasets. If the device is cpu and cuda is available, the TensorDataset will live in pinned memory. Arguments dataset (Dataset) - Dataset to put on a device. device (torch.device, optional , default=None) - Device of dataset. Defaults to CPU. transform (transform, optional , default=None) - Transform to apply on the first variate of the dataset's samples X. Example 1 2 3 4 5 6 7 8 transforms = transforms . Compose ([ transforms . ToTensor (), transforms . Normalize (( 0.1307 ,), ( 0.3081 ,)), lambda x : x . view ( 1 , 28 , 28 ), ]) mnist = MNIST ( '~/data' ) mnist_ondevice = OnDeviceDataset ( mnist , device = 'cuda' , transform = transforms ) mnist_meta = MetaDataset ( mnist_ondevice ) InfiniteIterator \u00b6 [Source] Description Infinitely loops over a given iterator. Arguments dataloader (iterator) - Iterator to loop over. Example 1 2 3 4 dataloader = DataLoader ( dataset , shuffle = True , batch_size = 32 ) inf_dataloader = InfiniteIterator ( dataloader ) for iteration in range ( 10000 ): # guaranteed to reach 10,000 regardless of len(dataloader) X , y = next ( inf_dataloader ) partition_task ( data , labels , shots = 1 ) \u00b6 [Source] Description Partitions a classification task into support and query sets. The support set will contain shots samples per class, the query will take the remaining samples. Assumes each class in labels is associated with the same number of samples in data . Arguments data (Tensor) - Data to be partitioned into support and query. labels (Tensor) - Labels of each data sample, used for partitioning. shots (int, optional , default=1) - Number of data samples per class in the support set. Example 1 2 X , y = taskset . sample () ( X_support , y_support ), ( X_query , y_query ) = partition_task ( X , y , shots = 5 )","title":"learn2learn.data"},{"location":"docs/learn2learn.data/#learn2learndata","text":"","title":"learn2learn.data"},{"location":"docs/learn2learn.data/#meta-datasets","text":"","title":"Meta-Datasets"},{"location":"docs/learn2learn.data/#learn2learn.data.meta_dataset.MetaDataset","text":"Description Wraps a classification dataset to enable fast indexing of samples within classes. This class exposes two attributes specific to the wrapped dataset: labels_to_indices : maps a class label to a list of sample indices with that label. indices_to_labels : maps a sample index to its corresponding class label. Those dictionary attributes are often used to quickly create few-shot classification tasks. They can be passed as arguments upon instantiation, or automatically built on-the-fly. If the wrapped dataset has an attribute _bookkeeping_path , then the built attributes will be cached on disk and reloaded upon the next instantiation. This caching strategy is useful for large datasets (e.g. ImageNet-1k) where the first instantiation can take several hours. Note that if only one of labels_to_indices or indices_to_labels is provided, this class builds the other one from it. Arguments dataset (Dataset) - A torch Dataset. labels_to_indices (dict, optional , default=None) - A dictionary mapping labels to the indices of their samples. indices_to_labels (dict, optional , default=None) - A dictionary mapping sample indices to their corresponding label. Example 1 2 mnist = torchvision . datasets . MNIST ( root = \"/tmp/mnist\" , train = True ) mnist = l2l . data . MetaDataset ( mnist )","title":"MetaDataset"},{"location":"docs/learn2learn.data/#learn2learn.data.meta_dataset.UnionMetaDataset","text":"Description Takes multiple MetaDataests and constructs their union. Note: The labels of all datasets are remapped to be in consecutive order. (i.e. the same label in two datasets will be to two different labels in the union) Arguments datasets (list of Dataset) - A list of torch Datasets. Example 1 2 3 4 5 6 7 8 train = torchvision . datasets . CIFARFS ( root = \"/tmp/mnist\" , mode = \"train\" ) train = l2l . data . MetaDataset ( train ) valid = torchvision . datasets . CIFARFS ( root = \"/tmp/mnist\" , mode = \"validation\" ) valid = l2l . data . MetaDataset ( valid ) test = torchvision . datasets . CIFARFS ( root = \"/tmp/mnist\" , mode = \"test\" ) test = l2l . data . MetaDataset ( test ) union = UnionMetaDataset ([ train , valid , test ]) assert len ( union . labels ) == 100","title":"UnionMetaDataset"},{"location":"docs/learn2learn.data/#learn2learn.data.meta_dataset.FilteredMetaDataset","text":"Description Takes in a MetaDataset and filters it to only include a subset of its labels. Note: The labels of all datasets are not remapped. (i.e. the labels from the original dataset are retained) Arguments datasets (Dataset) - A torch Datasets. labels (list of ints) - A list of labels to keep. Example 1 2 3 4 train = torchvision . datasets . CIFARFS ( root = \"/tmp/mnist\" , mode = \"train\" ) train = l2l . data . MetaDataset ( train ) filtered = FilteredMetaDataset ( train , [ 4 , 8 , 2 , 1 , 9 ]) assert len ( filtered . labels ) == 5","title":"FilteredMetaDataset"},{"location":"docs/learn2learn.data/#learn2learn.data.task_dataset.TaskDataset","text":"[Source] Description Creates a set of tasks from a given Dataset. In addition to the Dataset, TaskDataset accepts a list of task transformations ( task_transforms ) which define the kind of tasks sampled from the dataset. The tasks are lazily sampled upon indexing (or calling the .sample() method), and their descriptions cached for later use. If num_tasks is -1, the TaskDataset will not cache task descriptions and instead continuously resample new ones. In this case, the length of the TaskDataset is set to 1. For more information on tasks and task descriptions, please refer to the documentation of task transforms. Arguments dataset (Dataset) - Dataset of data to compute tasks. task_transforms (list, optional , default=None) - List of task transformations. num_tasks (int, optional , default=-1) - Number of tasks to generate. Example 1 2 3 4 5 6 7 8 9 dataset = l2l . data . MetaDataset ( MyDataset ()) transforms = [ l2l . data . transforms . NWays ( dataset , n = 5 ), l2l . data . transforms . KShots ( dataset , k = 1 ), l2l . data . transforms . LoadData ( dataset ), ] taskset = TaskDataset ( dataset , transforms , num_tasks = 20000 ) for task in taskset : X , y = task","title":"TaskDataset"},{"location":"docs/learn2learn.data/#learn2learndatatransforms","text":"Transforms to help automatically generate tasks.","title":"learn2learn.data.transforms"},{"location":"docs/learn2learn.data/#learn2learn.data.transforms.LoadData","text":"[Source] Description Loads a sample from the dataset given its index. Arguments dataset (Dataset) - The dataset from which to load the sample.","title":"LoadData"},{"location":"docs/learn2learn.data/#learn2learn.data.transforms.NWays","text":"[Source] Description Keeps samples from N random labels present in the task description. Arguments dataset (Dataset) - The dataset from which to load the sample. n (int, optional , default=2) - Number of labels to sample from the task description's labels.","title":"NWays"},{"location":"docs/learn2learn.data/#learn2learn.data.transforms.KShots","text":"[Source] Description Keeps K samples for each present labels. Arguments dataset (Dataset) - The dataset from which to load the sample. k (int, optional , default=1) - The number of samples per label. replacement (bool, optional , default=False) - Whether to sample with replacement.","title":"KShots"},{"location":"docs/learn2learn.data/#learn2learn.data.transforms.FilterLabels","text":"[Source] Description Removes samples that do not belong to the given set of labels. Arguments dataset (Dataset) - The dataset from which to load the sample. labels (list) - The list of labels to include.","title":"FilterLabels"},{"location":"docs/learn2learn.data/#learn2learn.data.transforms.FusedNWaysKShots","text":"[Source] Description Efficient implementation of FilterLabels, NWays, and KShots. Arguments dataset (Dataset) - The dataset from which to load the sample. n (int, optional , default=2) - Number of labels to sample from the task description's labels. k (int, optional , default=1) - The number of samples per label. replacement (bool, optional , default=False) - Whether to sample shots with replacement. filter_labels (list, optional , default=None) - The list of labels to include. Defaults to all labels in the dataset.","title":"FusedNWaysKShots"},{"location":"docs/learn2learn.data/#learn2learn.data.transforms.RemapLabels","text":"[Source] Description Given samples from K classes, maps the labels to 0, ..., K. Arguments dataset (Dataset) - The dataset from which to load the sample.","title":"RemapLabels"},{"location":"docs/learn2learn.data/#learn2learn.data.transforms.ConsecutiveLabels","text":"[Source] Description Re-orders the samples in the task description such that they are sorted in consecutive order. Note: when used before RemapLabels , the labels will be homogeneously clustered, but in no specific order. Arguments dataset (Dataset) - The dataset from which to load the sample.","title":"ConsecutiveLabels"},{"location":"docs/learn2learn.data/#learn2learndatautils","text":"Help functions to work with data and tasks.","title":"learn2learn.data.utils"},{"location":"docs/learn2learn.data/#learn2learn.data.utils.OnDeviceDataset","text":"[Source] Description Converts an entire dataset into a TensorDataset, and optionally puts it on the desired device. Useful to accelerate training with relatively small datasets. If the device is cpu and cuda is available, the TensorDataset will live in pinned memory. Arguments dataset (Dataset) - Dataset to put on a device. device (torch.device, optional , default=None) - Device of dataset. Defaults to CPU. transform (transform, optional , default=None) - Transform to apply on the first variate of the dataset's samples X. Example 1 2 3 4 5 6 7 8 transforms = transforms . Compose ([ transforms . ToTensor (), transforms . Normalize (( 0.1307 ,), ( 0.3081 ,)), lambda x : x . view ( 1 , 28 , 28 ), ]) mnist = MNIST ( '~/data' ) mnist_ondevice = OnDeviceDataset ( mnist , device = 'cuda' , transform = transforms ) mnist_meta = MetaDataset ( mnist_ondevice )","title":"OnDeviceDataset"},{"location":"docs/learn2learn.data/#learn2learn.data.utils.InfiniteIterator","text":"[Source] Description Infinitely loops over a given iterator. Arguments dataloader (iterator) - Iterator to loop over. Example 1 2 3 4 dataloader = DataLoader ( dataset , shuffle = True , batch_size = 32 ) inf_dataloader = InfiniteIterator ( dataloader ) for iteration in range ( 10000 ): # guaranteed to reach 10,000 regardless of len(dataloader) X , y = next ( inf_dataloader )","title":"InfiniteIterator"},{"location":"docs/learn2learn.data/#learn2learn.data.utils.partition_task","text":"[Source] Description Partitions a classification task into support and query sets. The support set will contain shots samples per class, the query will take the remaining samples. Assumes each class in labels is associated with the same number of samples in data . Arguments data (Tensor) - Data to be partitioned into support and query. labels (Tensor) - Labels of each data sample, used for partitioning. shots (int, optional , default=1) - Number of data samples per class in the support set. Example 1 2 X , y = taskset . sample () ( X_support , y_support ), ( X_query , y_query ) = partition_task ( X , y , shots = 5 )","title":"partition_task()"},{"location":"docs/learn2learn.gym/","text":"learn2learn.gym \u00b6 The learn2learn.gym interface is being re-worked and will soon be released with major improvements. If you need those tasks now, please refer to the code and examples .","title":"learn2learn.gym"},{"location":"docs/learn2learn.gym/#learn2learngym","text":"The learn2learn.gym interface is being re-worked and will soon be released with major improvements. If you need those tasks now, please refer to the code and examples .","title":"learn2learn.gym"},{"location":"docs/learn2learn/","text":"learn2learn \u00b6 clone_module ( module , memo = None ) \u00b6 [Source] Description Creates a copy of a module, whose parameters/buffers/submodules are created using PyTorch's torch.clone(). This implies that the computational graph is kept, and you can compute the derivatives of the new modules' parameters w.r.t the original parameters. Arguments module (Module) - Module to be cloned. Return (Module) - The cloned module. Example 1 2 3 4 net = nn . Sequential ( Linear ( 20 , 10 ), nn . ReLU (), nn . Linear ( 10 , 2 )) clone = clone_module ( net ) error = loss ( clone ( X ), y ) error . backward () # Gradients are back-propagate all the way to net. detach_module ( module , keep_requires_grad = False ) \u00b6 [Source] Description Detaches all parameters/buffers of a previously cloned module from its computational graph. Note: detach works in-place, so it does not return a copy. Arguments module (Module) - Module to be detached. keep_requires_grad (bool) - By default, all parameters of the detached module will have requires_grad set to False . If this flag is set to True , then the requires_grad field will be the same as the pre-detached module. Example 1 2 3 4 5 net = nn . Sequential ( nn . Linear ( 20 , 10 ), nn . ReLU (), nn . Linear ( 10 , 2 )) clone = clone_module ( net ) detach_module ( clone , keep_requires_grad = True ) error = loss ( clone ( X ), y ) error . backward () # Gradients are back-propagate on clone, not net. update_module ( module , updates = None , memo = None ) \u00b6 [Source] Description Updates the parameters of a module in-place, in a way that preserves differentiability. The parameters of the module are swapped with their update values, according to: p \\gets p + u, where p is the parameter, and u is its corresponding update. Arguments module (Module) - The module to update. updates (list, optional , default=None) - A list of gradients for each parameter of the model. If None, will use the tensors in .update attributes. Example 1 2 3 4 5 6 7 8 error = loss ( model ( X ), y ) grads = torch . autograd . grad ( error , model . parameters (), create_graph = True , ) updates = [ - lr * g for g in grads ] l2l . update_module ( model , updates = updates ) magic_box ( x ) \u00b6 [Source] Description The magic box operator, which evaluates to 1 but whose gradient is dx : \\boxdot (x) = \\exp(x - \\bot(x)) where \\bot is the stop-gradient (or detach) operator. This operator is useful when computing higher-order derivatives of stochastic graphs. For more informations, please refer to the DiCE paper. (Reference 1) References Foerster et al. 2018. \"DiCE: The Infinitely Differentiable Monte-Carlo Estimator.\" arXiv. Arguments x (Variable) - Variable to transform. Return (Variable) - Tensor of 1, but it's gradient is the gradient of x. Example 1 2 loss = ( magic_box ( cum_log_probs ) * advantages ) . mean () # loss is the mean advantage loss . backward () clone_distribution ( dist ) \u00b6 detach_distribution ( dist ) \u00b6","title":"learn2learn"},{"location":"docs/learn2learn/#learn2learn","text":"","title":"learn2learn"},{"location":"docs/learn2learn/#learn2learn.utils.clone_module","text":"[Source] Description Creates a copy of a module, whose parameters/buffers/submodules are created using PyTorch's torch.clone(). This implies that the computational graph is kept, and you can compute the derivatives of the new modules' parameters w.r.t the original parameters. Arguments module (Module) - Module to be cloned. Return (Module) - The cloned module. Example 1 2 3 4 net = nn . Sequential ( Linear ( 20 , 10 ), nn . ReLU (), nn . Linear ( 10 , 2 )) clone = clone_module ( net ) error = loss ( clone ( X ), y ) error . backward () # Gradients are back-propagate all the way to net.","title":"clone_module()"},{"location":"docs/learn2learn/#learn2learn.utils.detach_module","text":"[Source] Description Detaches all parameters/buffers of a previously cloned module from its computational graph. Note: detach works in-place, so it does not return a copy. Arguments module (Module) - Module to be detached. keep_requires_grad (bool) - By default, all parameters of the detached module will have requires_grad set to False . If this flag is set to True , then the requires_grad field will be the same as the pre-detached module. Example 1 2 3 4 5 net = nn . Sequential ( nn . Linear ( 20 , 10 ), nn . ReLU (), nn . Linear ( 10 , 2 )) clone = clone_module ( net ) detach_module ( clone , keep_requires_grad = True ) error = loss ( clone ( X ), y ) error . backward () # Gradients are back-propagate on clone, not net.","title":"detach_module()"},{"location":"docs/learn2learn/#learn2learn.utils.update_module","text":"[Source] Description Updates the parameters of a module in-place, in a way that preserves differentiability. The parameters of the module are swapped with their update values, according to: p \\gets p + u, where p is the parameter, and u is its corresponding update. Arguments module (Module) - The module to update. updates (list, optional , default=None) - A list of gradients for each parameter of the model. If None, will use the tensors in .update attributes. Example 1 2 3 4 5 6 7 8 error = loss ( model ( X ), y ) grads = torch . autograd . grad ( error , model . parameters (), create_graph = True , ) updates = [ - lr * g for g in grads ] l2l . update_module ( model , updates = updates )","title":"update_module()"},{"location":"docs/learn2learn/#learn2learn.utils.magic_box","text":"[Source] Description The magic box operator, which evaluates to 1 but whose gradient is dx : \\boxdot (x) = \\exp(x - \\bot(x)) where \\bot is the stop-gradient (or detach) operator. This operator is useful when computing higher-order derivatives of stochastic graphs. For more informations, please refer to the DiCE paper. (Reference 1) References Foerster et al. 2018. \"DiCE: The Infinitely Differentiable Monte-Carlo Estimator.\" arXiv. Arguments x (Variable) - Variable to transform. Return (Variable) - Tensor of 1, but it's gradient is the gradient of x. Example 1 2 loss = ( magic_box ( cum_log_probs ) * advantages ) . mean () # loss is the mean advantage loss . backward ()","title":"magic_box()"},{"location":"docs/learn2learn/#learn2learn.utils.clone_distribution","text":"","title":"clone_distribution()"},{"location":"docs/learn2learn/#learn2learn.utils.detach_distribution","text":"","title":"detach_distribution()"},{"location":"docs/learn2learn.nn/","text":"learn2learn.nn \u00b6 Classifiers \u00b6 PrototypicalClassifier ( Module ) \u00b6 [Source] Description A module for the differentiable nearest neighbour classifier of Prototypical Networks. Arguments support (Tensor, optional , default=None) - Tensor of support features. labels (Tensor, optional , default=None) - Labels corresponding to the support features. distance (str, optional , default='euclidean') - Distance metric between samples. ['euclidean', 'cosine'] normalize (bool, optional , default=False) - Whether to normalize the inputs. Defaults to True when distance='cosine'. References Snell et al. 2017. \"Prototypical Networks for Few-shot Learning\" Example 1 2 3 4 5 classifier = PrototypicalClassifier () support = features ( support_data ) classifier . fit_ ( support , labels ) query = features ( query_data ) preds = classifier ( query ) fit_ ( self , support , labels ) \u00b6 Description Computes and updates the prototypes given support embeddings and corresponding labels. SVClassifier ( Module ) \u00b6 [Source] Description A module for the differentiable SVM classifier of MetaOptNet. Arguments support (Tensor, optional , default=None) - Tensor of support features. labels (Tensor, optional , default=None) - Labels corresponding to the support features. ways (str, optional , default=None) - Number of classes in the task. normalize (bool, optional , default=False) - Whether to normalize the inputs. C_reg (float, optional , default=0.1) - Regularization weight for SVM. max_iters (int, optional , default=15) - Maximum number of iterations for SVM convergence. References Lee et al. 2019. \"Prototypical Networks for Few-shot Learning\" Example 1 2 3 4 5 classifier = SVMClassifier () support = features ( support_data ) classifier . fit_ ( support , labels ) query = features ( query_data ) preds = classifier ( query ) fit_ ( self , support , labels , ways = None , C_reg = None , max_iters = None ) \u00b6 MetaLayers \u00b6 MetaModule ( Module ) \u00b6 [Source] Description \u00b6 Takes a module and recursively replaces its submodules with others. The substitution is passed based on a dictionary ( substitutions ) which maps module classes to substitution functions. For example, to append a second Linear module after all Linear submodules: 1 2 3 4 substitutions [ torch . nn . Linear ] = lambda linear : torch . nn . Sequential ( linear , torch . nn . Linear ( linear . out_features , linear . out_features ), ) Optionally, the original module parameters can be frozen ( requires_grad = False ) by setting freeze_module = True . This is helpful when only the substitution modules need to be updated. Arguments module (Module) - The model to wrap. substitutions (dict) - Map of class -> construction substitutions. freeze_module (bool, optional , default=True) - Whether to freeze the original module parameters. Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import learn2learn.nn.metalayers as ml single_layer = torch . nn . Sequential ( torch . nn . Linear ( 768 , 10 ), torch . nn . ReLU (), ) double_layers = ml . MetaModule ( module = single_layer , substitutions = { torch . nn . Linear : lambda linear : torch . nn . Sequential ( linear , torch . nn . Linear ( linear . out_features , linear . out_features ), ) }, freeze_module = True , ) print ( double_layers ) Output: 1 2 3 4 5 6 7 8 9 MetaModule ( ( wrapped_module ): Sequential ( ( 0 ): Sequential ( ( 0 ): Linear ( in_features = 768 , out_features = 10 , bias = True ) ( 1 ): Linear ( in_features = 10 , out_features = 10 , bias = True ) ) ( 1 ): ReLU () ) ) module ( self ) \u00b6 Description Returns the original module . Example (continued from above) 1 single_layer = double_layers . module () ParameterTransform ( Module ) \u00b6 [Source] Description Calls module after have transformed its parameters via transform . After the forward pass, the parameters of module are reverted to their original values. Useful to implement learnable (and constrained) updates of module weights (e.g., LoRA). Best used in conjunction with MetaModule . Arguments module (Module) - The model to wrap. transform (callable) - Function to be called on all parameters of module before its forward pass. Possibly a module itself, which is learnable. Example Where we only learn to a scalar factor of the original weights. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import learn2learn.nn.metalayers as ml model = torch . nn . Sequential ( torch . nn . Linear ( 768 , 512 ), torch . nn . ReLU (), torch . nn . Linear ( 512 , 10 ), ) meta_model = ml . MetaModule ( module = model , substitutions = { torch . nn . Linear : lambda linear : ml . ParameterTransform ( module = linear , transform = lambda param : l2l . nn . Scale (), ), }, freeze_module = True , ) Kroneckers \u00b6 KroneckerLinear ( Module ) \u00b6 [Source] Description A linear transformation whose parameters are expressed as a Kronecker product. This Module maps an input vector x \\in \\mathbb{R}^{nm} to y = Ax + b such that: A = R^\\top \\otimes L, where L \\in \\mathbb{R}^{n \\times n} and R \\in \\mathbb{R}^{m \\times m} are the learnable Kronecker factors. This implementation can reduce the memory requirement for large linear mapping from \\mathcal{O}(n^2 \\cdot m^2) to \\mathcal{O}(n^2 + m^2) , but forces y \\in \\mathbb{R}^{nm} . The matrix A is initialized as the identity, and the bias as a zero vector. Arguments n (int) - Dimensionality of the left Kronecker factor. m (int) - Dimensionality of the right Kronecker factor. bias (bool, optional , default=True) - Whether to include the bias term. psd (bool, optional , default=False) - Forces the matrix A to be positive semi-definite if True. device (device, optional , default=None) - The device on which to instantiate the Module. References Jose et al. 2018. \"Kronecker recurrent units\". Arnold et al. 2019. \"When MAML can adapt fast and how to assist when it cannot\". Example 1 2 3 4 5 m , n = 2 , 3 x = torch . randn ( 6 ) kronecker = KroneckerLinear ( n , m ) y = kronecker ( x ) y . shape # (6, ) KroneckerRNN ( Module ) \u00b6 [Source] Description Implements a recurrent neural network whose matrices are parameterized via their Kronecker factors. (See KroneckerLinear for details.) Arguments n (int) - Dimensionality of the left Kronecker factor. m (int) - Dimensionality of the right Kronecker factor. bias (bool, optional , default=True) - Whether to include the bias term. sigma (callable, optional , default=None) - The activation function. References Jose et al. 2018. \"Kronecker recurrent units\". Example 1 2 3 4 5 6 m , n = 2 , 3 x = torch . randn ( 6 ) h = torch . randn ( 6 ) kronecker = KroneckerRNN ( n , m ) y , new_h = kronecker ( x , h ) y . shape # (6, ) KroneckerLSTM ( Module ) \u00b6 [Source] Description Implements an LSTM using a factorization similar to the one of KroneckerLinear . Arguments n (int) - Dimensionality of the left Kronecker factor. m (int) - Dimensionality of the right Kronecker factor. bias (bool, optional , default=True) - Whether to include the bias term. sigma (callable, optional , default=None) - The activation function. References Jose et al. 2018. \"Kronecker recurrent units\". Example 1 2 3 4 5 6 m , n = 2 , 3 x = torch . randn ( 6 ) h = torch . randn ( 6 ) kronecker = KroneckerLSTM ( n , m ) y , new_h = kronecker ( x , h ) y . shape # (6, ) Misc \u00b6 Lambda ( Module ) \u00b6 [Source] Description Utility class to create a wrapper based on a lambda function. Arguments lmb (callable) - The function to call in the forward pass. Example 1 2 3 4 mean23 = Lambda ( lambda x : x . mean ( dim = [ 2 , 3 ])) # mean23 is a Module x = features ( img ) x = mean23 ( x ) x = x . flatten () Scale ( Module ) \u00b6 [Source] Description A per-parameter scaling factor with learnable parameter. Arguments shape (int or tuple, optional , default=1) - The shape of the scaling matrix. alpha (float, optional , default=1.0) - Initial value for the scaling factor. Example 1 2 3 x = torch . ones ( 3 ) scale = Scale ( x . shape , alpha = 0.5 ) print ( scale ( x )) # [.5, .5, .5] Flatten ( Module ) \u00b6 [Source] Description Utility Module to flatten inputs to (batch_size, -1) shape. Example 1 2 3 4 flatten = Flatten () x = torch . randn ( 5 , 3 , 32 , 32 ) x = flatten ( x ) print ( x . shape ) # (5, 3072) freeze ( module ) \u00b6 [Source] Description Prevents all parameters in module to get gradients. Note: the module is modified in-place. Arguments module (Module) - The module to freeze. Example 1 2 linear = torch . nn . Linear ( 128 , 4 ) l2l . nn . freeze ( linear ) unfreeze ( module ) \u00b6 [Source] Description Enables all parameters in module to compute gradients. Note: the module is modified in-place. Arguments module (Module) - The module to unfreeze. Example 1 2 3 linear = torch . nn . Linear ( 128 , 4 ) l2l . nn . freeze ( linear ) l2l . nn . unfreeze ( linear )","title":"learn2learn.nn"},{"location":"docs/learn2learn.nn/#learn2learnnn","text":"","title":"learn2learn.nn"},{"location":"docs/learn2learn.nn/#classifiers","text":"","title":"Classifiers"},{"location":"docs/learn2learn.nn/#learn2learn.nn.protonet.PrototypicalClassifier","text":"[Source] Description A module for the differentiable nearest neighbour classifier of Prototypical Networks. Arguments support (Tensor, optional , default=None) - Tensor of support features. labels (Tensor, optional , default=None) - Labels corresponding to the support features. distance (str, optional , default='euclidean') - Distance metric between samples. ['euclidean', 'cosine'] normalize (bool, optional , default=False) - Whether to normalize the inputs. Defaults to True when distance='cosine'. References Snell et al. 2017. \"Prototypical Networks for Few-shot Learning\" Example 1 2 3 4 5 classifier = PrototypicalClassifier () support = features ( support_data ) classifier . fit_ ( support , labels ) query = features ( query_data ) preds = classifier ( query )","title":"PrototypicalClassifier"},{"location":"docs/learn2learn.nn/#learn2learn.nn.protonet.PrototypicalClassifier.fit_","text":"Description Computes and updates the prototypes given support embeddings and corresponding labels.","title":"fit_()"},{"location":"docs/learn2learn.nn/#learn2learn.nn.metaoptnet.SVClassifier","text":"[Source] Description A module for the differentiable SVM classifier of MetaOptNet. Arguments support (Tensor, optional , default=None) - Tensor of support features. labels (Tensor, optional , default=None) - Labels corresponding to the support features. ways (str, optional , default=None) - Number of classes in the task. normalize (bool, optional , default=False) - Whether to normalize the inputs. C_reg (float, optional , default=0.1) - Regularization weight for SVM. max_iters (int, optional , default=15) - Maximum number of iterations for SVM convergence. References Lee et al. 2019. \"Prototypical Networks for Few-shot Learning\" Example 1 2 3 4 5 classifier = SVMClassifier () support = features ( support_data ) classifier . fit_ ( support , labels ) query = features ( query_data ) preds = classifier ( query )","title":"SVClassifier"},{"location":"docs/learn2learn.nn/#learn2learn.nn.metaoptnet.SVClassifier.fit_","text":"","title":"fit_()"},{"location":"docs/learn2learn.nn/#metalayers","text":"","title":"MetaLayers"},{"location":"docs/learn2learn.nn/#learn2learn.nn.metalayers.metamodule.MetaModule","text":"[Source]","title":"MetaModule"},{"location":"docs/learn2learn.nn/#learn2learn.nn.metalayers.metamodule.MetaModule--description","text":"Takes a module and recursively replaces its submodules with others. The substitution is passed based on a dictionary ( substitutions ) which maps module classes to substitution functions. For example, to append a second Linear module after all Linear submodules: 1 2 3 4 substitutions [ torch . nn . Linear ] = lambda linear : torch . nn . Sequential ( linear , torch . nn . Linear ( linear . out_features , linear . out_features ), ) Optionally, the original module parameters can be frozen ( requires_grad = False ) by setting freeze_module = True . This is helpful when only the substitution modules need to be updated. Arguments module (Module) - The model to wrap. substitutions (dict) - Map of class -> construction substitutions. freeze_module (bool, optional , default=True) - Whether to freeze the original module parameters. Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import learn2learn.nn.metalayers as ml single_layer = torch . nn . Sequential ( torch . nn . Linear ( 768 , 10 ), torch . nn . ReLU (), ) double_layers = ml . MetaModule ( module = single_layer , substitutions = { torch . nn . Linear : lambda linear : torch . nn . Sequential ( linear , torch . nn . Linear ( linear . out_features , linear . out_features ), ) }, freeze_module = True , ) print ( double_layers ) Output: 1 2 3 4 5 6 7 8 9 MetaModule ( ( wrapped_module ): Sequential ( ( 0 ): Sequential ( ( 0 ): Linear ( in_features = 768 , out_features = 10 , bias = True ) ( 1 ): Linear ( in_features = 10 , out_features = 10 , bias = True ) ) ( 1 ): ReLU () ) )","title":"Description"},{"location":"docs/learn2learn.nn/#learn2learn.nn.metalayers.metamodule.MetaModule.module","text":"Description Returns the original module . Example (continued from above) 1 single_layer = double_layers . module ()","title":"module()"},{"location":"docs/learn2learn.nn/#learn2learn.nn.metalayers.parameter_transform.ParameterTransform","text":"[Source] Description Calls module after have transformed its parameters via transform . After the forward pass, the parameters of module are reverted to their original values. Useful to implement learnable (and constrained) updates of module weights (e.g., LoRA). Best used in conjunction with MetaModule . Arguments module (Module) - The model to wrap. transform (callable) - Function to be called on all parameters of module before its forward pass. Possibly a module itself, which is learnable. Example Where we only learn to a scalar factor of the original weights. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import learn2learn.nn.metalayers as ml model = torch . nn . Sequential ( torch . nn . Linear ( 768 , 512 ), torch . nn . ReLU (), torch . nn . Linear ( 512 , 10 ), ) meta_model = ml . MetaModule ( module = model , substitutions = { torch . nn . Linear : lambda linear : ml . ParameterTransform ( module = linear , transform = lambda param : l2l . nn . Scale (), ), }, freeze_module = True , )","title":"ParameterTransform"},{"location":"docs/learn2learn.nn/#kroneckers","text":"","title":"Kroneckers"},{"location":"docs/learn2learn.nn/#learn2learn.nn.kroneckers.KroneckerLinear","text":"[Source] Description A linear transformation whose parameters are expressed as a Kronecker product. This Module maps an input vector x \\in \\mathbb{R}^{nm} to y = Ax + b such that: A = R^\\top \\otimes L, where L \\in \\mathbb{R}^{n \\times n} and R \\in \\mathbb{R}^{m \\times m} are the learnable Kronecker factors. This implementation can reduce the memory requirement for large linear mapping from \\mathcal{O}(n^2 \\cdot m^2) to \\mathcal{O}(n^2 + m^2) , but forces y \\in \\mathbb{R}^{nm} . The matrix A is initialized as the identity, and the bias as a zero vector. Arguments n (int) - Dimensionality of the left Kronecker factor. m (int) - Dimensionality of the right Kronecker factor. bias (bool, optional , default=True) - Whether to include the bias term. psd (bool, optional , default=False) - Forces the matrix A to be positive semi-definite if True. device (device, optional , default=None) - The device on which to instantiate the Module. References Jose et al. 2018. \"Kronecker recurrent units\". Arnold et al. 2019. \"When MAML can adapt fast and how to assist when it cannot\". Example 1 2 3 4 5 m , n = 2 , 3 x = torch . randn ( 6 ) kronecker = KroneckerLinear ( n , m ) y = kronecker ( x ) y . shape # (6, )","title":"KroneckerLinear"},{"location":"docs/learn2learn.nn/#learn2learn.nn.kroneckers.KroneckerRNN","text":"[Source] Description Implements a recurrent neural network whose matrices are parameterized via their Kronecker factors. (See KroneckerLinear for details.) Arguments n (int) - Dimensionality of the left Kronecker factor. m (int) - Dimensionality of the right Kronecker factor. bias (bool, optional , default=True) - Whether to include the bias term. sigma (callable, optional , default=None) - The activation function. References Jose et al. 2018. \"Kronecker recurrent units\". Example 1 2 3 4 5 6 m , n = 2 , 3 x = torch . randn ( 6 ) h = torch . randn ( 6 ) kronecker = KroneckerRNN ( n , m ) y , new_h = kronecker ( x , h ) y . shape # (6, )","title":"KroneckerRNN"},{"location":"docs/learn2learn.nn/#learn2learn.nn.kroneckers.KroneckerLSTM","text":"[Source] Description Implements an LSTM using a factorization similar to the one of KroneckerLinear . Arguments n (int) - Dimensionality of the left Kronecker factor. m (int) - Dimensionality of the right Kronecker factor. bias (bool, optional , default=True) - Whether to include the bias term. sigma (callable, optional , default=None) - The activation function. References Jose et al. 2018. \"Kronecker recurrent units\". Example 1 2 3 4 5 6 m , n = 2 , 3 x = torch . randn ( 6 ) h = torch . randn ( 6 ) kronecker = KroneckerLSTM ( n , m ) y , new_h = kronecker ( x , h ) y . shape # (6, )","title":"KroneckerLSTM"},{"location":"docs/learn2learn.nn/#misc","text":"","title":"Misc"},{"location":"docs/learn2learn.nn/#learn2learn.nn.misc.Lambda","text":"[Source] Description Utility class to create a wrapper based on a lambda function. Arguments lmb (callable) - The function to call in the forward pass. Example 1 2 3 4 mean23 = Lambda ( lambda x : x . mean ( dim = [ 2 , 3 ])) # mean23 is a Module x = features ( img ) x = mean23 ( x ) x = x . flatten ()","title":"Lambda"},{"location":"docs/learn2learn.nn/#learn2learn.nn.misc.Scale","text":"[Source] Description A per-parameter scaling factor with learnable parameter. Arguments shape (int or tuple, optional , default=1) - The shape of the scaling matrix. alpha (float, optional , default=1.0) - Initial value for the scaling factor. Example 1 2 3 x = torch . ones ( 3 ) scale = Scale ( x . shape , alpha = 0.5 ) print ( scale ( x )) # [.5, .5, .5]","title":"Scale"},{"location":"docs/learn2learn.nn/#learn2learn.nn.misc.Flatten","text":"[Source] Description Utility Module to flatten inputs to (batch_size, -1) shape. Example 1 2 3 4 flatten = Flatten () x = torch . randn ( 5 , 3 , 32 , 32 ) x = flatten ( x ) print ( x . shape ) # (5, 3072)","title":"Flatten"},{"location":"docs/learn2learn.nn/#learn2learn.nn.misc.freeze","text":"[Source] Description Prevents all parameters in module to get gradients. Note: the module is modified in-place. Arguments module (Module) - The module to freeze. Example 1 2 linear = torch . nn . Linear ( 128 , 4 ) l2l . nn . freeze ( linear )","title":"freeze()"},{"location":"docs/learn2learn.nn/#learn2learn.nn.misc.unfreeze","text":"[Source] Description Enables all parameters in module to compute gradients. Note: the module is modified in-place. Arguments module (Module) - The module to unfreeze. Example 1 2 3 linear = torch . nn . Linear ( 128 , 4 ) l2l . nn . freeze ( linear ) l2l . nn . unfreeze ( linear )","title":"unfreeze()"},{"location":"docs/learn2learn.optim/","text":"learn2learn.optim \u00b6 LearnableOptimizer ( Module ) \u00b6 [Source] Description A PyTorch Optimizer with learnable transform, enabling the implementation of meta-descent / hyper-gradient algorithms. This optimizer takes a Module and a gradient transform. At each step, the gradient of the module is passed through the transforms, and the module differentiably update -- i.e. when the next backward is called, gradients of both the module and the transform are computed. In turn, the transform can be updated via your favorite optmizer. Arguments model (Module) - Module to be updated. transform (Module) - Transform used to compute updates of the model. lr (float) - Learning rate. References Sutton. 1992. \u201cGain Adaptation Beats Least Squares.\u201d Schraudolph. 1999. \u201cLocal Gain Adaptation in Stochastic Gradient Descent.\u201d Baydin et al. 2017. \u201cOnline Learning Rate Adaptation with Hypergradient Descent.\u201d Majumder et al. 2019. \u201cLearning the Learning Rate for Gradient Descent by Gradient Descent.\u201d Jacobsen et al. 2019. \u201cMeta-Descent for Online, Continual Prediction.\u201d Example 1 2 3 4 5 6 7 8 9 10 11 linear = nn . Linear ( 784 , 10 ) transform = l2l . optim . ModuleTransform ( torch . nn . Linear ) metaopt = l2l . optim . LearnableOptimizer ( linear , transform , lr = 0.01 ) opt = torch . optim . SGD ( metaopt . parameters (), lr = 0.001 ) metaopt . zero_grad () opt . zero_grad () error = loss ( linear ( X ), y ) error . backward () opt . step () # update metaopt metaopt . step () # update linear zero_grad ( self ) \u00b6 Only reset target parameters. ParameterUpdate ( Module ) \u00b6 [Source] Description Convenience class to implement custom update functions. Objects instantiated from this class behave similarly to torch.autograd.grad , but return parameter updates as opposed to gradients. Concretely, the gradients are first computed, then fed to their respective transform whose output is finally returned to the user. Additionally, this class supports parameters that might not require updates by setting the allow_nograd flag to True. In this case, the returned update is None . Arguments parameters (list) - Parameters of the model to update. transform (callable) - A callable that returns an instantiated transform given a parameter. Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 model = torch . nn . Linear () transform = l2l . optim . KroneckerTransform ( l2l . nn . KroneckerLinear ) get_update = ParameterUpdate ( model , transform ) opt = torch . optim . SGD ( model . parameters () + get_update . parameters ()) for iteration in range ( 10 ): opt . zero_grad () error = loss ( model ( X ), y ) updates = get_update ( error , model . parameters (), create_graph = True , ) l2l . update_module ( model , updates ) opt . step () forward ( self , loss , parameters , create_graph = False , retain_graph = False , allow_unused = False , allow_nograd = False ) \u00b6 Description Similar to torch.autograd.grad, but passes the gradients through the provided transform. Arguments loss (Tensor) - The loss to differentiate. parameters (iterable) - Parameters w.r.t. which we want to compute the update. create_graph (bool, optional , default=False) - Same as torch.autograd.grad . retain_graph (bool, optional , default=False) - Same as torch.autograd.grad . allow_unused (bool, optional , default=False) - Same as torch.autograd.grad . allow_nograd (bool, optional , default=False) - Properly handles parameters that do not require gradients. (Their update will be None .) DifferentiableSGD ( Module ) \u00b6 [Source] Description A callable object that applies a list of updates to the parameters of a torch.nn.Module in a differentiable manner. For each parameter p and corresponding gradient g , calling an instance of this class results in updating parameters: p \\gets p - \\alpha g, where \\alpha is the learning rate. Note: The module is updated in-place. Arguments lr (float) - The learning rate used to update the model. Example 1 2 3 4 5 6 sgd = DifferentiableSGD ( 0.1 ) gradients = torch . autograd . grad ( loss , model . parameters (), create_gaph = True ) sgd ( model , gradients ) # model is updated in-place forward ( self , module , gradients = None ) \u00b6 Arguments module (Module) - The module to update. gradients (list, optional , default=None) - A list of gradients for each parameter of the module. If None, will use the gradients in .grad attributes. learn2learn.optim.transforms \u00b6 ModuleTransform \u00b6 [Source] Description The ModuleTransform creates a an optimization transform based on any nn.Module. ModuleTransform automatically instanciates a module from its class, based on a given parameter. The input and output shapes are of the module are set to (1, param.numel()) . When optimizing large layers, this type of transform can quickly run out of memory. See KroneckerTransform for a scalable alternative. Arguments module_cls (callable) - A callable that instantiates the module used to transform gradients. Example 1 2 3 4 5 6 classifier = torch . nn . Linear ( 784 , 10 , bias = False ) linear_transform = ModuleTransform ( torch . nn . Linear ) linear_update = linear_transform ( classifier . weight ) # maps gradients to updates, both of shape (1, 7840) loss ( classifier ( X ), y ) . backward () update = linear_update ( classifier . weight . grad ) classifier . weight . data . add_ ( - lr , update ) # Not a differentiable update. See l2l.optim.DifferentiableSGD. KroneckerTransform \u00b6 [Source] Description The KroneckerTransform creates a an optimization transform based on nn.Module's that admit a Kronecker factorization. (see l2l.nn.Kronecker* ) Akin to the ModuleTransform, this class of transform instanciates a module from its class, based on a given parameter. But, instead of reshaping the gradients to shape (1, param.numel()) , this class assumes a Kronecker factorization of the weights for memory and computational efficiency. The specific dimension of the Kronecker factorization depends on the the parameter's shape. For a weight of shape (n, m), a KroneckerLinear transform consists of two weights with shapes (n, n) and (m, m) rather than a single weight of shape (nm, nm). Refer to Arnold et al., 2019 for more details. Arguments kronecker_cls (callable) - A callable that instantiates the Kronecker module used to transform gradients. References Arnold et al. 2019. \"When MAML can adapt fast and how to assist when it cannot\". Example 1 2 3 4 5 6 classifier = torch . nn . Linear ( 784 , 10 , bias = False ) kronecker_transform = KroneckerTransform ( l2l . nn . KroneckerLinear ) kronecker_update = kronecker_transform ( classifier . weight ) loss ( classifier ( X ), y ) . backward () update = kronecker_update ( classifier . weight . grad ) classifier . weight . data . add_ ( - lr , update ) # Not a differentiable update. See l2l.optim.DifferentiableSGD. MetaCurvatureTransform ( Module ) \u00b6 [Source] Description Implements the Meta-Curvature transform of Park and Oliva, 2019. Unlike ModuleTranform and KroneckerTransform , this class does not wrap other Modules but is directly called on a weight to instantiate the transform. Arguments param (Tensor) - The weight whose gradients will be transformed. lr (float, optional , default=1.0) - Scaling factor of the udpate. (non-learnable) References Park & Oliva. 2019. Meta-curvature. Example 1 2 3 4 5 classifier = torch . nn . Linear ( 784 , 10 , bias = False ) metacurvature_update = MetaCurvatureTransform ( classifier . weight ) loss ( classifier ( X ), y ) . backward () update = metacurvature_update ( classifier . weight . grad ) classifier . weight . data . add_ ( - lr , update ) # Not a differentiable update. See l2l.optim.DifferentiableSGD.","title":"learn2learn.optim"},{"location":"docs/learn2learn.optim/#learn2learnoptim","text":"","title":"learn2learn.optim"},{"location":"docs/learn2learn.optim/#learn2learn.optim.learnable_optimizer.LearnableOptimizer","text":"[Source] Description A PyTorch Optimizer with learnable transform, enabling the implementation of meta-descent / hyper-gradient algorithms. This optimizer takes a Module and a gradient transform. At each step, the gradient of the module is passed through the transforms, and the module differentiably update -- i.e. when the next backward is called, gradients of both the module and the transform are computed. In turn, the transform can be updated via your favorite optmizer. Arguments model (Module) - Module to be updated. transform (Module) - Transform used to compute updates of the model. lr (float) - Learning rate. References Sutton. 1992. \u201cGain Adaptation Beats Least Squares.\u201d Schraudolph. 1999. \u201cLocal Gain Adaptation in Stochastic Gradient Descent.\u201d Baydin et al. 2017. \u201cOnline Learning Rate Adaptation with Hypergradient Descent.\u201d Majumder et al. 2019. \u201cLearning the Learning Rate for Gradient Descent by Gradient Descent.\u201d Jacobsen et al. 2019. \u201cMeta-Descent for Online, Continual Prediction.\u201d Example 1 2 3 4 5 6 7 8 9 10 11 linear = nn . Linear ( 784 , 10 ) transform = l2l . optim . ModuleTransform ( torch . nn . Linear ) metaopt = l2l . optim . LearnableOptimizer ( linear , transform , lr = 0.01 ) opt = torch . optim . SGD ( metaopt . parameters (), lr = 0.001 ) metaopt . zero_grad () opt . zero_grad () error = loss ( linear ( X ), y ) error . backward () opt . step () # update metaopt metaopt . step () # update linear","title":"LearnableOptimizer"},{"location":"docs/learn2learn.optim/#learn2learn.optim.learnable_optimizer.LearnableOptimizer.zero_grad","text":"Only reset target parameters.","title":"zero_grad()"},{"location":"docs/learn2learn.optim/#learn2learn.optim.parameter_update.ParameterUpdate","text":"[Source] Description Convenience class to implement custom update functions. Objects instantiated from this class behave similarly to torch.autograd.grad , but return parameter updates as opposed to gradients. Concretely, the gradients are first computed, then fed to their respective transform whose output is finally returned to the user. Additionally, this class supports parameters that might not require updates by setting the allow_nograd flag to True. In this case, the returned update is None . Arguments parameters (list) - Parameters of the model to update. transform (callable) - A callable that returns an instantiated transform given a parameter. Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 model = torch . nn . Linear () transform = l2l . optim . KroneckerTransform ( l2l . nn . KroneckerLinear ) get_update = ParameterUpdate ( model , transform ) opt = torch . optim . SGD ( model . parameters () + get_update . parameters ()) for iteration in range ( 10 ): opt . zero_grad () error = loss ( model ( X ), y ) updates = get_update ( error , model . parameters (), create_graph = True , ) l2l . update_module ( model , updates ) opt . step ()","title":"ParameterUpdate"},{"location":"docs/learn2learn.optim/#learn2learn.optim.parameter_update.ParameterUpdate.forward","text":"Description Similar to torch.autograd.grad, but passes the gradients through the provided transform. Arguments loss (Tensor) - The loss to differentiate. parameters (iterable) - Parameters w.r.t. which we want to compute the update. create_graph (bool, optional , default=False) - Same as torch.autograd.grad . retain_graph (bool, optional , default=False) - Same as torch.autograd.grad . allow_unused (bool, optional , default=False) - Same as torch.autograd.grad . allow_nograd (bool, optional , default=False) - Properly handles parameters that do not require gradients. (Their update will be None .)","title":"forward()"},{"location":"docs/learn2learn.optim/#learn2learn.optim.update_rules.differentiable_sgd.DifferentiableSGD","text":"[Source] Description A callable object that applies a list of updates to the parameters of a torch.nn.Module in a differentiable manner. For each parameter p and corresponding gradient g , calling an instance of this class results in updating parameters: p \\gets p - \\alpha g, where \\alpha is the learning rate. Note: The module is updated in-place. Arguments lr (float) - The learning rate used to update the model. Example 1 2 3 4 5 6 sgd = DifferentiableSGD ( 0.1 ) gradients = torch . autograd . grad ( loss , model . parameters (), create_gaph = True ) sgd ( model , gradients ) # model is updated in-place","title":"DifferentiableSGD"},{"location":"docs/learn2learn.optim/#learn2learn.optim.update_rules.differentiable_sgd.DifferentiableSGD.forward","text":"Arguments module (Module) - The module to update. gradients (list, optional , default=None) - A list of gradients for each parameter of the module. If None, will use the gradients in .grad attributes.","title":"forward()"},{"location":"docs/learn2learn.optim/#learn2learnoptimtransforms","text":"","title":"learn2learn.optim.transforms"},{"location":"docs/learn2learn.optim/#learn2learn.optim.transforms.module_transform.ModuleTransform","text":"[Source] Description The ModuleTransform creates a an optimization transform based on any nn.Module. ModuleTransform automatically instanciates a module from its class, based on a given parameter. The input and output shapes are of the module are set to (1, param.numel()) . When optimizing large layers, this type of transform can quickly run out of memory. See KroneckerTransform for a scalable alternative. Arguments module_cls (callable) - A callable that instantiates the module used to transform gradients. Example 1 2 3 4 5 6 classifier = torch . nn . Linear ( 784 , 10 , bias = False ) linear_transform = ModuleTransform ( torch . nn . Linear ) linear_update = linear_transform ( classifier . weight ) # maps gradients to updates, both of shape (1, 7840) loss ( classifier ( X ), y ) . backward () update = linear_update ( classifier . weight . grad ) classifier . weight . data . add_ ( - lr , update ) # Not a differentiable update. See l2l.optim.DifferentiableSGD.","title":"ModuleTransform"},{"location":"docs/learn2learn.optim/#learn2learn.optim.transforms.kronecker_transform.KroneckerTransform","text":"[Source] Description The KroneckerTransform creates a an optimization transform based on nn.Module's that admit a Kronecker factorization. (see l2l.nn.Kronecker* ) Akin to the ModuleTransform, this class of transform instanciates a module from its class, based on a given parameter. But, instead of reshaping the gradients to shape (1, param.numel()) , this class assumes a Kronecker factorization of the weights for memory and computational efficiency. The specific dimension of the Kronecker factorization depends on the the parameter's shape. For a weight of shape (n, m), a KroneckerLinear transform consists of two weights with shapes (n, n) and (m, m) rather than a single weight of shape (nm, nm). Refer to Arnold et al., 2019 for more details. Arguments kronecker_cls (callable) - A callable that instantiates the Kronecker module used to transform gradients. References Arnold et al. 2019. \"When MAML can adapt fast and how to assist when it cannot\". Example 1 2 3 4 5 6 classifier = torch . nn . Linear ( 784 , 10 , bias = False ) kronecker_transform = KroneckerTransform ( l2l . nn . KroneckerLinear ) kronecker_update = kronecker_transform ( classifier . weight ) loss ( classifier ( X ), y ) . backward () update = kronecker_update ( classifier . weight . grad ) classifier . weight . data . add_ ( - lr , update ) # Not a differentiable update. See l2l.optim.DifferentiableSGD.","title":"KroneckerTransform"},{"location":"docs/learn2learn.optim/#learn2learn.optim.transforms.metacurvature_transform.MetaCurvatureTransform","text":"[Source] Description Implements the Meta-Curvature transform of Park and Oliva, 2019. Unlike ModuleTranform and KroneckerTransform , this class does not wrap other Modules but is directly called on a weight to instantiate the transform. Arguments param (Tensor) - The weight whose gradients will be transformed. lr (float, optional , default=1.0) - Scaling factor of the udpate. (non-learnable) References Park & Oliva. 2019. Meta-curvature. Example 1 2 3 4 5 classifier = torch . nn . Linear ( 784 , 10 , bias = False ) metacurvature_update = MetaCurvatureTransform ( classifier . weight ) loss ( classifier ( X ), y ) . backward () update = metacurvature_update ( classifier . weight . grad ) classifier . weight . data . add_ ( - lr , update ) # Not a differentiable update. See l2l.optim.DifferentiableSGD.","title":"MetaCurvatureTransform"},{"location":"docs/learn2learn.vision/","text":"learn2learn.vision \u00b6 Datasets, models, and other utilities related to computer vision. learn2learn.vision.models \u00b6 OmniglotFC ( Module ) \u00b6 [Source] Description The fully-connected network used for Omniglot experiments, as described in Santoro et al, 2016. References Santoro et al. 2016. \u201cMeta-Learning with Memory-Augmented Neural Networks.\u201d ICML. Arguments input_size (int) - The dimensionality of the input. output_size (int) - The dimensionality of the output. sizes (list, optional , default=None) - A list of hidden layer sizes. Example 1 2 3 net = OmniglotFC ( input_size = 28 ** 2 , output_size = 10 , sizes = [ 64 , 64 , 64 ]) OmniglotCNN ( Module ) \u00b6 Source Description The convolutional network commonly used for Omniglot, as described by Finn et al, 2017. This network assumes inputs of shapes (1, 28, 28). References Finn et al. 2017. \u201cModel-Agnostic Meta-Learning for Fast Adaptation of Deep Networks.\u201d ICML. Arguments output_size (int) - The dimensionality of the network's output. hidden_size (int, optional , default=64) - The dimensionality of the hidden representation. layers (int, optional , default=4) - The number of convolutional layers. Example 1 model = OmniglotCNN ( output_size = 20 , hidden_size = 128 , layers = 3 ) CNN4 ( Module ) \u00b6 [Source] Description The convolutional network commonly used for MiniImagenet, as described by Ravi et Larochelle, 2017. This network assumes inputs of shapes (3, 84, 84). Instantiate CNN4Backbone if you only need the feature extractor. References Ravi and Larochelle. 2017. \u201cOptimization as a Model for Few-Shot Learning.\u201d ICLR. Arguments output_size (int) - The dimensionality of the network's output. hidden_size (int, optional , default=64) - The dimensionality of the hidden representation. layers (int, optional , default=4) - The number of convolutional layers. channels (int, optional , default=3) - The number of channels in input. max_pool (bool, optional , default=True) - Whether ConvBlocks use max-pooling. embedding_size (int, optional , default=None) - Size of feature embedding. Defaults to 25 * hidden_size (for mini-Imagenet). Example 1 model = CNN4 ( output_size = 20 , hidden_size = 128 , layers = 3 ) ResNet12 ( Module ) \u00b6 [Source] Description The 12-layer residual network from Mishra et al, 2017. The code is adapted from Lee et al, 2019 who share it under the Apache 2 license. Instantiate ResNet12Backbone if you only need the feature extractor. List of changes: Rename ResNet to ResNet12. Small API modifications. Fix code style to be compatible with PEP8. Support multiple devices in DropBlock References Mishra et al. 2017. \u201cA Simple Neural Attentive Meta-Learner.\u201d ICLR 18. Lee et al. 2019. \u201cMeta-Learning with Differentiable Convex Optimization.\u201d CVPR 19. Lee et al's code: https://github.com/kjunelee/MetaOptNet/ Oreshkin et al. 2018. \u201cTADAM: Task Dependent Adaptive Metric for Improved Few-Shot Learning.\u201d NeurIPS 18. Arguments output_size (int) - The dimensionality of the output (eg, number of classes). hidden_size (list, optional , default=640) - Size of the embedding once features are extracted. (640 is for mini-ImageNet; used for the classifier layer) avg_pool (bool, optional , default=True) - Set to False for the 16k-dim embeddings of Lee et al, 2019. wider (bool, optional , default=True) - True uses (64, 160, 320, 640) filters akin to Lee et al, 2019. False uses (64, 128, 256, 512) filters, akin to Oreshkin et al, 2018. embedding_dropout (float, optional , default=0.0) - Dropout rate on the flattened embedding layer. dropblock_dropout (float, optional , default=0.1) - Dropout rate for the residual layers. dropblock_size (int, optional , default=5) - Size of drop blocks. Example 1 model = ResNet12 ( output_size = ways , hidden_size = 1600 , avg_pool = False ) WRN28 ( Module ) \u00b6 [Source] Description The 28-layer 10-depth wide residual network from Dhillon et al, 2020. The code is adapted from Ye et al, 2020 who share it under the MIT license. Instantiate WRN28Backbone if you only need the feature extractor. References Dhillon et al. 2020. \u201cA Baseline for Few-Shot Image Classification.\u201d ICLR 20. Ye et al. 2020. \u201cFew-Shot Learning via Embedding Adaptation with Set-to-Set Functions.\u201d CVPR 20. Ye et al's code: https://github.com/Sha-Lab/FEAT Arguments output_size (int) - The dimensionality of the output. hidden_size (list, optional , default=640) - Size of the embedding once features are extracted. (640 is for mini-ImageNet; used for the classifier layer) dropout (float, optional , default=0.0) - Dropout rate. Example 1 model = WRN28 ( output_size = ways , hidden_size = 1600 , avg_pool = False ) get_pretrained_backbone ( model , dataset , spec = 'default' , root = '~/data' , download = False ) \u00b6 [Source] Description Returns pretrained backbone for a benchmark dataset. The returned object is a torch.nn.Module instance. Arguments model (str) - The name of the model ( cnn4 , resnet12 , or wrn28 ) dataset (str) - The name of the benchmark dataset ( mini-imagenet or tiered-imagenet ). spec (str, optional , default='default') - Which weight specification to load ( default ). root (str, optional , default='~/data') - Location of the pretrained weights. download (bool, optional , default=False) - Download the pretrained weights if not available? Example 1 2 3 4 5 6 backbone = l2l . vision . models . get_pretrained_backbone ( model = 'resnet12' , dataset = 'mini-imagenet' , root = '~/.data' , download = True , ) learn2learn.vision.datasets \u00b6 FullOmniglot ( Dataset ) \u00b6 [Source] Description This class provides an interface to the Omniglot dataset. The Omniglot dataset was introduced by Lake et al., 2015. Omniglot consists of 1623 character classes from 50 different alphabets, each containing 20 samples. While the original dataset is separated in background and evaluation sets, this class concatenates both sets and leaves to the user the choice of classes splitting as was done in Ravi and Larochelle, 2017. The background and evaluation splits are available in the torchvision package. References Lake et al. 2015. \u201cHuman-Level Concept Learning through Probabilistic Program Induction.\u201d Science. Ravi and Larochelle. 2017. \u201cOptimization as a Model for Few-Shot Learning.\u201d ICLR. Arguments root (str) - Path to download the data. transform (Transform, optional , default=None) - Input pre-processing. target_transform (Transform, optional , default=None) - Target pre-processing. download (bool, optional , default=False) - Whether to download the dataset. Example 1 2 3 4 5 6 7 8 omniglot = l2l . vision . datasets . FullOmniglot ( root = './data' , transform = transforms . Compose ([ transforms . Resize ( 28 , interpolation = LANCZOS ), transforms . ToTensor (), lambda x : 1.0 - x , ]), download = True ) omniglot = l2l . data . MetaDataset ( omniglot ) MiniImagenet ( Dataset ) \u00b6 [Source] Description The mini -ImageNet dataset was originally introduced by Vinyals et al., 2016. It consists of 60'000 colour images of sizes 84x84 pixels. The dataset is divided in 3 splits of 64 training, 16 validation, and 20 testing classes each containing 600 examples. The classes are sampled from the ImageNet dataset, and we use the splits from Ravi & Larochelle, 2017. References Vinyals et al. 2016. \u201cMatching Networks for One Shot Learning.\u201d NeurIPS. Ravi and Larochelle. 2017. \u201cOptimization as a Model for Few-Shot Learning.\u201d ICLR. Arguments root (str) - Path to download the data. mode (str, optional , default='train') - Which split to use. Must be 'train', 'validation', or 'test'. transform (Transform, optional , default=None) - Input pre-processing. target_transform (Transform, optional , default=None) - Target pre-processing. download (bool, optional , default=False) - Download the dataset if it's not available. Example 1 2 3 train_dataset = l2l . vision . datasets . MiniImagenet ( root = './data' , mode = 'train' ) train_dataset = l2l . data . MetaDataset ( train_dataset ) train_generator = l2l . data . TaskGenerator ( dataset = train_dataset , ways = ways ) TieredImagenet ( Dataset ) \u00b6 [Source] Description The tiered -ImageNet dataset was originally introduced by Ren et al, 2018 and we download the data directly from the link provided in their repository. Like mini -ImageNet, tiered -ImageNet builds on top of ILSVRC-12, but consists of 608 classes (779,165 images) instead of 100. The train-validation-test split is made such that classes from similar categories are in the same splits. There are 34 categories each containing between 10 and 30 classes. Of these categories, 20 (351 classes; 448,695 images) are used for training, 6 (97 classes; 124,261 images) for validation, and 8 (160 class; 206,209 images) for testing. References Ren et al, 2018. \"Meta-Learning for Semi-Supervised Few-Shot Classification.\" ICLR '18. Ren Mengye. 2018. \"few-shot-ssl-public\". https://github.com/renmengye/few-shot-ssl-public Arguments root (str) - Path to download the data. mode (str, optional , default='train') - Which split to use. Must be 'train', 'validation', or 'test'. transform (Transform, optional , default=None) - Input pre-processing. target_transform (Transform, optional , default=None) - Target pre-processing. download (bool, optional , default=False) - Whether to download the dataset. Example 1 2 3 train_dataset = l2l . vision . datasets . TieredImagenet ( root = './data' , mode = 'train' , download = True ) train_dataset = l2l . data . MetaDataset ( train_dataset ) train_generator = l2l . data . TaskDataset ( dataset = train_dataset , num_tasks = 1000 ) CIFARFS ( ImageFolder ) \u00b6 [Source] Description The CIFAR Few-Shot dataset as originally introduced by Bertinetto et al., 2019. It consists of 60'000 colour images of sizes 32x32 pixels. The dataset is divided in 3 splits of 64 training, 16 validation, and 20 testing classes each containing 600 examples. The classes are sampled from the CIFAR-100 dataset, and we use the splits from Bertinetto et al., 2019. References Bertinetto et al. 2019. \"Meta-learning with differentiable closed-form solvers\". ICLR. Arguments root (str) - Path to download the data. mode (str, optional , default='train') - Which split to use. Must be 'train', 'validation', or 'test'. transform (Transform, optional , default=None) - Input pre-processing. target_transform (Transform, optional , default=None) - Target pre-processing. Example 1 2 3 train_dataset = l2l . vision . datasets . CIFARFS ( root = './data' , mode = 'train' ) train_dataset = l2l . data . MetaDataset ( train_dataset ) train_generator = l2l . data . TaskGenerator ( dataset = train_dataset , ways = ways ) FC100 ( Dataset ) \u00b6 [Source] Description The FC100 dataset was originally introduced by Oreshkin et al., 2018. It is based on CIFAR100, but unlike CIFAR-FS training, validation, and testing classes are split so as to minimize the information overlap between splits. The 100 classes are grouped into 20 superclasses of which 12 (60 classes) are used for training, 4 (20 classes) for validation, and 4 (20 classes) for testing. Each class contains 600 images. The specific splits are provided in the Supplementary Material of the paper. Our data is downloaded from the link provided by [2]. References Oreshkin et al. 2018. \"TADAM: Task Dependent Adaptive Metric for Improved Few-Shot Learning.\" NeurIPS. Kwoonjoon Lee. 2019. \"MetaOptNet.\" https://github.com/kjunelee/MetaOptNet Arguments root (str) - Path to download the data. mode (str, optional , default='train') - Which split to use. Must be 'train', 'validation', or 'test'. transform (Transform, optional , default=None) - Input pre-processing. target_transform (Transform, optional , default=None) - Target pre-processing. Example 1 2 3 train_dataset = l2l . vision . datasets . FC100 ( root = './data' , mode = 'train' ) train_dataset = l2l . data . MetaDataset ( train_dataset ) train_generator = l2l . data . TaskDataset ( dataset = train_dataset , num_tasks = 1000 ) VGGFlower102 ( Dataset ) \u00b6 [Source] Description The VGG Flowers dataset was originally introduced by Nilsback and Zisserman, 2006 and then re-purposed for few-shot learning in Triantafillou et al., 2020. The dataset consists of 102 classes of flowers, with each class consisting of 40 to 258 images. We provide the raw (unprocessed) images, and follow the train-validation-test splits of Triantafillou et al. References Nilsback, M. and A. Zisserman. 2006. \"A Visual Vocabulary for Flower Classification.\" CVPR '06. Triantafillou et al. 2020. \"Meta-Dataset: A Dataset of Datasets for Learning to Learn from Few Examples.\" ICLR '20. https://www.robots.ox.ac.uk/~vgg/data/flowers/ Arguments root (str) - Path to download the data. mode (str, optional , default='train') - Which split to use. Must be 'train', 'validation', or 'test'. transform (Transform, optional , default=None) - Input pre-processing. target_transform (Transform, optional , default=None) - Target pre-processing. download (bool, optional , default=False) - Whether to download the dataset. Example 1 2 3 train_dataset = l2l . vision . datasets . VGGFlower102 ( root = './data' , mode = 'train' ) train_dataset = l2l . data . MetaDataset ( train_dataset ) train_generator = l2l . data . TaskDataset ( dataset = train_dataset , num_tasks = 1000 ) FGVCAircraft ( Dataset ) \u00b6 [Source] Description The FGVC Aircraft dataset was originally introduced by Maji et al., 2013 and then re-purposed for few-shot learning in Triantafillou et al., 2020. The dataset consists of 10,200 images of aircraft (102 classes, each 100 images). We provided the raw (un-processed) images and follow the train-validation-test splits of Triantafillou et al. TODO: Triantafillou et al. recommend cropping the images using the bounding box information, to remove copyright information and ensure that only one plane is visible in the image. References Maji et al. 2013. \"Fine-Grained Visual Classification of Aircraft.\" arXiv [cs.CV]. Triantafillou et al. 2020. \"Meta-Dataset: A Dataset of Datasets for Learning to Learn from Few Examples.\" ICLR '20. http://www.robots.ox.ac.uk/~vgg/data/fgvc-aircraft/ Arguments root (str) - Path to download the data. mode (str, optional , default='train') - Which split to use. Must be 'train', 'validation', or 'test'. transform (Transform, optional , default=None) - Input pre-processing. target_transform (Transform, optional , default=None) - Target pre-processing. download (bool, optional , default=False) - Whether to download the dataset. bounding_box_crop (bool, optional , default=False) - Whether to crop each image using bounding box information. Example 1 2 3 train_dataset = l2l . vision . datasets . FGVCAircraft ( root = './data' , mode = 'train' , download = True ) train_dataset = l2l . data . MetaDataset ( train_dataset ) train_generator = l2l . data . TaskDataset ( dataset = train_dataset , num_tasks = 1000 ) FGVCFungi ( Dataset ) \u00b6 [Source] Description The FGVC Fungi dataset was originally introduced in the 5th Workshop on Fine-Grained Visual Categorization (FGVC) and then re-purposed for few-shot learning in Triantafillou et al., 2020. The dataset consists of 1,394 classes and 89,760 images of fungi. We provide the raw (unprocessed) images, and follow the train-validation-test splits of Triantafillou et al. Important You must agree to the original Terms of Use to use this dataset. More information here: https://github.com/visipedia/fgvcx_fungi_comp References https://sites.google.com/view/fgvc5/home Triantafillou et al. 2020. \"Meta-Dataset: A Dataset of Datasets for Learning to Learn from Few Examples.\" ICLR '20. https://github.com/visipedia/fgvcx_fungi_comp Arguments root (str) - Path to download the data. mode (str, optional , default='train') - Which split to use. Must be 'train', 'validation', or 'test'. transform (Transform, optional , default=None) - Input pre-processing. target_transform (Transform, optional , default=None) - Target pre-processing. download (bool, optional , default=False) - Whether to download the dataset. Example 1 2 3 train_dataset = l2l . vision . datasets . FGVCFungi ( root = './data' , mode = 'train' ) train_dataset = l2l . data . MetaDataset ( train_dataset ) train_generator = l2l . data . TaskDataset ( dataset = train_dataset , num_tasks = 1000 ) DescribableTextures ( Dataset ) \u00b6 [Source] Description The VGG Describable Textures dataset was originally introduced by Cimpoi et al., 2014 and then re-purposed for few-shot learning in Triantafillou et al., 2020. The dataset consists of 5640 images organized according to 47 texture classes. Each class consists of 120 images between 300x300 and 640x640 pixels. Each image contains at least 90% of the texture. We follow the train-validation-test splits of Triantafillou et al., 2020. (33 classes for train, 7 for validation and test.) References Cimpoi et al. 2014. \"Describing Textures in the Wild.\" CVPR'14. Triantafillou et al. 2020. \"Meta-Dataset: A Dataset of Datasets for Learning to Learn from Few Examples.\" ICLR '20. https://www.robots.ox.ac.uk/~vgg/data/dtd/ Arguments root (str) - Path to download the data. mode (str, optional , default='train') - Which split to use. Must be 'train', 'validation', or 'test'. transform (Transform, optional , default=None) - Input pre-processing. target_transform (Transform, optional , default=None) - Target pre-processing. download (bool, optional , default=False) - Whether to download the dataset. Example 1 2 3 train_dataset = l2l . vision . datasets . DescribableTextures ( root = './data' , mode = 'train' ) train_dataset = l2l . data . MetaDataset ( train_dataset ) train_generator = l2l . data . TaskDataset ( dataset = train_dataset , num_tasks = 1000 ) CUBirds200 ( Dataset ) \u00b6 [Source] Description The Caltech-UCSD Birds dataset was originally introduced by Wellinder et al., 2010 and then re-purposed for few-shot learning in Triantafillou et al., 2020. The dataset consists of 6,033 bird images classified into 200 bird species. The train set consists of 140 classes, while the validation and test sets each contain 30. We provide the raw (unprocessed) images, and follow the train-validation-test splits of Triantafillou et al. This dataset includes 43 images that overlap with the ILSVRC-2012 (ImageNet) dataset. They are omitted by default, but can be included by setting the include_imagenet_duplicates flag to True . References Welinder et al. 2010. \"Caltech-UCSD Birds 200.\" Caltech Technical Report. Triantafillou et al. 2020. \"Meta-Dataset: A Dataset of Datasets for Learning to Learn from Few Examples.\" ICLR '20. http://www.vision.caltech.edu/visipedia/CUB-200.html Arguments root (str) - Path to download the data. mode (str, optional , default='train') - Which split to use. Must be 'train', 'validation', or 'test'. transform (Transform, optional , default=None) - Input pre-processing. target_transform (Transform, optional , default=None) - Target pre-processing. download (bool, optional , default=False) - Whether to download the dataset. include_imagenet_duplicates (bool, optional , default=False) - Whether to include images that are also present in the ImageNet 2012 dataset. bounding_box_crop (bool, optional , default=False) - Whether to crop each image using bounding box information. Example 1 2 3 train_dataset = l2l . vision . datasets . CUBirds200 ( root = './data' , mode = 'train' ) train_dataset = l2l . data . MetaDataset ( train_dataset ) train_generator = l2l . data . TaskDataset ( dataset = train_dataset , num_tasks = 1000 ) Quickdraw ( Dataset ) \u00b6 [Source] Description The Quickdraw dataset was originally introduced by Google Creative Lab in 2017 and then re-purposed for few-shot learning in Triantafillou et al., 2020. See Ha and Heck, 2017 for more information. The dataset consists of roughly 50M drawing images of 345 objects. Each image was hand-drawn by human annotators and is represented as black-and-white 28x28 pixel array. We follow the train-validation-test splits of Triantafillou et al., 2020. (241 classes for train, 52 for validation, and 52 for test.) References https://github.com/googlecreativelab/quickdraw-dataset Ha, David, and Douglas Eck. 2017. \"A Neural Representation of Sketch Drawings.\" ArXiv '17. Triantafillou et al. 2020. \"Meta-Dataset: A Dataset of Datasets for Learning to Learn from Few Examples.\" ICLR '20. Arguments root (str) - Path to download the data. mode (str, optional , default='train') - Which split to use. Must be 'train', 'validation', or 'test'. transform (Transform, optional , default=None) - Input pre-processing. target_transform (Transform, optional , default=None) - Target pre-processing. download (bool, optional , default=False) - Whether to download the dataset. Example 1 2 3 train_dataset = l2l . vision . datasets . Quickdraw ( root = './data' , mode = 'train' ) train_dataset = l2l . data . MetaDataset ( train_dataset ) train_generator = l2l . data . TaskDataset ( dataset = train_dataset , num_tasks = 1000 ) learn2learn.vision.transforms \u00b6 RandomClassRotation \u00b6 [Source] Description Samples rotations from a given list uniformly at random, and applies it to all images from a given class. Arguments degrees (list) - The rotations to be sampled. Example 1 transform = RandomClassRotation ([ 0 , 90 , 180 , 270 ]) learn2learn.vision.benchmarks \u00b6 list_tasksets () \u00b6 [Source] Description Returns a list of all available benchmarks. Example 1 2 3 for name in l2l . vision . benchmarks . list_tasksets (): print ( name ) tasksets = l2l . vision . benchmarks . get_tasksets ( name ) get_tasksets ( name , train_ways = 5 , train_samples = 10 , test_ways = 5 , test_samples = 10 , num_tasks =- 1 , root = '~/data' , device = None , ** kwargs ) \u00b6 [Source] Description Returns the tasksets for a particular benchmark, using literature standard data and task transformations. The returned object is a namedtuple with attributes train , validation , test which correspond to their respective TaskDatasets. See examples/vision/maml_miniimagenet.py for an example. Arguments name (str) - The name of the benchmark. Full list in list_tasksets() . train_ways (int, optional , default=5) - The number of classes per train tasks. train_samples (int, optional , default=10) - The number of samples per train tasks. test_ways (int, optional , default=5) - The number of classes per test tasks. Also used for validation tasks. test_samples (int, optional , default=10) - The number of samples per test tasks. Also used for validation tasks. num_tasks (int, optional , default=-1) - The number of tasks in each TaskDataset. device (torch.Device, optional , default=None) - If not None, tasksets are loaded as Tensors on device . root (str, optional , default='~/data') - Where the data is stored. Example 1 2 3 4 5 6 7 train_tasks , validation_tasks , test_tasks = l2l . vision . benchmarks . get_tasksets ( 'omniglot' ) batch = train_tasks . sample () or : tasksets = l2l . vision . benchmarks . get_tasksets ( 'omniglot' ) batch = tasksets . train . sample ()","title":"learn2learn.vision"},{"location":"docs/learn2learn.vision/#learn2learnvision","text":"Datasets, models, and other utilities related to computer vision.","title":"learn2learn.vision"},{"location":"docs/learn2learn.vision/#learn2learnvisionmodels","text":"","title":"learn2learn.vision.models"},{"location":"docs/learn2learn.vision/#learn2learn.vision.models.cnn4.OmniglotFC","text":"[Source] Description The fully-connected network used for Omniglot experiments, as described in Santoro et al, 2016. References Santoro et al. 2016. \u201cMeta-Learning with Memory-Augmented Neural Networks.\u201d ICML. Arguments input_size (int) - The dimensionality of the input. output_size (int) - The dimensionality of the output. sizes (list, optional , default=None) - A list of hidden layer sizes. Example 1 2 3 net = OmniglotFC ( input_size = 28 ** 2 , output_size = 10 , sizes = [ 64 , 64 , 64 ])","title":"OmniglotFC"},{"location":"docs/learn2learn.vision/#learn2learn.vision.models.cnn4.OmniglotCNN","text":"Source Description The convolutional network commonly used for Omniglot, as described by Finn et al, 2017. This network assumes inputs of shapes (1, 28, 28). References Finn et al. 2017. \u201cModel-Agnostic Meta-Learning for Fast Adaptation of Deep Networks.\u201d ICML. Arguments output_size (int) - The dimensionality of the network's output. hidden_size (int, optional , default=64) - The dimensionality of the hidden representation. layers (int, optional , default=4) - The number of convolutional layers. Example 1 model = OmniglotCNN ( output_size = 20 , hidden_size = 128 , layers = 3 )","title":"OmniglotCNN"},{"location":"docs/learn2learn.vision/#learn2learn.vision.models.cnn4.CNN4","text":"[Source] Description The convolutional network commonly used for MiniImagenet, as described by Ravi et Larochelle, 2017. This network assumes inputs of shapes (3, 84, 84). Instantiate CNN4Backbone if you only need the feature extractor. References Ravi and Larochelle. 2017. \u201cOptimization as a Model for Few-Shot Learning.\u201d ICLR. Arguments output_size (int) - The dimensionality of the network's output. hidden_size (int, optional , default=64) - The dimensionality of the hidden representation. layers (int, optional , default=4) - The number of convolutional layers. channels (int, optional , default=3) - The number of channels in input. max_pool (bool, optional , default=True) - Whether ConvBlocks use max-pooling. embedding_size (int, optional , default=None) - Size of feature embedding. Defaults to 25 * hidden_size (for mini-Imagenet). Example 1 model = CNN4 ( output_size = 20 , hidden_size = 128 , layers = 3 )","title":"CNN4"},{"location":"docs/learn2learn.vision/#learn2learn.vision.models.resnet12.ResNet12","text":"[Source] Description The 12-layer residual network from Mishra et al, 2017. The code is adapted from Lee et al, 2019 who share it under the Apache 2 license. Instantiate ResNet12Backbone if you only need the feature extractor. List of changes: Rename ResNet to ResNet12. Small API modifications. Fix code style to be compatible with PEP8. Support multiple devices in DropBlock References Mishra et al. 2017. \u201cA Simple Neural Attentive Meta-Learner.\u201d ICLR 18. Lee et al. 2019. \u201cMeta-Learning with Differentiable Convex Optimization.\u201d CVPR 19. Lee et al's code: https://github.com/kjunelee/MetaOptNet/ Oreshkin et al. 2018. \u201cTADAM: Task Dependent Adaptive Metric for Improved Few-Shot Learning.\u201d NeurIPS 18. Arguments output_size (int) - The dimensionality of the output (eg, number of classes). hidden_size (list, optional , default=640) - Size of the embedding once features are extracted. (640 is for mini-ImageNet; used for the classifier layer) avg_pool (bool, optional , default=True) - Set to False for the 16k-dim embeddings of Lee et al, 2019. wider (bool, optional , default=True) - True uses (64, 160, 320, 640) filters akin to Lee et al, 2019. False uses (64, 128, 256, 512) filters, akin to Oreshkin et al, 2018. embedding_dropout (float, optional , default=0.0) - Dropout rate on the flattened embedding layer. dropblock_dropout (float, optional , default=0.1) - Dropout rate for the residual layers. dropblock_size (int, optional , default=5) - Size of drop blocks. Example 1 model = ResNet12 ( output_size = ways , hidden_size = 1600 , avg_pool = False )","title":"ResNet12"},{"location":"docs/learn2learn.vision/#learn2learn.vision.models.wrn28.WRN28","text":"[Source] Description The 28-layer 10-depth wide residual network from Dhillon et al, 2020. The code is adapted from Ye et al, 2020 who share it under the MIT license. Instantiate WRN28Backbone if you only need the feature extractor. References Dhillon et al. 2020. \u201cA Baseline for Few-Shot Image Classification.\u201d ICLR 20. Ye et al. 2020. \u201cFew-Shot Learning via Embedding Adaptation with Set-to-Set Functions.\u201d CVPR 20. Ye et al's code: https://github.com/Sha-Lab/FEAT Arguments output_size (int) - The dimensionality of the output. hidden_size (list, optional , default=640) - Size of the embedding once features are extracted. (640 is for mini-ImageNet; used for the classifier layer) dropout (float, optional , default=0.0) - Dropout rate. Example 1 model = WRN28 ( output_size = ways , hidden_size = 1600 , avg_pool = False )","title":"WRN28"},{"location":"docs/learn2learn.vision/#learn2learn.vision.models.get_pretrained_backbone","text":"[Source] Description Returns pretrained backbone for a benchmark dataset. The returned object is a torch.nn.Module instance. Arguments model (str) - The name of the model ( cnn4 , resnet12 , or wrn28 ) dataset (str) - The name of the benchmark dataset ( mini-imagenet or tiered-imagenet ). spec (str, optional , default='default') - Which weight specification to load ( default ). root (str, optional , default='~/data') - Location of the pretrained weights. download (bool, optional , default=False) - Download the pretrained weights if not available? Example 1 2 3 4 5 6 backbone = l2l . vision . models . get_pretrained_backbone ( model = 'resnet12' , dataset = 'mini-imagenet' , root = '~/.data' , download = True , )","title":"get_pretrained_backbone()"},{"location":"docs/learn2learn.vision/#learn2learnvisiondatasets","text":"","title":"learn2learn.vision.datasets"},{"location":"docs/learn2learn.vision/#learn2learn.vision.datasets.full_omniglot.FullOmniglot","text":"[Source] Description This class provides an interface to the Omniglot dataset. The Omniglot dataset was introduced by Lake et al., 2015. Omniglot consists of 1623 character classes from 50 different alphabets, each containing 20 samples. While the original dataset is separated in background and evaluation sets, this class concatenates both sets and leaves to the user the choice of classes splitting as was done in Ravi and Larochelle, 2017. The background and evaluation splits are available in the torchvision package. References Lake et al. 2015. \u201cHuman-Level Concept Learning through Probabilistic Program Induction.\u201d Science. Ravi and Larochelle. 2017. \u201cOptimization as a Model for Few-Shot Learning.\u201d ICLR. Arguments root (str) - Path to download the data. transform (Transform, optional , default=None) - Input pre-processing. target_transform (Transform, optional , default=None) - Target pre-processing. download (bool, optional , default=False) - Whether to download the dataset. Example 1 2 3 4 5 6 7 8 omniglot = l2l . vision . datasets . FullOmniglot ( root = './data' , transform = transforms . Compose ([ transforms . Resize ( 28 , interpolation = LANCZOS ), transforms . ToTensor (), lambda x : 1.0 - x , ]), download = True ) omniglot = l2l . data . MetaDataset ( omniglot )","title":"FullOmniglot"},{"location":"docs/learn2learn.vision/#learn2learn.vision.datasets.mini_imagenet.MiniImagenet","text":"[Source] Description The mini -ImageNet dataset was originally introduced by Vinyals et al., 2016. It consists of 60'000 colour images of sizes 84x84 pixels. The dataset is divided in 3 splits of 64 training, 16 validation, and 20 testing classes each containing 600 examples. The classes are sampled from the ImageNet dataset, and we use the splits from Ravi & Larochelle, 2017. References Vinyals et al. 2016. \u201cMatching Networks for One Shot Learning.\u201d NeurIPS. Ravi and Larochelle. 2017. \u201cOptimization as a Model for Few-Shot Learning.\u201d ICLR. Arguments root (str) - Path to download the data. mode (str, optional , default='train') - Which split to use. Must be 'train', 'validation', or 'test'. transform (Transform, optional , default=None) - Input pre-processing. target_transform (Transform, optional , default=None) - Target pre-processing. download (bool, optional , default=False) - Download the dataset if it's not available. Example 1 2 3 train_dataset = l2l . vision . datasets . MiniImagenet ( root = './data' , mode = 'train' ) train_dataset = l2l . data . MetaDataset ( train_dataset ) train_generator = l2l . data . TaskGenerator ( dataset = train_dataset , ways = ways )","title":"MiniImagenet"},{"location":"docs/learn2learn.vision/#learn2learn.vision.datasets.tiered_imagenet.TieredImagenet","text":"[Source] Description The tiered -ImageNet dataset was originally introduced by Ren et al, 2018 and we download the data directly from the link provided in their repository. Like mini -ImageNet, tiered -ImageNet builds on top of ILSVRC-12, but consists of 608 classes (779,165 images) instead of 100. The train-validation-test split is made such that classes from similar categories are in the same splits. There are 34 categories each containing between 10 and 30 classes. Of these categories, 20 (351 classes; 448,695 images) are used for training, 6 (97 classes; 124,261 images) for validation, and 8 (160 class; 206,209 images) for testing. References Ren et al, 2018. \"Meta-Learning for Semi-Supervised Few-Shot Classification.\" ICLR '18. Ren Mengye. 2018. \"few-shot-ssl-public\". https://github.com/renmengye/few-shot-ssl-public Arguments root (str) - Path to download the data. mode (str, optional , default='train') - Which split to use. Must be 'train', 'validation', or 'test'. transform (Transform, optional , default=None) - Input pre-processing. target_transform (Transform, optional , default=None) - Target pre-processing. download (bool, optional , default=False) - Whether to download the dataset. Example 1 2 3 train_dataset = l2l . vision . datasets . TieredImagenet ( root = './data' , mode = 'train' , download = True ) train_dataset = l2l . data . MetaDataset ( train_dataset ) train_generator = l2l . data . TaskDataset ( dataset = train_dataset , num_tasks = 1000 )","title":"TieredImagenet"},{"location":"docs/learn2learn.vision/#learn2learn.vision.datasets.cifarfs.CIFARFS","text":"[Source] Description The CIFAR Few-Shot dataset as originally introduced by Bertinetto et al., 2019. It consists of 60'000 colour images of sizes 32x32 pixels. The dataset is divided in 3 splits of 64 training, 16 validation, and 20 testing classes each containing 600 examples. The classes are sampled from the CIFAR-100 dataset, and we use the splits from Bertinetto et al., 2019. References Bertinetto et al. 2019. \"Meta-learning with differentiable closed-form solvers\". ICLR. Arguments root (str) - Path to download the data. mode (str, optional , default='train') - Which split to use. Must be 'train', 'validation', or 'test'. transform (Transform, optional , default=None) - Input pre-processing. target_transform (Transform, optional , default=None) - Target pre-processing. Example 1 2 3 train_dataset = l2l . vision . datasets . CIFARFS ( root = './data' , mode = 'train' ) train_dataset = l2l . data . MetaDataset ( train_dataset ) train_generator = l2l . data . TaskGenerator ( dataset = train_dataset , ways = ways )","title":"CIFARFS"},{"location":"docs/learn2learn.vision/#learn2learn.vision.datasets.fc100.FC100","text":"[Source] Description The FC100 dataset was originally introduced by Oreshkin et al., 2018. It is based on CIFAR100, but unlike CIFAR-FS training, validation, and testing classes are split so as to minimize the information overlap between splits. The 100 classes are grouped into 20 superclasses of which 12 (60 classes) are used for training, 4 (20 classes) for validation, and 4 (20 classes) for testing. Each class contains 600 images. The specific splits are provided in the Supplementary Material of the paper. Our data is downloaded from the link provided by [2]. References Oreshkin et al. 2018. \"TADAM: Task Dependent Adaptive Metric for Improved Few-Shot Learning.\" NeurIPS. Kwoonjoon Lee. 2019. \"MetaOptNet.\" https://github.com/kjunelee/MetaOptNet Arguments root (str) - Path to download the data. mode (str, optional , default='train') - Which split to use. Must be 'train', 'validation', or 'test'. transform (Transform, optional , default=None) - Input pre-processing. target_transform (Transform, optional , default=None) - Target pre-processing. Example 1 2 3 train_dataset = l2l . vision . datasets . FC100 ( root = './data' , mode = 'train' ) train_dataset = l2l . data . MetaDataset ( train_dataset ) train_generator = l2l . data . TaskDataset ( dataset = train_dataset , num_tasks = 1000 )","title":"FC100"},{"location":"docs/learn2learn.vision/#learn2learn.vision.datasets.vgg_flowers.VGGFlower102","text":"[Source] Description The VGG Flowers dataset was originally introduced by Nilsback and Zisserman, 2006 and then re-purposed for few-shot learning in Triantafillou et al., 2020. The dataset consists of 102 classes of flowers, with each class consisting of 40 to 258 images. We provide the raw (unprocessed) images, and follow the train-validation-test splits of Triantafillou et al. References Nilsback, M. and A. Zisserman. 2006. \"A Visual Vocabulary for Flower Classification.\" CVPR '06. Triantafillou et al. 2020. \"Meta-Dataset: A Dataset of Datasets for Learning to Learn from Few Examples.\" ICLR '20. https://www.robots.ox.ac.uk/~vgg/data/flowers/ Arguments root (str) - Path to download the data. mode (str, optional , default='train') - Which split to use. Must be 'train', 'validation', or 'test'. transform (Transform, optional , default=None) - Input pre-processing. target_transform (Transform, optional , default=None) - Target pre-processing. download (bool, optional , default=False) - Whether to download the dataset. Example 1 2 3 train_dataset = l2l . vision . datasets . VGGFlower102 ( root = './data' , mode = 'train' ) train_dataset = l2l . data . MetaDataset ( train_dataset ) train_generator = l2l . data . TaskDataset ( dataset = train_dataset , num_tasks = 1000 )","title":"VGGFlower102"},{"location":"docs/learn2learn.vision/#learn2learn.vision.datasets.fgvc_aircraft.FGVCAircraft","text":"[Source] Description The FGVC Aircraft dataset was originally introduced by Maji et al., 2013 and then re-purposed for few-shot learning in Triantafillou et al., 2020. The dataset consists of 10,200 images of aircraft (102 classes, each 100 images). We provided the raw (un-processed) images and follow the train-validation-test splits of Triantafillou et al. TODO: Triantafillou et al. recommend cropping the images using the bounding box information, to remove copyright information and ensure that only one plane is visible in the image. References Maji et al. 2013. \"Fine-Grained Visual Classification of Aircraft.\" arXiv [cs.CV]. Triantafillou et al. 2020. \"Meta-Dataset: A Dataset of Datasets for Learning to Learn from Few Examples.\" ICLR '20. http://www.robots.ox.ac.uk/~vgg/data/fgvc-aircraft/ Arguments root (str) - Path to download the data. mode (str, optional , default='train') - Which split to use. Must be 'train', 'validation', or 'test'. transform (Transform, optional , default=None) - Input pre-processing. target_transform (Transform, optional , default=None) - Target pre-processing. download (bool, optional , default=False) - Whether to download the dataset. bounding_box_crop (bool, optional , default=False) - Whether to crop each image using bounding box information. Example 1 2 3 train_dataset = l2l . vision . datasets . FGVCAircraft ( root = './data' , mode = 'train' , download = True ) train_dataset = l2l . data . MetaDataset ( train_dataset ) train_generator = l2l . data . TaskDataset ( dataset = train_dataset , num_tasks = 1000 )","title":"FGVCAircraft"},{"location":"docs/learn2learn.vision/#learn2learn.vision.datasets.fgvc_fungi.FGVCFungi","text":"[Source] Description The FGVC Fungi dataset was originally introduced in the 5th Workshop on Fine-Grained Visual Categorization (FGVC) and then re-purposed for few-shot learning in Triantafillou et al., 2020. The dataset consists of 1,394 classes and 89,760 images of fungi. We provide the raw (unprocessed) images, and follow the train-validation-test splits of Triantafillou et al. Important You must agree to the original Terms of Use to use this dataset. More information here: https://github.com/visipedia/fgvcx_fungi_comp References https://sites.google.com/view/fgvc5/home Triantafillou et al. 2020. \"Meta-Dataset: A Dataset of Datasets for Learning to Learn from Few Examples.\" ICLR '20. https://github.com/visipedia/fgvcx_fungi_comp Arguments root (str) - Path to download the data. mode (str, optional , default='train') - Which split to use. Must be 'train', 'validation', or 'test'. transform (Transform, optional , default=None) - Input pre-processing. target_transform (Transform, optional , default=None) - Target pre-processing. download (bool, optional , default=False) - Whether to download the dataset. Example 1 2 3 train_dataset = l2l . vision . datasets . FGVCFungi ( root = './data' , mode = 'train' ) train_dataset = l2l . data . MetaDataset ( train_dataset ) train_generator = l2l . data . TaskDataset ( dataset = train_dataset , num_tasks = 1000 )","title":"FGVCFungi"},{"location":"docs/learn2learn.vision/#learn2learn.vision.datasets.describable_textures.DescribableTextures","text":"[Source] Description The VGG Describable Textures dataset was originally introduced by Cimpoi et al., 2014 and then re-purposed for few-shot learning in Triantafillou et al., 2020. The dataset consists of 5640 images organized according to 47 texture classes. Each class consists of 120 images between 300x300 and 640x640 pixels. Each image contains at least 90% of the texture. We follow the train-validation-test splits of Triantafillou et al., 2020. (33 classes for train, 7 for validation and test.) References Cimpoi et al. 2014. \"Describing Textures in the Wild.\" CVPR'14. Triantafillou et al. 2020. \"Meta-Dataset: A Dataset of Datasets for Learning to Learn from Few Examples.\" ICLR '20. https://www.robots.ox.ac.uk/~vgg/data/dtd/ Arguments root (str) - Path to download the data. mode (str, optional , default='train') - Which split to use. Must be 'train', 'validation', or 'test'. transform (Transform, optional , default=None) - Input pre-processing. target_transform (Transform, optional , default=None) - Target pre-processing. download (bool, optional , default=False) - Whether to download the dataset. Example 1 2 3 train_dataset = l2l . vision . datasets . DescribableTextures ( root = './data' , mode = 'train' ) train_dataset = l2l . data . MetaDataset ( train_dataset ) train_generator = l2l . data . TaskDataset ( dataset = train_dataset , num_tasks = 1000 )","title":"DescribableTextures"},{"location":"docs/learn2learn.vision/#learn2learn.vision.datasets.cu_birds200.CUBirds200","text":"[Source] Description The Caltech-UCSD Birds dataset was originally introduced by Wellinder et al., 2010 and then re-purposed for few-shot learning in Triantafillou et al., 2020. The dataset consists of 6,033 bird images classified into 200 bird species. The train set consists of 140 classes, while the validation and test sets each contain 30. We provide the raw (unprocessed) images, and follow the train-validation-test splits of Triantafillou et al. This dataset includes 43 images that overlap with the ILSVRC-2012 (ImageNet) dataset. They are omitted by default, but can be included by setting the include_imagenet_duplicates flag to True . References Welinder et al. 2010. \"Caltech-UCSD Birds 200.\" Caltech Technical Report. Triantafillou et al. 2020. \"Meta-Dataset: A Dataset of Datasets for Learning to Learn from Few Examples.\" ICLR '20. http://www.vision.caltech.edu/visipedia/CUB-200.html Arguments root (str) - Path to download the data. mode (str, optional , default='train') - Which split to use. Must be 'train', 'validation', or 'test'. transform (Transform, optional , default=None) - Input pre-processing. target_transform (Transform, optional , default=None) - Target pre-processing. download (bool, optional , default=False) - Whether to download the dataset. include_imagenet_duplicates (bool, optional , default=False) - Whether to include images that are also present in the ImageNet 2012 dataset. bounding_box_crop (bool, optional , default=False) - Whether to crop each image using bounding box information. Example 1 2 3 train_dataset = l2l . vision . datasets . CUBirds200 ( root = './data' , mode = 'train' ) train_dataset = l2l . data . MetaDataset ( train_dataset ) train_generator = l2l . data . TaskDataset ( dataset = train_dataset , num_tasks = 1000 )","title":"CUBirds200"},{"location":"docs/learn2learn.vision/#learn2learn.vision.datasets.quickdraw.Quickdraw","text":"[Source] Description The Quickdraw dataset was originally introduced by Google Creative Lab in 2017 and then re-purposed for few-shot learning in Triantafillou et al., 2020. See Ha and Heck, 2017 for more information. The dataset consists of roughly 50M drawing images of 345 objects. Each image was hand-drawn by human annotators and is represented as black-and-white 28x28 pixel array. We follow the train-validation-test splits of Triantafillou et al., 2020. (241 classes for train, 52 for validation, and 52 for test.) References https://github.com/googlecreativelab/quickdraw-dataset Ha, David, and Douglas Eck. 2017. \"A Neural Representation of Sketch Drawings.\" ArXiv '17. Triantafillou et al. 2020. \"Meta-Dataset: A Dataset of Datasets for Learning to Learn from Few Examples.\" ICLR '20. Arguments root (str) - Path to download the data. mode (str, optional , default='train') - Which split to use. Must be 'train', 'validation', or 'test'. transform (Transform, optional , default=None) - Input pre-processing. target_transform (Transform, optional , default=None) - Target pre-processing. download (bool, optional , default=False) - Whether to download the dataset. Example 1 2 3 train_dataset = l2l . vision . datasets . Quickdraw ( root = './data' , mode = 'train' ) train_dataset = l2l . data . MetaDataset ( train_dataset ) train_generator = l2l . data . TaskDataset ( dataset = train_dataset , num_tasks = 1000 )","title":"Quickdraw"},{"location":"docs/learn2learn.vision/#learn2learnvisiontransforms","text":"","title":"learn2learn.vision.transforms"},{"location":"docs/learn2learn.vision/#learn2learn.vision.transforms.RandomClassRotation","text":"[Source] Description Samples rotations from a given list uniformly at random, and applies it to all images from a given class. Arguments degrees (list) - The rotations to be sampled. Example 1 transform = RandomClassRotation ([ 0 , 90 , 180 , 270 ])","title":"RandomClassRotation"},{"location":"docs/learn2learn.vision/#learn2learnvisionbenchmarks","text":"","title":"learn2learn.vision.benchmarks"},{"location":"docs/learn2learn.vision/#learn2learn.vision.benchmarks.list_tasksets","text":"[Source] Description Returns a list of all available benchmarks. Example 1 2 3 for name in l2l . vision . benchmarks . list_tasksets (): print ( name ) tasksets = l2l . vision . benchmarks . get_tasksets ( name )","title":"list_tasksets()"},{"location":"docs/learn2learn.vision/#learn2learn.vision.benchmarks.get_tasksets","text":"[Source] Description Returns the tasksets for a particular benchmark, using literature standard data and task transformations. The returned object is a namedtuple with attributes train , validation , test which correspond to their respective TaskDatasets. See examples/vision/maml_miniimagenet.py for an example. Arguments name (str) - The name of the benchmark. Full list in list_tasksets() . train_ways (int, optional , default=5) - The number of classes per train tasks. train_samples (int, optional , default=10) - The number of samples per train tasks. test_ways (int, optional , default=5) - The number of classes per test tasks. Also used for validation tasks. test_samples (int, optional , default=10) - The number of samples per test tasks. Also used for validation tasks. num_tasks (int, optional , default=-1) - The number of tasks in each TaskDataset. device (torch.Device, optional , default=None) - If not None, tasksets are loaded as Tensors on device . root (str, optional , default='~/data') - Where the data is stored. Example 1 2 3 4 5 6 7 train_tasks , validation_tasks , test_tasks = l2l . vision . benchmarks . get_tasksets ( 'omniglot' ) batch = train_tasks . sample () or : tasksets = l2l . vision . benchmarks . get_tasksets ( 'omniglot' ) batch = tasksets . train . sample ()","title":"get_tasksets()"},{"location":"examples/","text":"","title":"Index"},{"location":"examples/optim/","text":"Meta-Optimization \u00b6 This directory contains examples of using learn2learn for meta-optimization or meta-descent. Hypergradient \u00b6 The script hypergrad_mnist.py demonstrates how to implement a slightly modified version of \" Online Learning Rate Adaptation with Hypergradient Descent \". The implementation departs from the algorithm presented in the paper in two ways. We forgo the analytical formulation of the learning rate's gradient to demonstrate the capability of the LearnableOptimizer class. We adapt per-parameter learning rates instead of updating a single learning rate shared by all parameters. Usage Warning The parameters for this script were not carefully tuned. Manually edit the script and run: 1 python examples/optimization/hypergrad_mnist.py","title":"Optimization"},{"location":"examples/optim/#meta-optimization","text":"This directory contains examples of using learn2learn for meta-optimization or meta-descent.","title":"Meta-Optimization"},{"location":"examples/optim/#hypergradient","text":"The script hypergrad_mnist.py demonstrates how to implement a slightly modified version of \" Online Learning Rate Adaptation with Hypergradient Descent \". The implementation departs from the algorithm presented in the paper in two ways. We forgo the analytical formulation of the learning rate's gradient to demonstrate the capability of the LearnableOptimizer class. We adapt per-parameter learning rates instead of updating a single learning rate shared by all parameters. Usage Warning The parameters for this script were not carefully tuned. Manually edit the script and run: 1 python examples/optimization/hypergrad_mnist.py","title":"Hypergradient"},{"location":"examples/rl/","text":"Meta-Reinforcement Learning \u00b6 Warning Meta-RL results are particularly finicky to compare. Different papers use different environment implementations, which in turn produce different convergence and rewards. The plots below only serve to indicate what kind of performance you can expect with learn2learn. MAML \u00b6 The above results are obtained by running maml_trpo.py on HalfCheetahForwardBackwardEnv and AntForwardBackwardEnv for 300 updates. The figures show the expected sum of rewards over all tasks. The line and shadow are the mean and standard deviation computed over 3 random seeds. Info Those results were obtained in August 2019, and might be outdated.","title":"Reinforcement Learning"},{"location":"examples/rl/#meta-reinforcement-learning","text":"Warning Meta-RL results are particularly finicky to compare. Different papers use different environment implementations, which in turn produce different convergence and rewards. The plots below only serve to indicate what kind of performance you can expect with learn2learn.","title":"Meta-Reinforcement Learning"},{"location":"examples/rl/#maml","text":"The above results are obtained by running maml_trpo.py on HalfCheetahForwardBackwardEnv and AntForwardBackwardEnv for 300 updates. The figures show the expected sum of rewards over all tasks. The line and shadow are the mean and standard deviation computed over 3 random seeds. Info Those results were obtained in August 2019, and might be outdated.","title":"MAML"},{"location":"examples/vision/","text":"Meta-Learning & Computer Vision \u00b6 This directory contains meta-learning examples and reproductions for common computer vision benchmarks. MAML \u00b6 The following files reproduce MAML on the Omniglot and mini -ImageNet datasets. The FOMAML results can be obtained by setting first_order=True in the MAML wrapper. On Omniglot, the CNN results can be obtained by swapping OmniglotFC with OmniglotCNN . maml_omniglot.py - MAML on the Omniglot dataset with a fully-connected network. maml_miniimagenet.py - MAML on the mini -ImageNet dataset with the standard convolutional network. Note that the original MAML paper trains with 5 fast adaptation step, but tests with 10 steps. This implementation only provides the training code. Results When adapting the code to different datasets, we obtained the following results. Only the fast-adaptation learning rate needs a bit of tuning, and good values usually lie in a 0.5-2x range of the original value. Dataset Architecture Ways Shots Original learn2learn Omniglot FC 5 1 89.7% 88.9% Omniglot CNN 5 1 98.7% 99.1% mini-ImageNet CNN 5 1 48.7% 48.3% mini-ImageNet CNN 5 5 63.1% 65.4% CIFAR-FS CNN 5 5 71.5% 73.6% FC100 CNN 5 5 n/a 49.0% Usage Manually edit the respective files and run: 1 python examples/vision/maml_omniglot.py or 1 python examples/vision/maml_miniimagenet.py Prototypical Networks \u00b6 The file protonet_miniimagenet.py reproduces Prototypical Networks on the mini -ImageNet dataset. This implementation provides training and testing code. Results Dataset Architecture Ways Shots Original learn2learn mini-ImageNet CNN 5 1 49.4% 49.1% mini-ImageNet CNN 5 5 68.2% 66.5% Usage For 1 shot 5 ways: 1 python examples/vision/protonet_miniimagenet.py For 5 shot 5 ways: 1 python examples/vision/protonet_miniimagenet.py --shot 5 --train-way 20 ANIL \u00b6 The file anil_fc100.py implements ANIL on the FC100 dataset. Results While ANIL only used mini -ImageNet as a benchmark, we provide results for CIFAR-FS and FC100 as well. Dataset Architecture Ways Shots Original learn2learn mini-ImageNet CNN 5 5 61.5% 63.2% CIFAR-FS CNN 5 5 n/a 68.3% FC100 CNN 5 5 n/a 47.6% Usage Manually edit the above file and run: 1 python examples/vision/anil_fc100.py Reptile \u00b6 The file reptile_miniimagenet.py reproduces Reptile on the mini -ImageNet dataset. Results The mini -ImageNet file can easily be adapted to obtain results on Omniglot and CIFAR-FS as well. Dataset Architecture Ways Shots Original learn2learn Omniglot CNN 5 5 99.5% 99.5% mini-ImageNet CNN 5 5 66.0% 65.5% CIFAR-FS CNN 10 3 n/a 46.3% Usage Manually edit the above file and run: 1 python examples/vision/reptile_miniimagenet.py Baseline \u00b6 The file supervised_pretraining.py reproduces the pretraining baseline of Dhillon et al. and extends to different architectures, datasets, and data augmentation. The pretrained weights can be downloaded using l2l.vision.models.get_pretrained_backbone() . Results The mini -ImageNet file can easily be adapted to obtain results on Omniglot and CIFAR-FS as well. Dataset Architecture Ways Shots Original learn2learn CIFAR-FS CNN4 5 5 n / a 73.13% FC100 CNN4 5 5 n / a 52.18% mini-ImageNet ResNet12 5 5 73.31% 77.38% tiered-ImageNet ResNet12 5 5 82.88% 83.80% Usage Manually edit the above file and run: 1 python examples/vision/supervised_pretraining.py Also see examples/vision/Makefile for reproducible commands.","title":"Computer Vision"},{"location":"examples/vision/#meta-learning-computer-vision","text":"This directory contains meta-learning examples and reproductions for common computer vision benchmarks.","title":"Meta-Learning &amp; Computer Vision"},{"location":"examples/vision/#maml","text":"The following files reproduce MAML on the Omniglot and mini -ImageNet datasets. The FOMAML results can be obtained by setting first_order=True in the MAML wrapper. On Omniglot, the CNN results can be obtained by swapping OmniglotFC with OmniglotCNN . maml_omniglot.py - MAML on the Omniglot dataset with a fully-connected network. maml_miniimagenet.py - MAML on the mini -ImageNet dataset with the standard convolutional network. Note that the original MAML paper trains with 5 fast adaptation step, but tests with 10 steps. This implementation only provides the training code. Results When adapting the code to different datasets, we obtained the following results. Only the fast-adaptation learning rate needs a bit of tuning, and good values usually lie in a 0.5-2x range of the original value. Dataset Architecture Ways Shots Original learn2learn Omniglot FC 5 1 89.7% 88.9% Omniglot CNN 5 1 98.7% 99.1% mini-ImageNet CNN 5 1 48.7% 48.3% mini-ImageNet CNN 5 5 63.1% 65.4% CIFAR-FS CNN 5 5 71.5% 73.6% FC100 CNN 5 5 n/a 49.0% Usage Manually edit the respective files and run: 1 python examples/vision/maml_omniglot.py or 1 python examples/vision/maml_miniimagenet.py","title":"MAML"},{"location":"examples/vision/#prototypical-networks","text":"The file protonet_miniimagenet.py reproduces Prototypical Networks on the mini -ImageNet dataset. This implementation provides training and testing code. Results Dataset Architecture Ways Shots Original learn2learn mini-ImageNet CNN 5 1 49.4% 49.1% mini-ImageNet CNN 5 5 68.2% 66.5% Usage For 1 shot 5 ways: 1 python examples/vision/protonet_miniimagenet.py For 5 shot 5 ways: 1 python examples/vision/protonet_miniimagenet.py --shot 5 --train-way 20","title":"Prototypical Networks"},{"location":"examples/vision/#anil","text":"The file anil_fc100.py implements ANIL on the FC100 dataset. Results While ANIL only used mini -ImageNet as a benchmark, we provide results for CIFAR-FS and FC100 as well. Dataset Architecture Ways Shots Original learn2learn mini-ImageNet CNN 5 5 61.5% 63.2% CIFAR-FS CNN 5 5 n/a 68.3% FC100 CNN 5 5 n/a 47.6% Usage Manually edit the above file and run: 1 python examples/vision/anil_fc100.py","title":"ANIL"},{"location":"examples/vision/#reptile","text":"The file reptile_miniimagenet.py reproduces Reptile on the mini -ImageNet dataset. Results The mini -ImageNet file can easily be adapted to obtain results on Omniglot and CIFAR-FS as well. Dataset Architecture Ways Shots Original learn2learn Omniglot CNN 5 5 99.5% 99.5% mini-ImageNet CNN 5 5 66.0% 65.5% CIFAR-FS CNN 10 3 n/a 46.3% Usage Manually edit the above file and run: 1 python examples/vision/reptile_miniimagenet.py","title":"Reptile"},{"location":"examples/vision/#baseline","text":"The file supervised_pretraining.py reproduces the pretraining baseline of Dhillon et al. and extends to different architectures, datasets, and data augmentation. The pretrained weights can be downloaded using l2l.vision.models.get_pretrained_backbone() . Results The mini -ImageNet file can easily be adapted to obtain results on Omniglot and CIFAR-FS as well. Dataset Architecture Ways Shots Original learn2learn CIFAR-FS CNN4 5 5 n / a 73.13% FC100 CNN4 5 5 n / a 52.18% mini-ImageNet ResNet12 5 5 73.31% 77.38% tiered-ImageNet ResNet12 5 5 82.88% 83.80% Usage Manually edit the above file and run: 1 python examples/vision/supervised_pretraining.py Also see examples/vision/Makefile for reproducible commands.","title":"Baseline"},{"location":"tutorials/getting_started/","text":"Getting Started \u00b6 learn2learn is a meta-learning library providing three levels of functionality for users. At a high level, there are many examples using meta-learning algorithms to train on a myriad of datasets/environments. At a mid level, it provides a functional interface for several popular meta-learning algorithms as well as a data loader to make it easier to import other data sets. At a low level, it provides extended functionality for modules. Installing \u00b6 A pip package is available, updated periodically. Use the command: pip install -U learn2learn For the most update-to-date version clone the repository and use: pip install -e . When installing from sources, make sure that Cython is installed: pip install cython . Info While learn2learn is actively used in current research projects, it is still in development. Breaking changes might occur. Development \u00b6 To simplify the development process, the following commands can be executed from the cloned sources: make build - Builds learn2learn in place. make clean - Cleans previous installation. make lint - Runs linting on the codebase. make lint-examples - Runs linting on the examples. make tests - Runs a light testing suite. (i.e. the Travis one) make alltests - Runs an extensive testing suite. (much longer) make docs - Builds the documentation and serves the website locally. Tip If you encounter a problem, feel free to an open an issue and we'll look into it.","title":"Getting Started"},{"location":"tutorials/getting_started/#getting-started","text":"learn2learn is a meta-learning library providing three levels of functionality for users. At a high level, there are many examples using meta-learning algorithms to train on a myriad of datasets/environments. At a mid level, it provides a functional interface for several popular meta-learning algorithms as well as a data loader to make it easier to import other data sets. At a low level, it provides extended functionality for modules.","title":"Getting Started"},{"location":"tutorials/getting_started/#installing","text":"A pip package is available, updated periodically. Use the command: pip install -U learn2learn For the most update-to-date version clone the repository and use: pip install -e . When installing from sources, make sure that Cython is installed: pip install cython . Info While learn2learn is actively used in current research projects, it is still in development. Breaking changes might occur.","title":"Installing"},{"location":"tutorials/getting_started/#development","text":"To simplify the development process, the following commands can be executed from the cloned sources: make build - Builds learn2learn in place. make clean - Cleans previous installation. make lint - Runs linting on the codebase. make lint-examples - Runs linting on the examples. make tests - Runs a light testing suite. (i.e. the Travis one) make alltests - Runs an extensive testing suite. (much longer) make docs - Builds the documentation and serves the website locally. Tip If you encounter a problem, feel free to an open an issue and we'll look into it.","title":"Development"},{"location":"tutorials/anil_tutorial/ANIL_tutorial/","text":"Feature Reuse with ANIL \u00b6 Written by Ewina Pun on 3/30/2020. In this article, we will dive into a meta-learning algorithm called ANIL (Almost No Inner Loop) presented by Raghu et al., 2019 , and explain how to implement it with learn2learn. Note This tutorial is written for experienced PyTorch users who are getting started with meta-learning. Overview \u00b6 We look into how ANIL takes advantage of feature reuse for few-shot learning. ANIL simplifies MAML by removing the inner loop for all but the task-specific head of the underlying neural network. ANIL performs as well as MAML on benchmark few-shot classification and reinforcement learning tasks, and is computationally more efficient than MAML. We implement ANIL with learn2learn and provide additional results of how ANIL performs on other datasets. Lastly, we explain the implementation code step-be-step, making it easy for users to try ANIL on other datasets. ANIL algorithm \u00b6 Among various meta-learning algorithms for few-shot learning, MAML (model-agnostic meta-learning) (Finn et al. 2017) has been highly popular due to its substantial performance on several benchmarks. Its idea is to establish a meta-learner that seeks an initialization useful for fast learning of different tasks, then adapt to specific tasks quickly (within a few steps) and efficiently (with only a few examples). There are two types of parameter updates: the outer loop and the inner loop. The outer loop updates the meta-initialization of the neural network parameters to a setting that enables fast adaptation to new tasks. The inner loop takes the outer loop initialization and performs task-specific adaptation over a few labeled samples. To read more about meta-learning and MAML, you can read the summary article written by Finn on learning to learn and Lilian Weng's review on meta-learning . In 2019, Raghu et al. conjectured that we can obtain the same rapid learning performance of MAML solely through feature reuse. To test this hypothesis, they introduced ANIL (almost no inner loop), a simplified algorithm of MAML that is equally effective but computationally faster. Rapid learning vs. feature reuse Visualizations of rapid learning and feature reuse. Diagram from Raghu et al., 2019. Before we describe ANIL, we have to understand the difference between rapid learning and feature reuse. In rapid learning , the meta-initialization in the outer loop results in a parameter setting that is favorable for fast learning, thus significant adaptation to new tasks can rapidly take place in the inner loop. In feature reuse , the meta-initialization already contains useful features that can be reused, so little adaptation on the parameters is required in the inner loop. To prove feature reuse is a competitive alternative to rapid learning in MAML, the authors proposed a simplified algorithm, ANIL, where the inner loop is removed for all but the task-specific head of the underlying neural network during training and testing. ANIL vs. MAML Now, let us illustrate the difference mathematically. Let \\theta be the set of meta-initialization parameters for the feature extractable layers of the network and w be the meta-initialization parameters for the head. We obtain the label prediction \\hat{y} = w^T\\phi_\\theta(x) , where x is the input data and \\phi is a feature extractor parametrized by \\theta . Given \\theta_i and w_i at iteration step i , the outer loop updates both parameters via gradient descent: \\theta_{i+1} = \\theta_i - \\alpha\\nabla_{\\theta_i}\\mathcal{L}_{\\tau}(w^{\\prime \\top}_i\\phi_{\\theta^\\prime_i}(x), y) w_{i+1} = w_i - \\alpha\\nabla_{w_i}\\mathcal{L}_{\\tau}(w^{\\prime \\top}_i\\phi_{\\theta^\\prime_i}(x), y) where \\mathcal{L}_\\tau is the loss computed for task \\tau , and \\alpha is the meta learning rate in the outer loop. Notice how the gradient is taken with respect to the initialization parameters w_i and \\theta_i , but the loss is computed on the adapted parameters \\theta_i^\\prime and w_i^\\prime . For one adaptation step in the inner loop, ANIL computes those adapted parameters as: \\theta_{i}^\\prime = \\theta_i w_{i}^\\prime = w_i - \\beta\\nabla_{w_i}\\mathcal{L}_{\\tau}(w_i^T\\phi_{\\theta_i}(x), y) where \\beta is the learning rate of the inner loop. Concretely, ANIL keeps the feature extractor constant and only adapts the head with gradient descent. In contrast, MAML updates both the head and the feature extractor: \\theta_{i}^\\prime = \\theta_i - \\beta\\nabla_{\\theta_i}\\mathcal{L}_{\\tau}(w_i^T\\phi_{\\theta_i}(x), y) w_{i}^\\prime = w_i - \\beta\\nabla_{w_i}\\mathcal{L}_{\\tau}(w_i^T\\phi_{\\theta_i}(x), y). Unsurprisingly, ANIL is much more computationally efficient since it requires fewer updates in the inner loop. What might be surprising, is that this efficiency comes at almost no cost in terms of performance. Results ANIL provides fast adaptation in the absence of almost all inner loop parameter updates, while still matching the performance of MAML on few-shot image classification with Mini-ImageNet and Omniglot and standard reinforcement learning tasks. Method Omniglot-20way-1shot Omniglot-20way-5shot Mini-ImageNet-5way-1shot Mini-ImageNet-5way-5shot MAML 93.7 \u00b1 0.7 96.4 \u00b1 0.1 46.9 \u00b1 0.2 63.1 \u00b1 0.4 ANIL 96.2 \u00b1 0.5 98.0 \u00b1 0.3 46.7 \u00b1 0.4 61.5 \u00b1 0.5 Using ANIL with learn2learn \u00b6 With our understanding of how ANIL works, we are ready to implement the algorithm. An example implementation on the FC100 dataset is available at: anil_fc100.py . Using this implementation, we are able to obtain the following results on datasets such as Mini-ImageNet, CIFAR-FS and FC100 as well. Dataset Architecture Ways Shots Original learn2learn Mini-ImageNet CNN 5 5 61.5% 63.2% CIFAR-FS CNN 5 5 n/a 68.3% FC100 CNN 5 5 n/a 47.6% ANIL Implementation \u00b6 This section breaks down step-by-step the ANIL implementation with our example code. Creating dataset 1 2 3 4 train_dataset = l2l . vision . datasets . FC100 ( root = '~/data' , transform = tv . transforms . ToTensor (), mode = 'train' ) train_dataset = l2l . data . MetaDataset ( train_dataset ) First, data are obtained and separated into train, validation and test dataset with l2l.vision.datasets.FC100 . tv.transforms.ToTensor() converts Python Imaging Library (PIL) images to PyTorch tensors. l2l.data.MetaDataset is a thin wrapper around torch datasets that automatically generates bookkeeping information to create new tasks. 1 2 3 4 5 6 7 8 9 train_transforms = [ FusedNWaysKShots ( train_dataset , n = ways , k = 2 * shots ), LoadData ( train_dataset ), RemapLabels ( train_dataset ), ConsecutiveLabels ( train_dataset ), ] train_tasks = l2l . data . TaskDataset ( train_dataset , task_transforms = train_transforms , num_tasks = 20000 ) l2l.data.TaskDataset creates a set of tasks from the MetaDataset using a list of task transformations: FusedNWaysKShots(dataset, n=ways, k=2*shots) : efficient implementation to keep k data samples from n randomly sampled labels. LoadData(dataset) : loads a sample from the dataset given its index. RemapLabels(dataset) : given samples from n classes, maps the labels to 0, \\dots, n . ConsecutiveLabels(dataset) : re-orders the samples in the task description such that they are sorted in consecutive order. Question Why k = 2*shots ? The number of samples k is twice the number of shots because one half of the samples are for adaption and the other half are for evaluation in the inner loop. Info For more details, please refer to the documentation of learn2learn.data . Creating model 1 2 3 4 5 6 features = l2l . vision . models . ConvBase ( output_size = 64 , channels = 3 , max_pool = True ) features = torch . nn . Sequential ( features , Lambda ( lambda x : x . view ( - 1 , 256 ))) features . to ( device ) head = torch . nn . Linear ( 256 , ways ) head = l2l . algorithms . MAML ( head , lr = fast_lr ) head . to ( device ) We then instantiate two modules, one for features and one for the head. ConvBase instantiates a four-layer CNN, and the head is a fully connected layer. Because we are not updating the feature extractor parameters, we only need to wrap the head with the l2l.algorithms.MAML() wrapper, which takes in the fast adaptation learning rate fast_lr used for the inner loop later. Info For more details on the MAML wrapper, please refer to the documentation of l2l.algorithms . Optimization setup 1 2 3 all_parameters = list ( features . parameters ()) + list ( head . parameters ()) optimizer = torch . optim . Adam ( all_parameters , lr = meta_lr ) loss = nn . CrossEntropyLoss ( reduction = 'mean' ) Next, we set up the optimizer with mini-batch SGD using torch.optim.Adam , which takes in both feature and head parameters, and learning rate meta_lr used for the outer loop. Outer loop 1 2 3 4 5 6 for iteration in range ( iters ): ... for task in range ( meta_bsz ): learner = head . clone () batch = train_tasks . sample () ... For training, validation and testing, we first sample a task, then copy the head with head.clone() , which is a method exposed by the MAML wrapper for PyTorch modules, akin to tensor.clone() for PyTorch tensors. Calling clone() allows us to update the parameters of the clone while maintaining ability to back-propagate to the parameters in head . There's no need for feature.clone() as we are only adapting the head. Inner loop 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def fast_adapt ( batch , learner , features , loss , adaptation_steps , shots , ways , device = None ): data , labels = batch data , labels = data . to ( device ), labels . to ( device ) data = features ( data ) # Separate data into adaptation/evaluation sets adaptation_indices = np . zeros ( data . size ( 0 ), dtype = bool ) adaptation_indices [ np . arange ( shots * ways ) * 2 ] = True evaluation_indices = torch . from_numpy ( ~ adaptation_indices ) adaptation_indices = torch . from_numpy ( adaptation_indices ) adaptation_data , adaptation_labels = data [ adaptation_indices ], labels [ adaptation_indices ] evaluation_data , evaluation_labels = data [ evaluation_indices ], labels [ evaluation_indices ] for step in range ( adaptation_steps ): train_error = loss ( learner ( adaptation_data ), adaptation_labels ) learner . adapt ( train_error ) predictions = learner ( evaluation_data ) valid_error = loss ( predictions , evaluation_labels ) valid_accuracy = accuracy ( predictions , evaluation_labels ) return valid_error , valid_accuracy In fast_adapt() , we separate data into adaptation and evaluation sets with k shot samples each. In each adaptation step, learner.adapt() takes a gradient step on the loss and updates the cloned parameter, learner , such that we can back-propagate through the adaptation step. Under the hood, this is achieved by calling torch.autograd.grad() and setting create_graph=True . fast_adapt() then returns the evaluation loss and accuracy based on the predicted and true labels. Question Why is the number of adaptation steps so small? To demonstrate fast adaptation, we want the algorithm to adapt to each specific task quickly within a few steps. Since the number of samples is so small in few-shot learning, increasing number of adaptation steps would not help raising the performance. Closing the outer loop 1 2 3 4 5 6 7 8 evaluation_error . backward () meta_train_error += evaluation_error . item () meta_train_accuracy += evaluation_accuracy . item () ... # Average the accumulated gradients and optimize for p in all_parameters : p . grad . data . mul_ ( 1.0 / meta_bsz ) optimizer . step () We compute the gradients with evaluation_error.backward() right after the inner loop updates to free activation and adaptation buffers from memory as early as possible. Lastly, after collecting the gradients, we average the accumulated gradients and updates the parameter at the end of each iteration with optimizer.step() . Conclusion \u00b6 Having explained the inner-workings of ANIL and its code implementation with learn2learn, I hope this tutorial will be helpful to those who are interested in using ANIL for their own research and applications. References \u00b6 Raghu, A., Raghu, M., Bengio, S., & Vinyals, O. (2019). Rapid Learning or Feature Reuse? Towards Understanding the Effectiveness of MAML. In arXiv [cs.LG]. arXiv. http://arxiv.org/abs/1909.09157 Finn, C., Abbeel, P., & Levine, S. (2017). Model-Agnostic Meta-Learning for Fast Adaptation of Deep Networks. In arXiv [cs.LG]. arXiv. http://arxiv.org/abs/1703.03400","title":"Feature Reuse with ANIL"},{"location":"tutorials/anil_tutorial/ANIL_tutorial/#feature-reuse-with-anil","text":"Written by Ewina Pun on 3/30/2020. In this article, we will dive into a meta-learning algorithm called ANIL (Almost No Inner Loop) presented by Raghu et al., 2019 , and explain how to implement it with learn2learn. Note This tutorial is written for experienced PyTorch users who are getting started with meta-learning.","title":"Feature Reuse with ANIL"},{"location":"tutorials/anil_tutorial/ANIL_tutorial/#overview","text":"We look into how ANIL takes advantage of feature reuse for few-shot learning. ANIL simplifies MAML by removing the inner loop for all but the task-specific head of the underlying neural network. ANIL performs as well as MAML on benchmark few-shot classification and reinforcement learning tasks, and is computationally more efficient than MAML. We implement ANIL with learn2learn and provide additional results of how ANIL performs on other datasets. Lastly, we explain the implementation code step-be-step, making it easy for users to try ANIL on other datasets.","title":"Overview"},{"location":"tutorials/anil_tutorial/ANIL_tutorial/#anil-algorithm","text":"Among various meta-learning algorithms for few-shot learning, MAML (model-agnostic meta-learning) (Finn et al. 2017) has been highly popular due to its substantial performance on several benchmarks. Its idea is to establish a meta-learner that seeks an initialization useful for fast learning of different tasks, then adapt to specific tasks quickly (within a few steps) and efficiently (with only a few examples). There are two types of parameter updates: the outer loop and the inner loop. The outer loop updates the meta-initialization of the neural network parameters to a setting that enables fast adaptation to new tasks. The inner loop takes the outer loop initialization and performs task-specific adaptation over a few labeled samples. To read more about meta-learning and MAML, you can read the summary article written by Finn on learning to learn and Lilian Weng's review on meta-learning . In 2019, Raghu et al. conjectured that we can obtain the same rapid learning performance of MAML solely through feature reuse. To test this hypothesis, they introduced ANIL (almost no inner loop), a simplified algorithm of MAML that is equally effective but computationally faster. Rapid learning vs. feature reuse Visualizations of rapid learning and feature reuse. Diagram from Raghu et al., 2019. Before we describe ANIL, we have to understand the difference between rapid learning and feature reuse. In rapid learning , the meta-initialization in the outer loop results in a parameter setting that is favorable for fast learning, thus significant adaptation to new tasks can rapidly take place in the inner loop. In feature reuse , the meta-initialization already contains useful features that can be reused, so little adaptation on the parameters is required in the inner loop. To prove feature reuse is a competitive alternative to rapid learning in MAML, the authors proposed a simplified algorithm, ANIL, where the inner loop is removed for all but the task-specific head of the underlying neural network during training and testing. ANIL vs. MAML Now, let us illustrate the difference mathematically. Let \\theta be the set of meta-initialization parameters for the feature extractable layers of the network and w be the meta-initialization parameters for the head. We obtain the label prediction \\hat{y} = w^T\\phi_\\theta(x) , where x is the input data and \\phi is a feature extractor parametrized by \\theta . Given \\theta_i and w_i at iteration step i , the outer loop updates both parameters via gradient descent: \\theta_{i+1} = \\theta_i - \\alpha\\nabla_{\\theta_i}\\mathcal{L}_{\\tau}(w^{\\prime \\top}_i\\phi_{\\theta^\\prime_i}(x), y) w_{i+1} = w_i - \\alpha\\nabla_{w_i}\\mathcal{L}_{\\tau}(w^{\\prime \\top}_i\\phi_{\\theta^\\prime_i}(x), y) where \\mathcal{L}_\\tau is the loss computed for task \\tau , and \\alpha is the meta learning rate in the outer loop. Notice how the gradient is taken with respect to the initialization parameters w_i and \\theta_i , but the loss is computed on the adapted parameters \\theta_i^\\prime and w_i^\\prime . For one adaptation step in the inner loop, ANIL computes those adapted parameters as: \\theta_{i}^\\prime = \\theta_i w_{i}^\\prime = w_i - \\beta\\nabla_{w_i}\\mathcal{L}_{\\tau}(w_i^T\\phi_{\\theta_i}(x), y) where \\beta is the learning rate of the inner loop. Concretely, ANIL keeps the feature extractor constant and only adapts the head with gradient descent. In contrast, MAML updates both the head and the feature extractor: \\theta_{i}^\\prime = \\theta_i - \\beta\\nabla_{\\theta_i}\\mathcal{L}_{\\tau}(w_i^T\\phi_{\\theta_i}(x), y) w_{i}^\\prime = w_i - \\beta\\nabla_{w_i}\\mathcal{L}_{\\tau}(w_i^T\\phi_{\\theta_i}(x), y). Unsurprisingly, ANIL is much more computationally efficient since it requires fewer updates in the inner loop. What might be surprising, is that this efficiency comes at almost no cost in terms of performance. Results ANIL provides fast adaptation in the absence of almost all inner loop parameter updates, while still matching the performance of MAML on few-shot image classification with Mini-ImageNet and Omniglot and standard reinforcement learning tasks. Method Omniglot-20way-1shot Omniglot-20way-5shot Mini-ImageNet-5way-1shot Mini-ImageNet-5way-5shot MAML 93.7 \u00b1 0.7 96.4 \u00b1 0.1 46.9 \u00b1 0.2 63.1 \u00b1 0.4 ANIL 96.2 \u00b1 0.5 98.0 \u00b1 0.3 46.7 \u00b1 0.4 61.5 \u00b1 0.5","title":"ANIL algorithm"},{"location":"tutorials/anil_tutorial/ANIL_tutorial/#using-anil-with-learn2learn","text":"With our understanding of how ANIL works, we are ready to implement the algorithm. An example implementation on the FC100 dataset is available at: anil_fc100.py . Using this implementation, we are able to obtain the following results on datasets such as Mini-ImageNet, CIFAR-FS and FC100 as well. Dataset Architecture Ways Shots Original learn2learn Mini-ImageNet CNN 5 5 61.5% 63.2% CIFAR-FS CNN 5 5 n/a 68.3% FC100 CNN 5 5 n/a 47.6%","title":"Using ANIL with learn2learn"},{"location":"tutorials/anil_tutorial/ANIL_tutorial/#anil-implementation","text":"This section breaks down step-by-step the ANIL implementation with our example code. Creating dataset 1 2 3 4 train_dataset = l2l . vision . datasets . FC100 ( root = '~/data' , transform = tv . transforms . ToTensor (), mode = 'train' ) train_dataset = l2l . data . MetaDataset ( train_dataset ) First, data are obtained and separated into train, validation and test dataset with l2l.vision.datasets.FC100 . tv.transforms.ToTensor() converts Python Imaging Library (PIL) images to PyTorch tensors. l2l.data.MetaDataset is a thin wrapper around torch datasets that automatically generates bookkeeping information to create new tasks. 1 2 3 4 5 6 7 8 9 train_transforms = [ FusedNWaysKShots ( train_dataset , n = ways , k = 2 * shots ), LoadData ( train_dataset ), RemapLabels ( train_dataset ), ConsecutiveLabels ( train_dataset ), ] train_tasks = l2l . data . TaskDataset ( train_dataset , task_transforms = train_transforms , num_tasks = 20000 ) l2l.data.TaskDataset creates a set of tasks from the MetaDataset using a list of task transformations: FusedNWaysKShots(dataset, n=ways, k=2*shots) : efficient implementation to keep k data samples from n randomly sampled labels. LoadData(dataset) : loads a sample from the dataset given its index. RemapLabels(dataset) : given samples from n classes, maps the labels to 0, \\dots, n . ConsecutiveLabels(dataset) : re-orders the samples in the task description such that they are sorted in consecutive order. Question Why k = 2*shots ? The number of samples k is twice the number of shots because one half of the samples are for adaption and the other half are for evaluation in the inner loop. Info For more details, please refer to the documentation of learn2learn.data . Creating model 1 2 3 4 5 6 features = l2l . vision . models . ConvBase ( output_size = 64 , channels = 3 , max_pool = True ) features = torch . nn . Sequential ( features , Lambda ( lambda x : x . view ( - 1 , 256 ))) features . to ( device ) head = torch . nn . Linear ( 256 , ways ) head = l2l . algorithms . MAML ( head , lr = fast_lr ) head . to ( device ) We then instantiate two modules, one for features and one for the head. ConvBase instantiates a four-layer CNN, and the head is a fully connected layer. Because we are not updating the feature extractor parameters, we only need to wrap the head with the l2l.algorithms.MAML() wrapper, which takes in the fast adaptation learning rate fast_lr used for the inner loop later. Info For more details on the MAML wrapper, please refer to the documentation of l2l.algorithms . Optimization setup 1 2 3 all_parameters = list ( features . parameters ()) + list ( head . parameters ()) optimizer = torch . optim . Adam ( all_parameters , lr = meta_lr ) loss = nn . CrossEntropyLoss ( reduction = 'mean' ) Next, we set up the optimizer with mini-batch SGD using torch.optim.Adam , which takes in both feature and head parameters, and learning rate meta_lr used for the outer loop. Outer loop 1 2 3 4 5 6 for iteration in range ( iters ): ... for task in range ( meta_bsz ): learner = head . clone () batch = train_tasks . sample () ... For training, validation and testing, we first sample a task, then copy the head with head.clone() , which is a method exposed by the MAML wrapper for PyTorch modules, akin to tensor.clone() for PyTorch tensors. Calling clone() allows us to update the parameters of the clone while maintaining ability to back-propagate to the parameters in head . There's no need for feature.clone() as we are only adapting the head. Inner loop 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def fast_adapt ( batch , learner , features , loss , adaptation_steps , shots , ways , device = None ): data , labels = batch data , labels = data . to ( device ), labels . to ( device ) data = features ( data ) # Separate data into adaptation/evaluation sets adaptation_indices = np . zeros ( data . size ( 0 ), dtype = bool ) adaptation_indices [ np . arange ( shots * ways ) * 2 ] = True evaluation_indices = torch . from_numpy ( ~ adaptation_indices ) adaptation_indices = torch . from_numpy ( adaptation_indices ) adaptation_data , adaptation_labels = data [ adaptation_indices ], labels [ adaptation_indices ] evaluation_data , evaluation_labels = data [ evaluation_indices ], labels [ evaluation_indices ] for step in range ( adaptation_steps ): train_error = loss ( learner ( adaptation_data ), adaptation_labels ) learner . adapt ( train_error ) predictions = learner ( evaluation_data ) valid_error = loss ( predictions , evaluation_labels ) valid_accuracy = accuracy ( predictions , evaluation_labels ) return valid_error , valid_accuracy In fast_adapt() , we separate data into adaptation and evaluation sets with k shot samples each. In each adaptation step, learner.adapt() takes a gradient step on the loss and updates the cloned parameter, learner , such that we can back-propagate through the adaptation step. Under the hood, this is achieved by calling torch.autograd.grad() and setting create_graph=True . fast_adapt() then returns the evaluation loss and accuracy based on the predicted and true labels. Question Why is the number of adaptation steps so small? To demonstrate fast adaptation, we want the algorithm to adapt to each specific task quickly within a few steps. Since the number of samples is so small in few-shot learning, increasing number of adaptation steps would not help raising the performance. Closing the outer loop 1 2 3 4 5 6 7 8 evaluation_error . backward () meta_train_error += evaluation_error . item () meta_train_accuracy += evaluation_accuracy . item () ... # Average the accumulated gradients and optimize for p in all_parameters : p . grad . data . mul_ ( 1.0 / meta_bsz ) optimizer . step () We compute the gradients with evaluation_error.backward() right after the inner loop updates to free activation and adaptation buffers from memory as early as possible. Lastly, after collecting the gradients, we average the accumulated gradients and updates the parameter at the end of each iteration with optimizer.step() .","title":"ANIL Implementation"},{"location":"tutorials/anil_tutorial/ANIL_tutorial/#conclusion","text":"Having explained the inner-workings of ANIL and its code implementation with learn2learn, I hope this tutorial will be helpful to those who are interested in using ANIL for their own research and applications.","title":"Conclusion"},{"location":"tutorials/anil_tutorial/ANIL_tutorial/#references","text":"Raghu, A., Raghu, M., Bengio, S., & Vinyals, O. (2019). Rapid Learning or Feature Reuse? Towards Understanding the Effectiveness of MAML. In arXiv [cs.LG]. arXiv. http://arxiv.org/abs/1909.09157 Finn, C., Abbeel, P., & Levine, S. (2017). Model-Agnostic Meta-Learning for Fast Adaptation of Deep Networks. In arXiv [cs.LG]. arXiv. http://arxiv.org/abs/1703.03400","title":"References"},{"location":"tutorials/task_transform_tutorial/transform_tutorial/","text":"Demystifying Task-Transforms \u00b6 Written by Varad Pimpalkhute on 02/18/2022. Notebook of this tutorial is available on Colab Notebook . In this tutorial, we will explore in depth one of the core utilities learn2learn library provides - Task Generators. Overview \u00b6 We will first discuss the motivation behind generating tasks. (Those familiar with meta-learning can skip this section.) Next, we will have a high-level overview of the overall pipeline used for generating tasks using learn2learn . MetaDataset is used fast indexing, and accelerates the process of generating few-shot learning tasks. UnionMetaDataset and FilteredMetaDataset are extensions of MetaDataset that can further provide customised utility. UnionMetaDataset builds up on MetaDataset to construct a union of multiple input datasets, and FilteredMetaDataset takes in a MetaDataset and filters it to include only the required labels. TaskDataset is the core module that generates tasks from input dataset. Tasks are lazily sampled upon indexing or calling .sample() method. Lastly, we study different task transforms defined in learn2learn that modifies the input data such that a customised task is generated. Motivation for generating tasks \u00b6 What is a task? \u00b6 Let's first start with understanding what is a task. The definition of a task varies from one application to other, but in context of few-shot learning, a task is a supervised-learning approach (e.g., classification, regression) trained over a collection of datapoints (images, in context of vision) that are sampled from the same distribution. For example , a task may consist of 5 images from 5 different classes - flower, cup, bird, fruit, clock (say, 1 image per class), all sampled from the same distribution. Now, the objective of the task might be to classify the images present at test time amongst the five classes - that is, minimize over the loss function. Few-Shot Classification Tasks. Image source: Cloudera Fast Forward Report on Meta-Learning . How is a task used in context of meta-learning? \u00b6 Meta-learning used in the context of few-shot learning paradigm trains over different tasks (each task consists of limited number of samples) over multiple iterations of training. For example, gradient-based meta-learners learn a model initialization prior such that the model converges to the global minima on unseen tasks (tasks that were not encountered during training) using few samples/datapoints. How is a task generated? \u00b6 In layman's terms, few-shot classification experiment is set up as a N-wayed K-shot problem. Meaning, the model needs to learn how to classify an input task over N different classes given K examples per class during training. Thus, we need to generate 'M' such tasks for training, and inferencing the meta-learner. Summarizing , we require to: Iterate over classes and their respective samples present in the dataset rapidly in order to generate a task. Write a protocol that generates a task that adhers to the few-shot paradigm (that is, N-way K-shot problem) . Incorporate additional transforms (say, augmentation of data) . Generate M randomly sampled tasks for training and inferencing. Given any input dataset, learn2learn makes it easy for generating custom tasks depending on the user's usecase. 1 2 3 4 5 6 7 8 # Import modules that would be used later. import os , random , pickle , itertools , copy import learn2learn as l2l import torchvision as tv from PIL.Image import LANCZOS from learn2learn.data.transforms import NWays , KShots , LoadData , RemapLabels , ConsecutiveLabels from learn2learn.vision.transforms import RandomClassRotation from collections import defaultdict Overview of pipeline for generating tasks \u00b6 Given any input dataset, learn2learn makes it easy for generating custom tasks depending on the user's usecase. A high-level overall pipeline is shown in the diagram below: The dataset consists of 100 different classes, having 5 samples per class. The objective is to generate N-wayed K-shot task (say, 3-way 2-shot task from the given dataset.) Pipeline for generating tasks in learn2learn. The below code snippet shows to generate customised tasks using any input custom using learn2learn . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 # 1. Apply transforms on input data if any (eg., Resizing, converting arrays to tensors) data_transform = tv . transforms . Compose ([ tv . transforms . Resize (( 28 , 28 ), interpolation = LANCZOS ), tv . transforms . ToTensor ()]) # 2. Download the dataset, and apply the above transforms on each of the samples dataset = l2l . vision . datasets . FullOmniglot ( root = '~\\data' , transform = data_transform , download = True ) # Load your custom dataset # 3. Wrap the dataset using MetaDataset to enable fast indexing omniglot = l2l . data . MetaDataset ( dataset ) # Use MetaDataset to do fast indexing of samples # 4. Specify transforms to be used for generating tasks transforms = [ NWays ( omniglot , 5 ), # Samples N random classes per task (here, N = 5) KShots ( omniglot , 1 ), # Samples K samples per class from the above N classes (here, K = 1) LoadData ( omniglot ), # Loads a sample from the dataset RemapLabels ( omniglot ), # Remaps labels starting from zero ConsecutiveLabels ( omniglot ), # Re-orders samples s.t. they are sorted in consecutive order RandomClassRotation ( omniglot , [ 0 , 90 , 180 , 270 ]) # Randomly rotate sample over x degrees (only for vision tasks) ] # 5. Generate set of tasks using the dataset, and transforms taskset = l2l . data . TaskDataset ( dataset = omniglot , task_transforms = transforms , num_tasks = 10 ) # Creates sets of tasks from the dataset # Now sample a task from the taskset X , y = taskset . sample () # or, you can also sample this way: for task in taskset : X , y = task print ( X . shape ) (out): torch.Size([5, 1, 28, 28]) And that's it! You have now generated one task randomly sampled from the omniglot dataset distribution. For generating M tasks, you will need to sample the taskset M times. For the rest of the tutorial, we will inspect each of the modules present in the above code, and discuss a few general strategies that can be used while generating tasks efficiently. MetaDataset - A wrapper for fast indexing of samples. \u00b6 At a high level, MetaDataset is a wrapper that enables fast indexing of samples of a given class in a dataset. The motivation behind building is to decrease the \\mathcal{O}(n) time to \\mathcal{O}(1) everytime we iterate over a dataset to generate tasks. Naturally, the time saved increases as the dataset size keeps on increasing. Note : The input dataset needs to be iterable. learn2learn does this by maintaining two dictionaries for each classification dataset: 1. labels_to_indices : A dictionary that maintains labels of classes as keys, and the corresponding indices of samples within the class in form of list as values. 2. indices_to_labels : As the name suggests, a dictionary is formed with indices of samples as key, and their corresponding class labels as value. This feature comes in handy while generating tasks. For example, if you are sampling a task having N classes (say, N=5) , then using labels_to_indices dictionary to identify all the samples belonging to this set of 5 classes ( \\mathcal{O}(c) ) will be much more faster than iterating all the samples ( \\mathcal{O}(n) ) . 1 2 3 4 5 6 7 8 9 10 11 12 13 from collections import defaultdict labels_to_indices = defaultdict ( list ) # each label will store list of sample indices indices_to_labels = defaultdict ( int ) # each index will store corresponding sample's label for i in range ( len ( dataset )): # iterate over all samples label = dataset [ i ][ 1 ] # load label if hasattr ( label , 'item' ): label = dataset [ i ][ 1 ] . item () # if label is a Tensor, then take get the scalar value labels_to_indices [ label ] . append ( i ) # append sample's index to the given class indices_to_labels [ i ] = label # assign label to the given index Any one of the two dictionaries can also be optionally passed as an argument upon instantiation, and the other dictionary is built using this dictionary (See Line 81 - Line 90 on GitHub.) Bookkeeping \u00b6 learn2learn also provides another utility in the form of an attribute _bookkeeping_path . If the input dataset has the given attribute, then the built attributes (namely, the two dictionaries, and list of labels) will be cached on disk for latter use. It is recommended to use this utility if: If the dataset size is large, as it can take hours for instantiating it the first time. If you are going to use the dataset again for training. (Iterating over all the samples will be much slower than loading it from disk) To use the bookkeeping utility, while loading your custom dataset, you will need to add an additional attribute to it. For example, we add _bookkeeping_path attribute while generating FC100 dataset as follows: self._bookkeeping_path = os.path.join(self.root, 'fc100-bookkeeping-' + mode + '.pkl') where, mode is either train, validation, or test (depends on how you are defining your dataset. It's also possible that you are loading the entire dataset, and then creating train-valid-test splits. In that case, you can remove the mode variable) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import pickle # The variables can be loaded from the saved .pkl file with open ( '~\\data/omniglot-bookkeeping.pkl' , 'rb' ) as f : _bookkeeping = pickle . load ( f ) # In _bookkeeping, the three attributes are saved in the form of a dictionary labels_to_indices = _bookkeeping [ 'labels_to_indices' ] indices_to_labels = _bookkeeping [ 'indices_to_labels' ] labels = _bookkeeping [ 'labels' ] print ( 'labels_to_indices: label as keys, and list of sample indices as values' ) print ( labels_to_indices ) print ( ' \\n ' ) print ( 'indices_to_labels: index as key, and corresponding label as value' ) print ( indices_to_labels ) (out): labels_to_indices: label as keys, and list of sample indices as values defaultdict( , {0: [0, 1, 2, 3, 4, ..., 16, 17, 18, 19], 1: [20, 21, 22, 23, 24, 25, ..., 28, 29], ..., 1622: [32440, 32441, 32442, 32443, 32444, ..., 32458, 32459]}) indices_to_labels: index as key, and corresponding label as value defaultdict( , {0: 0, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6, ..., 32458: 1622, 32459: 1622}) So far, we understood the motivation for using MetaDataset . In the next sections, we will discuss exactly how the dictionaries generated using MetaDataset are used for creating a task. UnionMetaDataset - A wrapper for multiple datasets \u00b6 UnionMetaDataset is an extension of MetaDataset , and it is used to merge multiple datasets into one. This is useful when you want to sample heterogenous tasks - tasks in a metabatch being from different distributions. learn2learn implements it by simply remapping the labels of the dataset in a consecutive order. For example, say you have two datasets: \\mathcal{D}_1 : {1600 labels, 32000 samples} and \\mathcal{D}_2 : {400 labels, 12000 samples}. After wrapping the datasets using UnionMetaDataset we will get a MetaDataset that will have 2000 labels and 44000 samples, where the initial 1600 labels (0, 1, 2, ..., 1599) will be from \\mathcal{D}_1 and (1600, 1601, ..., 1999) labels will be from \\mathcal{D}_2 . Same is the case for the indices of the union. A list of datasets is fed as input the UnionMetaDataset Below code shows how a high level implementation of the wrapper: 1 2 3 4 5 6 7 8 dataset_omniglot = l2l . vision . datasets . FullOmniglot ( root = '~\\data' , transform = data_transform , download = True ) dataset_omniglot = l2l . data . MetaDataset ( dataset_omniglot ) # If not wrapped, UnionMetaDataset takes care of it. dataset_fc100 = l2l . vision . datasets . FC100 ( root = '~\\data' , transform = data_transform , download = True ) dataset_fc100 = l2l . data . MetaDataset ( dataset_fc100 ) dataset_cifarfs = l2l . vision . datasets . CIFARFS ( root = '~\\data' , transform = data_transform , download = True ) dataset_cifarfs = l2l . data . MetaDataset ( dataset_cifarfs ) datasets = [ dataset_omniglot , dataset_fc100 , dataset_cifarfs ] union = l2l . data . UnionMetaDataset ( datasets ) # a list of datasets is fed as argument 1 2 3 4 if len ( union . labels_to_indices ) == len ( dataset_omniglot . labels_to_indices ) + len ( dataset_fc100 . labels_to_indices ) + len ( dataset_cifarfs . labels_to_indices ): print ( 'Union was successful' ) else : print ( 'Something is wrong!' ) (out): Union was successful To retrieve a data sample using index, UnionMetaDataset iterates over all the individual datasets as follows: 1 2 3 4 5 6 7 8 9 10 11 12 13 # For sake of example, consider item = 1690 # Union of 2 datasets having [1600, 20] and [600, 10] samples & labels respectively # Thus, item is in D2 having index 89 and say has label as 3 def get_item ( item , datasets , union ): ds_count = 0 for dataset in datasets : # [D1, D2] (D1 -> 1600 samples, D2 -> 600 samples) if ds_count + len ( dataset ) > item : # For D1, condition fails data = list ( dataset [ item - ds_count ]) # searches in the D2's index space data [ 1 ] = union . indices_to_labels [ item ] # changes label from 3 to 22 (20 + 3 - 1) return data ds_count += len ( dataset ) # Now, ds_count = 1600 get_item ( 62000 , datasets , union )[ 1 ] # Returns modified label (out): 1670 FilteredMetaDataset - Filter out unwanted labels \u00b6 FilteredMetaDataset is a wrapper that takes in a MetaDataset and filters it to only include a subset of the desired labels. The labels included are not remapped, and the label value from the original dataset is retained. 1 2 3 4 5 toy_omniglot = l2l . vision . datasets . FullOmniglot ( root = '~\\data' , transform = data_transform , download = True ) toy_omniglot = l2l . data . MetaDataset ( toy_omniglot ) filtered = l2l . data . FilteredMetaDataset ( toy_omniglot , [ 4 , 8 , 2 , 1 , 9 ]) print ( 'Original Labels:' , len ( toy_omniglot . labels )) print ( 'Filtered Labels:' , len ( filtered . labels )) TaskDataset - Core module \u00b6 Introduction \u00b6 This is one of the core module of learn2learn that is used to generate a task from a given input dataset. It takes dataset , and list of task transformations as arguments. The task transformation basically define the kind of tasks that will be generated from the dataset. (For example, KShots transform limits the number of samples per class in a task to K samples per class.) If there are no task transforms, then the task consists of all the samples in the entire dataset. Another argument that TaskDataset takes as input is num_tasks (an integer value) . The value is set depending on how many tasks the user wants to generate. By default, it is kept as -1 , meaning infinite number of tasks will be generated, and a new task is generated on sampling. In the former case, the descriptions of the task will be cached in a dictionary such that if a given task is called again, the description can be loaded instantly rather than generating it once again. What is a task description? \u00b6 A task_description is a list of DataDescription objects with two attributes: index , and transforms . Index corresponds to the index of a sample in the dataset, and transforms is a list of transformations that will be applied to the sample. 1 2 3 4 5 6 7 8 9 10 11 # Transforms: [NWays, KShots, LoadData, RemapLabels, ConsecutiveLabels, RandomClassRotation] description = None for transform in transforms : description = transform ( description ) print ( len ( description ), description ) # Initially, there are all samples present in the dataset # NWays chooses N classes (5 in our case), and samples all the datapoints belonging to only these N classes -> 100 samples (as each class has 20 samples) # Next, KShot chooses K samples (1 samples per class in our case) from each of these N classes -> thus reducing the total samples in the task_description to 5 # And rest of the task transforms do other specicial transformations on the samples without changing the number of samples present in the description How is a task generated? \u00b6 STEP 1 An index between [0, num_tasks) is randomly generated.\\ (If num_tasks = -1 , then index is always 0.) 1 2 3 4 5 6 7 import random def sample ( num_tasks ): i = random . randint ( 0 , num_tasks - 1 ) return i sample ( 20000 ) STEP 2 There are two possible methods for generating task_description : If there's a cached description for the given index, the task_description is assigned the cached description. Otherwise, each transform takes the description returned by the previous transform as argument, and in turn returns a new description. The above only holds true when num_tasks != -1 , for num_tasks = -1 , new description is computed every time. NOTE - It is to be noted task_description and data_description are general methods and can be used for any type of task, be it a classification task, regression task, or even a timeseries task. Below code discusses both the methods. 1 2 3 4 5 6 7 # Method 1: Cached Description # If there's a cached description for the given index, the `task_description` is assigned the cached description. sampled_descriptions = {} # a dictionary for caching descriptions if i not in sampled_descriptions : # i is the index of task between [0, num_tasks] sampled_descriptions [ i ] = 'Call Method 2' # call sample_task_description() task_description = sampled_descriptions [ i ] 1 2 3 4 5 6 7 8 9 10 11 # Method 2: If method 1 fails, or num_tasks = -1 # 2.Each transform takes the description returned by the previous transform as argument, and in turn returns a new description. def sample_task_description ( self ): # Samples a new task description. description = None # initialize description as None at the start if callable ( self . task_transforms ): return self . task_transforms ( description ) for transform in self . task_transforms : # iterate on the transfroms list [NWays, Kshots, LoadData, ...] description = transform ( description ) # use the description generated by the previous transform for the current transform return description # A description modified by all the transforms present in the list. STEP 3 Once a task_description is retrieved/generated, task is generated by applying the list of transformations present in each of the DataDescription objects in the task description list. The transformations mentioned above are different from task_transforms ( task_transforms examples: NWays , KShots , LoadData , etc.) All the data samples generated in the list are accumulated and collated using task_collate . (by default, task_collate is assigned collate.default_collate ) DataDescription object has two attributes: index of the sample and any transforms that need to be applied on the sample. 1 2 3 4 5 6 7 8 9 10 11 def get_task ( self , task_description ): # Given a task description, creates the corresponding batch of data. all_data = [] for data_description in task_description : # iterate over all the samples in task description data = data_description . index # loads index of the sample present in the original dataset for transform in data_description . transforms : # There are two task_transforms (LoadData and RemapLabels) that apply transforms on the data # as of now in the learn2learn library. data = transform ( data ) # applies transform sequentially on the sample data all_data . append ( data ) return self . task_collate ( all_data ) # by default makes use of collate.default_colllate We will be discussing more about the data_description.transforms in the next section, after which there will be more clarity on exactly how the above snippet modifies the data. A few general tips \u00b6 If you have not wrapped the dataset with MetaDataset or its variants, the function will automatically instantiate MetaDataset wrapper. If you are not sure how many tasks you want to generate, use num_tasks = -1 . If num_tasks = N , and you are sampling M tasks where M > N , then M - N tasks will definitely be repeated. In case you want to avoid it, make sure N >= M . Given a list of task transformations, the transformations are applied in the order they are listed. (Task generated using [T_1, T_2] transforms might be different from that generated using [T_2, T_1] . A task is lazily sampled upon indexing, or using .sample() . .sample() is equivalent to indexing, just that before indexing, it randomly generates an index to be indexed. When using KShots transform, query twice the samples required for training. The queried samples will need to be split in half, for training, and evaluation. learn2learn provides a nice utility called partition_task() to partition the data in support and query sets. Check this to know more about it. A quick use case: 1 2 # k-shot learning scenario ( adapt_data , adapt_labels ), ( eval_data , eval_labels ) = partition_task ( data , labels , shots = k ) task_description and data_description are general methods and can be used for any type of task, be it a classification task, regression task, or even a timeseries task. In the next section, we will examine how the task_transforms exactly modify the input dataset to generate a task. 1 2 3 4 class DataDescription : def __init__ ( self , index ): self . index = index self . transforms = [] Task Tranforms - Modifying the input dataset \u00b6 Task transforms are a set of transformations that decide on what kind of a task is generated at the end. We will quickly go over some of the transforms defined in learn2learn , and examine how they are used. To reiterate, a DataDescripton is a class that has two attributes: index, and transforms. Index stores the index of the data sample, and transforms stores list of transforms if there are any (transforms is different from task transforms). In layman's words, it stores indices of samples in the dataset. Only LoadData and RemapLabels add transforms in the list of transform attribute in DataDescription object. High-Level Interface \u00b6 Each of the task transform classes is inherited from TaskTranform class. All of them have a common skeleton in the form of three methods namely: __init__() , __call__() and new_task() . We will now discuss what each of these methods do in general. __init__() Method Initializes the newly created object, in the transform, while also inheriting some arguments such as the dataset from the parent class. Objects / variables that needed to be instantiated only again are defined here. __call__() Method It's a callable method, and is used as a function to write the task_transform specific functionality. Objects / variables that keep on changing are defined here. new_task() Method If the task_description is empty (that is, None ), then this method is called. This method loads all the samples present in the dataset to the task_description . For instance, check the code below. It loads all the samples present in the dataset to the task_description 1 2 3 4 5 6 def new_task ( self ): n = len ( self . dataset ) task_description = [ None ] * n # generate an empty matrix for i in range ( n ): task_description [ i ] = DataDescription ( i ) # Add samples wrapped around DataDescription to the list. return task_description A) FusedNWaysKShots \u00b6 Efficient implementation of KShots , NWays , and FilterLabels transforms. We will be discussing each of the individual transforms in the subsequent sections. If you are planning to make use of more than 1 or these transforms, it is recommended to make use of FusedNWaysKshots transform instead of using each of them individually. B) NWays \u00b6 Keeps samples from N random labels present in the task description. NWays iterate over the current task description to generate a new description as follows: If no task_description is available, NWays randomly samples N labels, and adds all the samples in these N random labels using labels_to_indices dictionary. Else, using indices_to_labels dictionary, it first identifies the unique labels present in the description. Next, it randomly samples N labels from the set of classes. Lastly, it iterates over all the indices present in the description. If the index belongs to the set of these N random labels, the sample is added in the new task_description . 1 2 3 4 5 6 7 8 9 10 11 # Step 1 : When no task description is available, sample pool is entire dataset classes = random . sample ( labels , k = 5 ) # Randomly sample K classes that will be used for generating the task example = [] for cl in classes : # add only samples belonging to these classes for idx in labels_to_indices [ cl ]: # Adds the sample index to the task description wrapped in DataDescription object # task_description.append(DataDescription(idx)) # For sake of explaination I am adding the next step example . append ( idx ) print ( example ) print ( \"Number of samples:\" , len ( example )) # should be 100 as each class has 20 samples in omniglot (out): [14380, 14381, 14382, ..., 31196, 31197, 31198, 31199] Number of samples: 100 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # Step 2 : If there's an existing task description, identify unique labels present in the description def unique_labels (): set_classes = set () # to remove repeated entries for dd in task_description : set_classes . add ( indices_to_labels [ dd . index ]) # adds label of each sample index present in the description classes = list ( set_classes ) return classes # returns unique list of classes # Step 3 : Sample indices belonging the list of randomly choosen classes def n_samples (): result = [] classes = random . sample ( unique_labels (), k = 5 ) for dd in task_description : if indices_to_labels [ dd . index ] in classes : result . append ( dd ) # adds all the indices belonging to the 5 randomly choosen classes return result # return new task description C) KShots \u00b6 It samples K samples per label from all the labels present in the task_desription . Similar to NWays , KShots iterate over the samples present in the current task_description to generate a new one: If task_description is None , load all the samples present in the dataset. Else, generate a class_to_data dictionary that stores label as key and corresponding samples as value. Lastly, K samples are sampled from each of the classes either with or without replacement. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # Step 1 : Task description is None # Load all samples in dataset task_description = [ None ] * len ( dataset ) for i in range ( len ( dataset )): task_description [ i ] = DataDescription ( i ) # Step 2 : Create a dictionary that stores labels and their corresponding samples class_to_data = defaultdict ( list ) for dd in task_description : cls = indices_to_labels [ dd . index ] class_to_data [ cls ] . append ( dd ) # Step 3 : Sample K datapoints from each class with or without replacement # if with replacement, use def sampler ( x , k ): return [ copy . deepcopy ( dd ) for dd in random . choices ( x , k = k )] # else use sampler = random . sample # Lastly, sample the datapoints len ( list ( itertools . chain ( * [ sampler ( dds , k = 2 ) for dds in class_to_data . values ()]))) # here, we are sampling 2 datapoints per class. # There are 1623 classes having 20 samples per class -> 32460 datapoints # Thus, if we sample 2 datapoints per class, that will leave us with 3246 datapoints (out): 3246 D) LoadData \u00b6 Loads a sample from the dataset given its index. Does so by appending a transform lambda x: self.dataset[x] to transforms attribute present in DataDescription for each sample. 1 2 3 # Loads the data using transforms which will be used when calling get_task() in task_dataset.pyx for data_description in task_description : data_description . transforms . append ( lambda x : dataset [ x ]) The above three task transforms are the main transforms that are usually used when generating few-shot learning tasks. These transforms can be used in any other. E) FilterLabels \u00b6 It's a simple transform that removes any unwanted labels from the task_description . In addition to the dataset, it takes a list of labels that need to be included as an argument. It first generates filtered indices that keep a track on all the indices of the samples from the input labels. Next, it iterates over all the indices in the task description, and filters them out if they don't belong to the filtered indices. If you are using FilterLabels transform, it is recommended to use it before NWays, and KShots transforms. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # Step 1 : Generate filtered indices import array filtered_labels = [ 1 , 3 , 5 , 7 , 9 ] filtered_indices = array . array ( 'i' , [ 0 ] * len ( dataset )) for i in range ( len ( dataset )): # will generate a sparse list with labels for the samples with filtered labels filtered_indices [ i ] = int ( indices_to_labels [ i ] in filtered_labels ) # Step 2 : Filter out descriptions that don't belong to the filtered indices result = [] for dd in task_description : if filtered_indices [ dd . index ]: # if index value is non-zero result . append ( dd ) print ( result ) print ( len ( result )) # 20 samples for 5 classes each -> 100 samples F) ConsecutiveLabels \u00b6 The transform re-orders the samples present in the task_description according to the label order consecutively. If you are using RemapLabels transform and keeping shuffle=True , it is recommended to keep ConsecutiveLabels tranform after RemapLabels , otherwise, while they will be homogeneously clustered, the ordering would be random. If you are using ConsecutiveLabels transform before RemapLabels , and want ordered set of labels, then keep shuffle=False . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # How consecutive labels transform is implemented pairs = [( dd , indices_to_labels [ dd . index ]) for dd in task_description ] pairs = sorted ( pairs , key = lambda x : x [ 1 ]) # sort by labels x[0] : index, x[1] : label print ([ p [ 0 ] for p in pairs ]) # Example demonstration toy_dataset = [ i for i in range ( 1000 )] # generate a toy dataset toy_indices_to_labels = {} for i in toy_dataset : toy_indices_to_labels [ i ] = random . randint ( 0 , 99 ) # generate a toy indices to labels dictionary toy_list = [ i for i in range ( 1000 )] # generate a toy samples list toy_task_description = [ random . choice ( toy_list ) for _ in range ( 10 )] # generate a random task description pairs = [( dd , toy_indices_to_labels [ dd ]) for dd in toy_task_description ] pairs = sorted ( pairs , key = lambda x : x [ 1 ]) # sort the pairs list by using the second element (labels) in the tuple print ( ' \\n ' ) print ([ p [ 0 ] for p in pairs ]) # prints index (not ordered) print ([ p [ 1 ] for p in pairs ]) # prints label (ordered list) (out): [271, 702, 756, 319, 948, 840, 843, 741, 89, 413] [13, 33, 34, 46, 56, 57, 62, 70, 76, 92] G) RemapLabels \u00b6 The transform maps the labels of input to 0, 1, ..., N (given N unique set of labels). For example , if input task_description consists of samples from 3 labels namely 71, 14 and 89, then the transform maps the labels to 0, 1 and 2. Compulsorily needs to be present after LoadData transform in the transform list, otherwise, will give a TypeError: int is not iterable . The error occurs because RemapLabels expects the input to be of iterable form. Thus, unless you load data using LoadData prior to it, it will try to iterate over sample index , which is an int , and not an iterable. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import traceback toy_transforms = [ NWays ( omniglot , 5 ), # Samples N random classes per task (here, N=5) KShots ( omniglot , 2 ), # Samples K samples per class from the above N classes (here, K=1) RemapLabels ( omniglot ), LoadData ( omniglot ), # Loads a sample from the dataset ConsecutiveLabels ( omniglot ), # Re-orders samples s.t. they are sorted in consecutive order RandomClassRotation ( omniglot , [ 0 , 90 , 180 , 270 ]) # Randomly rotate sample over x degrees (only for vision tasks) ] toy_taskset = l2l . data . TaskDataset ( omniglot , toy_transforms , num_tasks = 20000 ) try : print ( len ( toy_taskset . sample ())) # Expected error as RemapLabels is used before LoadData except TypeError : print ( traceback . format_exc ()) 1 2 3 4 5 6 7 8 9 ( output ) : Traceback ( most recent call last ) : File \"<ipython-input-27-4c0558e6745b>\" , line 13 , in <module> print ( len ( toy_taskset.sample ())) # Expected error as RemapLabels is used before LoadData File \"learn2learn/data/task_dataset.pyx\" , line 158 , in learn2learn.data.task_dataset.CythonTaskDataset.sample File \"learn2learn/data/task_dataset.pyx\" , line 173 , in learn2learn.data.task_dataset.CythonTaskDataset.__getitem__ File \"learn2learn/data/task_dataset.pyx\" , line 142 , in learn2learn.data.task_dataset.CythonTaskDataset.get_task File \"learn2learn/data/transforms.pyx\" , line 201 , in learn2learn.data.transforms.RemapLabels.remap TypeError: 'int' object is not iterable Conclusion \u00b6 Thus, we studied how learn2learn simplifies the process of generating few-shot learning tasks. For more details, have a look at: Official Documentation Module Scripts - GitHub learn2learn provides benchmarks for some of the commonly used computer vision datasets such as omniglot , fc100 , mini-imagenet , cirfarfs and tiered-imagenet . The benchmarks are available at this link. They are very easy to use, and can be used as follows: 1 2 3 4 5 6 # data_name: 'omniglot', 'fc100', 'cifarfs', 'mini-imagenet', 'tiered-imagenet' # N: No of ways, K: No of shots tasksets = l2l . vision . benchmarks . get_tasksets ( data_name , train_ways = N , train_samples = 2 * K , test_ways = N , test_samples = 2 * K , num_tasks =- 1 , root = '~/data' ) X1 , y1 = tasksets . train . sample () X2 , y2 = tasksets . validation . sample () X3 , y3 = tasksets . test . sample () If you have any other queries - feel free to ask questions on the library's slack channel, or open an issue here . Thank you!","title":"Demystifying Task-Transforms"},{"location":"tutorials/task_transform_tutorial/transform_tutorial/#demystifying-task-transforms","text":"Written by Varad Pimpalkhute on 02/18/2022. Notebook of this tutorial is available on Colab Notebook . In this tutorial, we will explore in depth one of the core utilities learn2learn library provides - Task Generators.","title":"Demystifying Task-Transforms"},{"location":"tutorials/task_transform_tutorial/transform_tutorial/#overview","text":"We will first discuss the motivation behind generating tasks. (Those familiar with meta-learning can skip this section.) Next, we will have a high-level overview of the overall pipeline used for generating tasks using learn2learn . MetaDataset is used fast indexing, and accelerates the process of generating few-shot learning tasks. UnionMetaDataset and FilteredMetaDataset are extensions of MetaDataset that can further provide customised utility. UnionMetaDataset builds up on MetaDataset to construct a union of multiple input datasets, and FilteredMetaDataset takes in a MetaDataset and filters it to include only the required labels. TaskDataset is the core module that generates tasks from input dataset. Tasks are lazily sampled upon indexing or calling .sample() method. Lastly, we study different task transforms defined in learn2learn that modifies the input data such that a customised task is generated.","title":"Overview"},{"location":"tutorials/task_transform_tutorial/transform_tutorial/#motivation-for-generating-tasks","text":"","title":"Motivation for generating tasks"},{"location":"tutorials/task_transform_tutorial/transform_tutorial/#what-is-a-task","text":"Let's first start with understanding what is a task. The definition of a task varies from one application to other, but in context of few-shot learning, a task is a supervised-learning approach (e.g., classification, regression) trained over a collection of datapoints (images, in context of vision) that are sampled from the same distribution. For example , a task may consist of 5 images from 5 different classes - flower, cup, bird, fruit, clock (say, 1 image per class), all sampled from the same distribution. Now, the objective of the task might be to classify the images present at test time amongst the five classes - that is, minimize over the loss function. Few-Shot Classification Tasks. Image source: Cloudera Fast Forward Report on Meta-Learning .","title":"What is a task?"},{"location":"tutorials/task_transform_tutorial/transform_tutorial/#how-is-a-task-used-in-context-of-meta-learning","text":"Meta-learning used in the context of few-shot learning paradigm trains over different tasks (each task consists of limited number of samples) over multiple iterations of training. For example, gradient-based meta-learners learn a model initialization prior such that the model converges to the global minima on unseen tasks (tasks that were not encountered during training) using few samples/datapoints.","title":"How is a task used in context of meta-learning?"},{"location":"tutorials/task_transform_tutorial/transform_tutorial/#how-is-a-task-generated","text":"In layman's terms, few-shot classification experiment is set up as a N-wayed K-shot problem. Meaning, the model needs to learn how to classify an input task over N different classes given K examples per class during training. Thus, we need to generate 'M' such tasks for training, and inferencing the meta-learner. Summarizing , we require to: Iterate over classes and their respective samples present in the dataset rapidly in order to generate a task. Write a protocol that generates a task that adhers to the few-shot paradigm (that is, N-way K-shot problem) . Incorporate additional transforms (say, augmentation of data) . Generate M randomly sampled tasks for training and inferencing. Given any input dataset, learn2learn makes it easy for generating custom tasks depending on the user's usecase. 1 2 3 4 5 6 7 8 # Import modules that would be used later. import os , random , pickle , itertools , copy import learn2learn as l2l import torchvision as tv from PIL.Image import LANCZOS from learn2learn.data.transforms import NWays , KShots , LoadData , RemapLabels , ConsecutiveLabels from learn2learn.vision.transforms import RandomClassRotation from collections import defaultdict","title":"How is a task generated?"},{"location":"tutorials/task_transform_tutorial/transform_tutorial/#overview-of-pipeline-for-generating-tasks","text":"Given any input dataset, learn2learn makes it easy for generating custom tasks depending on the user's usecase. A high-level overall pipeline is shown in the diagram below: The dataset consists of 100 different classes, having 5 samples per class. The objective is to generate N-wayed K-shot task (say, 3-way 2-shot task from the given dataset.) Pipeline for generating tasks in learn2learn. The below code snippet shows to generate customised tasks using any input custom using learn2learn . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 # 1. Apply transforms on input data if any (eg., Resizing, converting arrays to tensors) data_transform = tv . transforms . Compose ([ tv . transforms . Resize (( 28 , 28 ), interpolation = LANCZOS ), tv . transforms . ToTensor ()]) # 2. Download the dataset, and apply the above transforms on each of the samples dataset = l2l . vision . datasets . FullOmniglot ( root = '~\\data' , transform = data_transform , download = True ) # Load your custom dataset # 3. Wrap the dataset using MetaDataset to enable fast indexing omniglot = l2l . data . MetaDataset ( dataset ) # Use MetaDataset to do fast indexing of samples # 4. Specify transforms to be used for generating tasks transforms = [ NWays ( omniglot , 5 ), # Samples N random classes per task (here, N = 5) KShots ( omniglot , 1 ), # Samples K samples per class from the above N classes (here, K = 1) LoadData ( omniglot ), # Loads a sample from the dataset RemapLabels ( omniglot ), # Remaps labels starting from zero ConsecutiveLabels ( omniglot ), # Re-orders samples s.t. they are sorted in consecutive order RandomClassRotation ( omniglot , [ 0 , 90 , 180 , 270 ]) # Randomly rotate sample over x degrees (only for vision tasks) ] # 5. Generate set of tasks using the dataset, and transforms taskset = l2l . data . TaskDataset ( dataset = omniglot , task_transforms = transforms , num_tasks = 10 ) # Creates sets of tasks from the dataset # Now sample a task from the taskset X , y = taskset . sample () # or, you can also sample this way: for task in taskset : X , y = task print ( X . shape ) (out): torch.Size([5, 1, 28, 28]) And that's it! You have now generated one task randomly sampled from the omniglot dataset distribution. For generating M tasks, you will need to sample the taskset M times. For the rest of the tutorial, we will inspect each of the modules present in the above code, and discuss a few general strategies that can be used while generating tasks efficiently.","title":"Overview of pipeline for generating tasks"},{"location":"tutorials/task_transform_tutorial/transform_tutorial/#metadataset-a-wrapper-for-fast-indexing-of-samples","text":"At a high level, MetaDataset is a wrapper that enables fast indexing of samples of a given class in a dataset. The motivation behind building is to decrease the \\mathcal{O}(n) time to \\mathcal{O}(1) everytime we iterate over a dataset to generate tasks. Naturally, the time saved increases as the dataset size keeps on increasing. Note : The input dataset needs to be iterable. learn2learn does this by maintaining two dictionaries for each classification dataset: 1. labels_to_indices : A dictionary that maintains labels of classes as keys, and the corresponding indices of samples within the class in form of list as values. 2. indices_to_labels : As the name suggests, a dictionary is formed with indices of samples as key, and their corresponding class labels as value. This feature comes in handy while generating tasks. For example, if you are sampling a task having N classes (say, N=5) , then using labels_to_indices dictionary to identify all the samples belonging to this set of 5 classes ( \\mathcal{O}(c) ) will be much more faster than iterating all the samples ( \\mathcal{O}(n) ) . 1 2 3 4 5 6 7 8 9 10 11 12 13 from collections import defaultdict labels_to_indices = defaultdict ( list ) # each label will store list of sample indices indices_to_labels = defaultdict ( int ) # each index will store corresponding sample's label for i in range ( len ( dataset )): # iterate over all samples label = dataset [ i ][ 1 ] # load label if hasattr ( label , 'item' ): label = dataset [ i ][ 1 ] . item () # if label is a Tensor, then take get the scalar value labels_to_indices [ label ] . append ( i ) # append sample's index to the given class indices_to_labels [ i ] = label # assign label to the given index Any one of the two dictionaries can also be optionally passed as an argument upon instantiation, and the other dictionary is built using this dictionary (See Line 81 - Line 90 on GitHub.)","title":"MetaDataset - A wrapper for fast indexing of samples."},{"location":"tutorials/task_transform_tutorial/transform_tutorial/#bookkeeping","text":"learn2learn also provides another utility in the form of an attribute _bookkeeping_path . If the input dataset has the given attribute, then the built attributes (namely, the two dictionaries, and list of labels) will be cached on disk for latter use. It is recommended to use this utility if: If the dataset size is large, as it can take hours for instantiating it the first time. If you are going to use the dataset again for training. (Iterating over all the samples will be much slower than loading it from disk) To use the bookkeeping utility, while loading your custom dataset, you will need to add an additional attribute to it. For example, we add _bookkeeping_path attribute while generating FC100 dataset as follows: self._bookkeeping_path = os.path.join(self.root, 'fc100-bookkeeping-' + mode + '.pkl') where, mode is either train, validation, or test (depends on how you are defining your dataset. It's also possible that you are loading the entire dataset, and then creating train-valid-test splits. In that case, you can remove the mode variable) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import pickle # The variables can be loaded from the saved .pkl file with open ( '~\\data/omniglot-bookkeeping.pkl' , 'rb' ) as f : _bookkeeping = pickle . load ( f ) # In _bookkeeping, the three attributes are saved in the form of a dictionary labels_to_indices = _bookkeeping [ 'labels_to_indices' ] indices_to_labels = _bookkeeping [ 'indices_to_labels' ] labels = _bookkeeping [ 'labels' ] print ( 'labels_to_indices: label as keys, and list of sample indices as values' ) print ( labels_to_indices ) print ( ' \\n ' ) print ( 'indices_to_labels: index as key, and corresponding label as value' ) print ( indices_to_labels ) (out): labels_to_indices: label as keys, and list of sample indices as values defaultdict( , {0: [0, 1, 2, 3, 4, ..., 16, 17, 18, 19], 1: [20, 21, 22, 23, 24, 25, ..., 28, 29], ..., 1622: [32440, 32441, 32442, 32443, 32444, ..., 32458, 32459]}) indices_to_labels: index as key, and corresponding label as value defaultdict( , {0: 0, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6, ..., 32458: 1622, 32459: 1622}) So far, we understood the motivation for using MetaDataset . In the next sections, we will discuss exactly how the dictionaries generated using MetaDataset are used for creating a task.","title":"Bookkeeping"},{"location":"tutorials/task_transform_tutorial/transform_tutorial/#unionmetadataset-a-wrapper-for-multiple-datasets","text":"UnionMetaDataset is an extension of MetaDataset , and it is used to merge multiple datasets into one. This is useful when you want to sample heterogenous tasks - tasks in a metabatch being from different distributions. learn2learn implements it by simply remapping the labels of the dataset in a consecutive order. For example, say you have two datasets: \\mathcal{D}_1 : {1600 labels, 32000 samples} and \\mathcal{D}_2 : {400 labels, 12000 samples}. After wrapping the datasets using UnionMetaDataset we will get a MetaDataset that will have 2000 labels and 44000 samples, where the initial 1600 labels (0, 1, 2, ..., 1599) will be from \\mathcal{D}_1 and (1600, 1601, ..., 1999) labels will be from \\mathcal{D}_2 . Same is the case for the indices of the union. A list of datasets is fed as input the UnionMetaDataset Below code shows how a high level implementation of the wrapper: 1 2 3 4 5 6 7 8 dataset_omniglot = l2l . vision . datasets . FullOmniglot ( root = '~\\data' , transform = data_transform , download = True ) dataset_omniglot = l2l . data . MetaDataset ( dataset_omniglot ) # If not wrapped, UnionMetaDataset takes care of it. dataset_fc100 = l2l . vision . datasets . FC100 ( root = '~\\data' , transform = data_transform , download = True ) dataset_fc100 = l2l . data . MetaDataset ( dataset_fc100 ) dataset_cifarfs = l2l . vision . datasets . CIFARFS ( root = '~\\data' , transform = data_transform , download = True ) dataset_cifarfs = l2l . data . MetaDataset ( dataset_cifarfs ) datasets = [ dataset_omniglot , dataset_fc100 , dataset_cifarfs ] union = l2l . data . UnionMetaDataset ( datasets ) # a list of datasets is fed as argument 1 2 3 4 if len ( union . labels_to_indices ) == len ( dataset_omniglot . labels_to_indices ) + len ( dataset_fc100 . labels_to_indices ) + len ( dataset_cifarfs . labels_to_indices ): print ( 'Union was successful' ) else : print ( 'Something is wrong!' ) (out): Union was successful To retrieve a data sample using index, UnionMetaDataset iterates over all the individual datasets as follows: 1 2 3 4 5 6 7 8 9 10 11 12 13 # For sake of example, consider item = 1690 # Union of 2 datasets having [1600, 20] and [600, 10] samples & labels respectively # Thus, item is in D2 having index 89 and say has label as 3 def get_item ( item , datasets , union ): ds_count = 0 for dataset in datasets : # [D1, D2] (D1 -> 1600 samples, D2 -> 600 samples) if ds_count + len ( dataset ) > item : # For D1, condition fails data = list ( dataset [ item - ds_count ]) # searches in the D2's index space data [ 1 ] = union . indices_to_labels [ item ] # changes label from 3 to 22 (20 + 3 - 1) return data ds_count += len ( dataset ) # Now, ds_count = 1600 get_item ( 62000 , datasets , union )[ 1 ] # Returns modified label (out): 1670","title":"UnionMetaDataset - A wrapper for multiple datasets"},{"location":"tutorials/task_transform_tutorial/transform_tutorial/#filteredmetadataset-filter-out-unwanted-labels","text":"FilteredMetaDataset is a wrapper that takes in a MetaDataset and filters it to only include a subset of the desired labels. The labels included are not remapped, and the label value from the original dataset is retained. 1 2 3 4 5 toy_omniglot = l2l . vision . datasets . FullOmniglot ( root = '~\\data' , transform = data_transform , download = True ) toy_omniglot = l2l . data . MetaDataset ( toy_omniglot ) filtered = l2l . data . FilteredMetaDataset ( toy_omniglot , [ 4 , 8 , 2 , 1 , 9 ]) print ( 'Original Labels:' , len ( toy_omniglot . labels )) print ( 'Filtered Labels:' , len ( filtered . labels ))","title":"FilteredMetaDataset - Filter out unwanted labels"},{"location":"tutorials/task_transform_tutorial/transform_tutorial/#taskdataset-core-module","text":"","title":"TaskDataset - Core module"},{"location":"tutorials/task_transform_tutorial/transform_tutorial/#introduction","text":"This is one of the core module of learn2learn that is used to generate a task from a given input dataset. It takes dataset , and list of task transformations as arguments. The task transformation basically define the kind of tasks that will be generated from the dataset. (For example, KShots transform limits the number of samples per class in a task to K samples per class.) If there are no task transforms, then the task consists of all the samples in the entire dataset. Another argument that TaskDataset takes as input is num_tasks (an integer value) . The value is set depending on how many tasks the user wants to generate. By default, it is kept as -1 , meaning infinite number of tasks will be generated, and a new task is generated on sampling. In the former case, the descriptions of the task will be cached in a dictionary such that if a given task is called again, the description can be loaded instantly rather than generating it once again.","title":"Introduction"},{"location":"tutorials/task_transform_tutorial/transform_tutorial/#what-is-a-task-description","text":"A task_description is a list of DataDescription objects with two attributes: index , and transforms . Index corresponds to the index of a sample in the dataset, and transforms is a list of transformations that will be applied to the sample. 1 2 3 4 5 6 7 8 9 10 11 # Transforms: [NWays, KShots, LoadData, RemapLabels, ConsecutiveLabels, RandomClassRotation] description = None for transform in transforms : description = transform ( description ) print ( len ( description ), description ) # Initially, there are all samples present in the dataset # NWays chooses N classes (5 in our case), and samples all the datapoints belonging to only these N classes -> 100 samples (as each class has 20 samples) # Next, KShot chooses K samples (1 samples per class in our case) from each of these N classes -> thus reducing the total samples in the task_description to 5 # And rest of the task transforms do other specicial transformations on the samples without changing the number of samples present in the description","title":"What is a task description?"},{"location":"tutorials/task_transform_tutorial/transform_tutorial/#how-is-a-task-generated_1","text":"STEP 1 An index between [0, num_tasks) is randomly generated.\\ (If num_tasks = -1 , then index is always 0.) 1 2 3 4 5 6 7 import random def sample ( num_tasks ): i = random . randint ( 0 , num_tasks - 1 ) return i sample ( 20000 ) STEP 2 There are two possible methods for generating task_description : If there's a cached description for the given index, the task_description is assigned the cached description. Otherwise, each transform takes the description returned by the previous transform as argument, and in turn returns a new description. The above only holds true when num_tasks != -1 , for num_tasks = -1 , new description is computed every time. NOTE - It is to be noted task_description and data_description are general methods and can be used for any type of task, be it a classification task, regression task, or even a timeseries task. Below code discusses both the methods. 1 2 3 4 5 6 7 # Method 1: Cached Description # If there's a cached description for the given index, the `task_description` is assigned the cached description. sampled_descriptions = {} # a dictionary for caching descriptions if i not in sampled_descriptions : # i is the index of task between [0, num_tasks] sampled_descriptions [ i ] = 'Call Method 2' # call sample_task_description() task_description = sampled_descriptions [ i ] 1 2 3 4 5 6 7 8 9 10 11 # Method 2: If method 1 fails, or num_tasks = -1 # 2.Each transform takes the description returned by the previous transform as argument, and in turn returns a new description. def sample_task_description ( self ): # Samples a new task description. description = None # initialize description as None at the start if callable ( self . task_transforms ): return self . task_transforms ( description ) for transform in self . task_transforms : # iterate on the transfroms list [NWays, Kshots, LoadData, ...] description = transform ( description ) # use the description generated by the previous transform for the current transform return description # A description modified by all the transforms present in the list. STEP 3 Once a task_description is retrieved/generated, task is generated by applying the list of transformations present in each of the DataDescription objects in the task description list. The transformations mentioned above are different from task_transforms ( task_transforms examples: NWays , KShots , LoadData , etc.) All the data samples generated in the list are accumulated and collated using task_collate . (by default, task_collate is assigned collate.default_collate ) DataDescription object has two attributes: index of the sample and any transforms that need to be applied on the sample. 1 2 3 4 5 6 7 8 9 10 11 def get_task ( self , task_description ): # Given a task description, creates the corresponding batch of data. all_data = [] for data_description in task_description : # iterate over all the samples in task description data = data_description . index # loads index of the sample present in the original dataset for transform in data_description . transforms : # There are two task_transforms (LoadData and RemapLabels) that apply transforms on the data # as of now in the learn2learn library. data = transform ( data ) # applies transform sequentially on the sample data all_data . append ( data ) return self . task_collate ( all_data ) # by default makes use of collate.default_colllate We will be discussing more about the data_description.transforms in the next section, after which there will be more clarity on exactly how the above snippet modifies the data.","title":"How is a task generated?"},{"location":"tutorials/task_transform_tutorial/transform_tutorial/#a-few-general-tips","text":"If you have not wrapped the dataset with MetaDataset or its variants, the function will automatically instantiate MetaDataset wrapper. If you are not sure how many tasks you want to generate, use num_tasks = -1 . If num_tasks = N , and you are sampling M tasks where M > N , then M - N tasks will definitely be repeated. In case you want to avoid it, make sure N >= M . Given a list of task transformations, the transformations are applied in the order they are listed. (Task generated using [T_1, T_2] transforms might be different from that generated using [T_2, T_1] . A task is lazily sampled upon indexing, or using .sample() . .sample() is equivalent to indexing, just that before indexing, it randomly generates an index to be indexed. When using KShots transform, query twice the samples required for training. The queried samples will need to be split in half, for training, and evaluation. learn2learn provides a nice utility called partition_task() to partition the data in support and query sets. Check this to know more about it. A quick use case: 1 2 # k-shot learning scenario ( adapt_data , adapt_labels ), ( eval_data , eval_labels ) = partition_task ( data , labels , shots = k ) task_description and data_description are general methods and can be used for any type of task, be it a classification task, regression task, or even a timeseries task. In the next section, we will examine how the task_transforms exactly modify the input dataset to generate a task. 1 2 3 4 class DataDescription : def __init__ ( self , index ): self . index = index self . transforms = []","title":"A few general tips"},{"location":"tutorials/task_transform_tutorial/transform_tutorial/#task-tranforms-modifying-the-input-dataset","text":"Task transforms are a set of transformations that decide on what kind of a task is generated at the end. We will quickly go over some of the transforms defined in learn2learn , and examine how they are used. To reiterate, a DataDescripton is a class that has two attributes: index, and transforms. Index stores the index of the data sample, and transforms stores list of transforms if there are any (transforms is different from task transforms). In layman's words, it stores indices of samples in the dataset. Only LoadData and RemapLabels add transforms in the list of transform attribute in DataDescription object.","title":"Task Tranforms - Modifying the input dataset"},{"location":"tutorials/task_transform_tutorial/transform_tutorial/#high-level-interface","text":"Each of the task transform classes is inherited from TaskTranform class. All of them have a common skeleton in the form of three methods namely: __init__() , __call__() and new_task() . We will now discuss what each of these methods do in general. __init__() Method Initializes the newly created object, in the transform, while also inheriting some arguments such as the dataset from the parent class. Objects / variables that needed to be instantiated only again are defined here. __call__() Method It's a callable method, and is used as a function to write the task_transform specific functionality. Objects / variables that keep on changing are defined here. new_task() Method If the task_description is empty (that is, None ), then this method is called. This method loads all the samples present in the dataset to the task_description . For instance, check the code below. It loads all the samples present in the dataset to the task_description 1 2 3 4 5 6 def new_task ( self ): n = len ( self . dataset ) task_description = [ None ] * n # generate an empty matrix for i in range ( n ): task_description [ i ] = DataDescription ( i ) # Add samples wrapped around DataDescription to the list. return task_description","title":"High-Level Interface"},{"location":"tutorials/task_transform_tutorial/transform_tutorial/#a-fusednwayskshots","text":"Efficient implementation of KShots , NWays , and FilterLabels transforms. We will be discussing each of the individual transforms in the subsequent sections. If you are planning to make use of more than 1 or these transforms, it is recommended to make use of FusedNWaysKshots transform instead of using each of them individually.","title":"A) FusedNWaysKShots"},{"location":"tutorials/task_transform_tutorial/transform_tutorial/#b-nways","text":"Keeps samples from N random labels present in the task description. NWays iterate over the current task description to generate a new description as follows: If no task_description is available, NWays randomly samples N labels, and adds all the samples in these N random labels using labels_to_indices dictionary. Else, using indices_to_labels dictionary, it first identifies the unique labels present in the description. Next, it randomly samples N labels from the set of classes. Lastly, it iterates over all the indices present in the description. If the index belongs to the set of these N random labels, the sample is added in the new task_description . 1 2 3 4 5 6 7 8 9 10 11 # Step 1 : When no task description is available, sample pool is entire dataset classes = random . sample ( labels , k = 5 ) # Randomly sample K classes that will be used for generating the task example = [] for cl in classes : # add only samples belonging to these classes for idx in labels_to_indices [ cl ]: # Adds the sample index to the task description wrapped in DataDescription object # task_description.append(DataDescription(idx)) # For sake of explaination I am adding the next step example . append ( idx ) print ( example ) print ( \"Number of samples:\" , len ( example )) # should be 100 as each class has 20 samples in omniglot (out): [14380, 14381, 14382, ..., 31196, 31197, 31198, 31199] Number of samples: 100 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # Step 2 : If there's an existing task description, identify unique labels present in the description def unique_labels (): set_classes = set () # to remove repeated entries for dd in task_description : set_classes . add ( indices_to_labels [ dd . index ]) # adds label of each sample index present in the description classes = list ( set_classes ) return classes # returns unique list of classes # Step 3 : Sample indices belonging the list of randomly choosen classes def n_samples (): result = [] classes = random . sample ( unique_labels (), k = 5 ) for dd in task_description : if indices_to_labels [ dd . index ] in classes : result . append ( dd ) # adds all the indices belonging to the 5 randomly choosen classes return result # return new task description","title":"B) NWays"},{"location":"tutorials/task_transform_tutorial/transform_tutorial/#c-kshots","text":"It samples K samples per label from all the labels present in the task_desription . Similar to NWays , KShots iterate over the samples present in the current task_description to generate a new one: If task_description is None , load all the samples present in the dataset. Else, generate a class_to_data dictionary that stores label as key and corresponding samples as value. Lastly, K samples are sampled from each of the classes either with or without replacement. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # Step 1 : Task description is None # Load all samples in dataset task_description = [ None ] * len ( dataset ) for i in range ( len ( dataset )): task_description [ i ] = DataDescription ( i ) # Step 2 : Create a dictionary that stores labels and their corresponding samples class_to_data = defaultdict ( list ) for dd in task_description : cls = indices_to_labels [ dd . index ] class_to_data [ cls ] . append ( dd ) # Step 3 : Sample K datapoints from each class with or without replacement # if with replacement, use def sampler ( x , k ): return [ copy . deepcopy ( dd ) for dd in random . choices ( x , k = k )] # else use sampler = random . sample # Lastly, sample the datapoints len ( list ( itertools . chain ( * [ sampler ( dds , k = 2 ) for dds in class_to_data . values ()]))) # here, we are sampling 2 datapoints per class. # There are 1623 classes having 20 samples per class -> 32460 datapoints # Thus, if we sample 2 datapoints per class, that will leave us with 3246 datapoints (out): 3246","title":"C) KShots"},{"location":"tutorials/task_transform_tutorial/transform_tutorial/#d-loaddata","text":"Loads a sample from the dataset given its index. Does so by appending a transform lambda x: self.dataset[x] to transforms attribute present in DataDescription for each sample. 1 2 3 # Loads the data using transforms which will be used when calling get_task() in task_dataset.pyx for data_description in task_description : data_description . transforms . append ( lambda x : dataset [ x ]) The above three task transforms are the main transforms that are usually used when generating few-shot learning tasks. These transforms can be used in any other.","title":"D) LoadData"},{"location":"tutorials/task_transform_tutorial/transform_tutorial/#e-filterlabels","text":"It's a simple transform that removes any unwanted labels from the task_description . In addition to the dataset, it takes a list of labels that need to be included as an argument. It first generates filtered indices that keep a track on all the indices of the samples from the input labels. Next, it iterates over all the indices in the task description, and filters them out if they don't belong to the filtered indices. If you are using FilterLabels transform, it is recommended to use it before NWays, and KShots transforms. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # Step 1 : Generate filtered indices import array filtered_labels = [ 1 , 3 , 5 , 7 , 9 ] filtered_indices = array . array ( 'i' , [ 0 ] * len ( dataset )) for i in range ( len ( dataset )): # will generate a sparse list with labels for the samples with filtered labels filtered_indices [ i ] = int ( indices_to_labels [ i ] in filtered_labels ) # Step 2 : Filter out descriptions that don't belong to the filtered indices result = [] for dd in task_description : if filtered_indices [ dd . index ]: # if index value is non-zero result . append ( dd ) print ( result ) print ( len ( result )) # 20 samples for 5 classes each -> 100 samples","title":"E) FilterLabels"},{"location":"tutorials/task_transform_tutorial/transform_tutorial/#f-consecutivelabels","text":"The transform re-orders the samples present in the task_description according to the label order consecutively. If you are using RemapLabels transform and keeping shuffle=True , it is recommended to keep ConsecutiveLabels tranform after RemapLabels , otherwise, while they will be homogeneously clustered, the ordering would be random. If you are using ConsecutiveLabels transform before RemapLabels , and want ordered set of labels, then keep shuffle=False . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # How consecutive labels transform is implemented pairs = [( dd , indices_to_labels [ dd . index ]) for dd in task_description ] pairs = sorted ( pairs , key = lambda x : x [ 1 ]) # sort by labels x[0] : index, x[1] : label print ([ p [ 0 ] for p in pairs ]) # Example demonstration toy_dataset = [ i for i in range ( 1000 )] # generate a toy dataset toy_indices_to_labels = {} for i in toy_dataset : toy_indices_to_labels [ i ] = random . randint ( 0 , 99 ) # generate a toy indices to labels dictionary toy_list = [ i for i in range ( 1000 )] # generate a toy samples list toy_task_description = [ random . choice ( toy_list ) for _ in range ( 10 )] # generate a random task description pairs = [( dd , toy_indices_to_labels [ dd ]) for dd in toy_task_description ] pairs = sorted ( pairs , key = lambda x : x [ 1 ]) # sort the pairs list by using the second element (labels) in the tuple print ( ' \\n ' ) print ([ p [ 0 ] for p in pairs ]) # prints index (not ordered) print ([ p [ 1 ] for p in pairs ]) # prints label (ordered list) (out): [271, 702, 756, 319, 948, 840, 843, 741, 89, 413] [13, 33, 34, 46, 56, 57, 62, 70, 76, 92]","title":"F) ConsecutiveLabels"},{"location":"tutorials/task_transform_tutorial/transform_tutorial/#g-remaplabels","text":"The transform maps the labels of input to 0, 1, ..., N (given N unique set of labels). For example , if input task_description consists of samples from 3 labels namely 71, 14 and 89, then the transform maps the labels to 0, 1 and 2. Compulsorily needs to be present after LoadData transform in the transform list, otherwise, will give a TypeError: int is not iterable . The error occurs because RemapLabels expects the input to be of iterable form. Thus, unless you load data using LoadData prior to it, it will try to iterate over sample index , which is an int , and not an iterable. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import traceback toy_transforms = [ NWays ( omniglot , 5 ), # Samples N random classes per task (here, N=5) KShots ( omniglot , 2 ), # Samples K samples per class from the above N classes (here, K=1) RemapLabels ( omniglot ), LoadData ( omniglot ), # Loads a sample from the dataset ConsecutiveLabels ( omniglot ), # Re-orders samples s.t. they are sorted in consecutive order RandomClassRotation ( omniglot , [ 0 , 90 , 180 , 270 ]) # Randomly rotate sample over x degrees (only for vision tasks) ] toy_taskset = l2l . data . TaskDataset ( omniglot , toy_transforms , num_tasks = 20000 ) try : print ( len ( toy_taskset . sample ())) # Expected error as RemapLabels is used before LoadData except TypeError : print ( traceback . format_exc ()) 1 2 3 4 5 6 7 8 9 ( output ) : Traceback ( most recent call last ) : File \"<ipython-input-27-4c0558e6745b>\" , line 13 , in <module> print ( len ( toy_taskset.sample ())) # Expected error as RemapLabels is used before LoadData File \"learn2learn/data/task_dataset.pyx\" , line 158 , in learn2learn.data.task_dataset.CythonTaskDataset.sample File \"learn2learn/data/task_dataset.pyx\" , line 173 , in learn2learn.data.task_dataset.CythonTaskDataset.__getitem__ File \"learn2learn/data/task_dataset.pyx\" , line 142 , in learn2learn.data.task_dataset.CythonTaskDataset.get_task File \"learn2learn/data/transforms.pyx\" , line 201 , in learn2learn.data.transforms.RemapLabels.remap TypeError: 'int' object is not iterable","title":"G) RemapLabels"},{"location":"tutorials/task_transform_tutorial/transform_tutorial/#conclusion","text":"Thus, we studied how learn2learn simplifies the process of generating few-shot learning tasks. For more details, have a look at: Official Documentation Module Scripts - GitHub learn2learn provides benchmarks for some of the commonly used computer vision datasets such as omniglot , fc100 , mini-imagenet , cirfarfs and tiered-imagenet . The benchmarks are available at this link. They are very easy to use, and can be used as follows: 1 2 3 4 5 6 # data_name: 'omniglot', 'fc100', 'cifarfs', 'mini-imagenet', 'tiered-imagenet' # N: No of ways, K: No of shots tasksets = l2l . vision . benchmarks . get_tasksets ( data_name , train_ways = N , train_samples = 2 * K , test_ways = N , test_samples = 2 * K , num_tasks =- 1 , root = '~/data' ) X1 , y1 = tasksets . train . sample () X2 , y2 = tasksets . validation . sample () X3 , y3 = tasksets . test . sample () If you have any other queries - feel free to ask questions on the library's slack channel, or open an issue here . Thank you!","title":"Conclusion"}]}